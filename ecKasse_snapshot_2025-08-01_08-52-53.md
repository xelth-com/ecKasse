# AI Instructions

## 1. How to Read This Snapshot

This document is a self-contained, single-file snapshot of the **ecKasse** software repository, generated by the `eck-snapshot` tool on **2025-08-01T08:52:53.181Z**. It is designed to provide a Large Language Model (LLM) with the complete context of a project.

* **Source of Truth:** Treat this snapshot as the complete and authoritative source code.
* **Structure:** The file contains a **Directory Structure** tree, followed by the full content of each file, demarcated by `--- File: /path/to/file ---` headers.

**Snapshot Stats:**
- **Files Included:** 155
- **Total Files in Repo:** 162

---

## 2. Your Core Operational Workflow

You are the Project Manager and Solution Architect AI. Your primary goal is to translate user requests into technical plans and then generate precise commands for a code-execution AI agent.

### PROJECT OVERVIEW
- **Project:** ecKasse
- **Description:** A CLI tool to create and restore single-file text snapshots of a Git repository, optimized for providing context to Large Language Models (LLMs).

### CORE WORKFLOW: The Interactive Command Cycle
1.  **Analyze User Request:** Understand the user's goal in their native language.
2.  **Formulate a Plan:** Create a high-level technical plan to solve the user's request.
3.  **Propose & Await Confirmation:** Present the plan to the user in their language and ask for approval to generate the command. **CRITICAL: Stop and wait for the user's response. Do NOT generate the command block at this stage.**
4.  **Generate Command on Demand:** This is the execution step, triggered ONLY by a positive user response.
    -   **On Approval:** If the user confirms the plan (e.g., "yes", "proceed") or provides a minor correction, your *next response* must be **only the command block**. Do not include any conversational text.
    -   **On Direct Order:** If the user explicitly asks for the command (e.g., "make the command for Claude now") and you have all the necessary information, you may skip step 3 and directly generate the command block.
5.  **Review & Report:** After the command is executed, analyze the results and report back to the user in their language.
6.  **Iterate:** Continue the cycle based on user feedback.

### COMMUNICATION PROTOCOL
-   **User Interaction:** ALWAYS communicate with the user in the language they use.
-   **Agent Commands:** ALWAYS formulate the JSON payload and technical instructions for the execution agent in **ENGLISH** to ensure technical accuracy.

### COMMAND BLOCK FORMAT
To ensure error-free execution, all tasks for the agent must be presented in a special block with a "Copy" button. Use this enhanced format for maximum clarity and execution accuracy:

```json
{
  "command_for_agent": "apply_code_changes",
  "task_id": "unique-task-id",
  "payload": {
    "objective": "Brief, clear task description",
    "context": "Why this change is needed",
    "files_to_modify": [
      {
        "path": "exact/file/path.js",
        "action": "specific action (add, modify, replace, delete)",
        "location": "line numbers, function name, or search pattern",
        "details": "precise description of the change"
      }
    ],
    "new_files": [
      {
        "path": "path/to/new/file.js",
        "content_type": "javascript/json/markdown/config",
        "purpose": "why this file is needed"
      }
    ],
    "dependencies": {
      "install": ["package-name@version"],
      "remove": ["old-package-name"]
    },
    "validation_steps": [
      "npm run test",
      "node index.js --help",
      "specific command to verify functionality"
    ],
    "expected_outcome": "what should work after changes"
  }
}
```

### PROJECT CONTEXT (`eck-snapshot`)
-   **Type:** Node.js CLI Application, executed directly.
-   **Module System:** ES Modules (`"type": "module"` in package.json).
-   **Main File:** `index.js` contains all primary logic (837 lines).
-   **Configuration:** `.ecksnapshot.config.js` is used for custom filtering and settings.
-   **Key Dependencies:** `commander`, `execa`, `inquirer`, `ignore`, `p-limit`, `cli-progress`.

### ARCHITECTURE DETAILS FOR CLAUDE CODE
**Core Functions Location:**
- `createRepoSnapshot()` - Line 333: Main snapshot creation
- `restoreSnapshot()` - Line 579: Snapshot restoration  
- `processFile()` - Line 265: Individual file processing
- `generateDirectoryTree()` - Line 224: Tree generation
- `generateSnapshotHeader()` - Line 42: AI instruction header
- CLI setup - Lines 800-837: Commander.js configuration

**Common Modification Patterns:**
- CLI options: Modify commander setup (lines 808-822, 824-835)
- Configuration: Update DEFAULT_CONFIG object (lines 23-31)
- File processing: Enhance processFile() function
- Output formats: Modify generateSnapshotHeader() or output logic
- Dependencies: Update package.json and import statements

**Testing Status:**
- No test framework currently configured
- package.json test script returns error
- Manual testing via `node index.js` commands
- Consider adding vitest or jest for future testing

**Development Workflow:**
- Direct execution: `node index.js [command] [options]`
- Package creation: `npm pack`
- Local testing: `node index.js --help`
- Configuration testing: modify `.ecksnapshot.config.js`

**Critical Implementation Notes:**
- All file paths normalized to forward slashes
- ES module imports only (no CommonJS)
- Error handling with detailed user messages
- Progress tracking for long operations
- Security: Path validation prevents directory traversal
- Cross-platform compatibility maintained

---
Directory Structure:

├── .claude/
│   └── settings.local.json
├── docs_forLMM/
│   ├── ecKasse_Complete_Concept_v2.json
│   ├── for_Gemini_LLM.md
│   └── icon_generation_guide.md
├── menu_inputs/
├── menu_outputs/
├── packages/
│   ├── backend/
│   │   ├── src/
│   │   │   ├── config/
│   │   │   │   └── logger.js
│   │   │   ├── controllers/
│   │   │   │   └── llm.controller.js
│   │   │   ├── db/
│   │   │   │   ├── migrations/
│   │   │   │   │   ├── 20250706120000_create_oop_pos_mdf_tables.js
│   │   │   │   │   ├── 20250706150000_create_fts_table.js
│   │   │   │   │   ├── 20250706160000_create_vec_items_table.js
│   │   │   │   │   ├── 20250709100000_add_menu_item_number_to_items.js
│   │   │   │   │   ├── 20250713120000_create_search_cache_table.js
│   │   │   │   │   ├── 20250713210000_create_menu_layouts_table.js
│   │   │   │   │   ├── 20250722000500_create_user_management_tables.js
│   │   │   │   │   ├── 20250726203101_create_fiscal_log_table.js
│   │   │   │   │   ├── 20250726203102_create_operational_log_table.js
│   │   │   │   │   ├── 20250726203103_create_system_log_table.js
│   │   │   │   │   ├── 20250726205444_create_pending_fiscal_operations_table.js
│   │   │   │   │   ├── 20250726215719_add_current_log_hash_to_operational_log.js
│   │   │   │   │   ├── 20250726222000_add_hash_columns_to_fiscal_log.js
│   │   │   │   │   ├── 20250727092501_create_active_transactions_table.js
│   │   │   │   │   ├── 20250727092502_create_active_transaction_items_table.js
│   │   │   │   │   ├── 20250727173908_add_resolution_status_to_transactions.js
│   │   │   │   │   └── 20250727174500_add_payment_fields_to_active_transactions.js
│   │   │   │   ├── seeds/
│   │   │   │   │   ├── 01_initial_oop_pos_mdf_data.js
│   │   │   │   │   └── 02_user_management_seed.js
│   │   │   │   ├── eckasse_dev.sqlite3
│   │   │   │   ├── knex.js
│   │   │   │   └── knexfile.js
│   │   │   ├── lib/
│   │   │   │   ├── converters/
│   │   │   │   │   ├── vectron/
│   │   │   │   │   │   ├── utils/
│   │   │   │   │   │   │   ├── encoding.js
│   │   │   │   │   │   │   ├── formatter.js
│   │   │   │   │   │   │   ├── multilingual.js
│   │   │   │   │   │   │   └── numbering.js
│   │   │   │   │   │   ├── auswahlfenster.js
│   │   │   │   │   │   ├── config.js
│   │   │   │   │   │   ├── header.js
│   │   │   │   │   │   ├── index.js
│   │   │   │   │   │   ├── mapping.js
│   │   │   │   │   │   ├── plu.js
│   │   │   │   │   │   ├── validation.js
│   │   │   │   │   │   └── warengruppen.js
│   │   │   │   │   ├── vectron-legacy.js
│   │   │   │   │   └── vectron.js
│   │   │   │   ├── CLI_README.md
│   │   │   │   ├── cli.js
│   │   │   │   └── menu_parser_llm.js
│   │   │   ├── routes/
│   │   │   │   └── llm.routes.js
│   │   │   ├── schemas/
│   │   │   │   └── v2.0.0/
│   │   │   │       └── schema.json
│   │   │   ├── scripts/
│   │   │   │   ├── backfillEmbeddings.js
│   │   │   │   ├── migrate.js
│   │   │   │   ├── parse_and_init.js
│   │   │   │   ├── recover_pending_operations.js
│   │   │   │   └── testHybridSearch.js
│   │   │   ├── services/
│   │   │   │   ├── auth.service.js
│   │   │   │   ├── category.service.js
│   │   │   │   ├── embedding.service.js
│   │   │   │   ├── enrichment.service.js
│   │   │   │   ├── export.service.js
│   │   │   │   ├── import.service.js
│   │   │   │   ├── layout.service.js
│   │   │   │   ├── llm.provider.js
│   │   │   │   ├── llm.service.js
│   │   │   │   ├── logging.service.js
│   │   │   │   ├── manager.service.js
│   │   │   │   ├── product.service.js
│   │   │   │   ├── reporting.service.js
│   │   │   │   ├── search.service.js
│   │   │   │   ├── system.service.js
│   │   │   │   ├── transaction_management.service.js
│   │   │   │   └── transaction.service.js
│   │   │   ├── utils/
│   │   │   │   ├── FileCallbackHandler.js
│   │   │   │   ├── geminiErrorHandler.js
│   │   │   │   └── levenshtein.js
│   │   │   ├── app.js
│   │   │   └── server.js
│   │   ├── check_categories.js
│   │   ├── create_test_category.js
│   │   ├── debug_category_lookup.js
│   │   ├── eckasse_dev.sqlite3
│   │   ├── exported_data.json
│   │   ├── GOOGLE_SEARCH_SETUP.md
│   │   ├── NEXT_GEN_SEARCH_STATUS.md
│   │   ├── package.json
│   │   ├── quick_test.js
│   │   ├── test_agent_search_e2e.js
│   │   ├── test_all_tools_stub.js
│   │   ├── test_context_dialog.js
│   │   ├── test_create_product.js
│   │   ├── test_enrichment_optimization.js
│   │   ├── test_enrichment.js
│   │   ├── test_gemini_limits.js
│   │   ├── test_google_env.js
│   │   ├── test_google_research.js
│   │   ├── test_google_setup.js
│   │   ├── test_import_service_phase2.js
│   │   ├── test_llm_create_product.js
│   │   ├── test_menu_parser_detailed.js
│   │   ├── test_next_gen_search.js
│   │   ├── test_phase3_structure.js
│   │   ├── test_real_search.js
│   │   ├── test_reporting_direct.js
│   │   ├── test_research_agent.js
│   │   ├── test_research_basic.js
│   │   ├── test_research_structure.js
│   │   ├── test_sales_report_only.js
│   │   ├── test_sample_mdf.json
│   │   ├── test_search.js
│   │   ├── test_user_management_flow.js
│   │   ├── test-sample-enhanced-mdf.json
│   │   ├── test-sample-mdf.json
│   │   └── verify_enrichment.js
│   └── client-desktop/
│       ├── electron/
│       │   ├── main.js
│       │   └── preload.js
│       ├── src/
│       │   └── renderer/
│       │       ├── src/
│       │       │   ├── lib/
│       │       │   │   ├── components/
│       │       │   │   │   ├── BetrugerCapIcon.svelte
│       │       │   │   │   ├── ContextMenu.svelte
│       │       │   │   │   ├── FunctionButtons.svelte
│       │       │   │   │   ├── HalfHexButton.svelte
│       │       │   │   │   ├── HalfRectButton.svelte
│       │       │   │   │   ├── HexButton.svelte
│       │       │   │   │   ├── OctagonButton.svelte
│       │       │   │   │   ├── ParkedOrdersDisplay.svelte
│       │       │   │   │   ├── Pinpad.svelte
│       │       │   │   │   ├── PinpadPreview.svelte
│       │       │   │   │   ├── ReceiptFeed.svelte
│       │       │   │   │   ├── RecoveryModal.svelte
│       │       │   │   │   ├── RectButton.svelte
│       │       │   │   │   ├── SquareButton.svelte
│       │       │   │   │   ├── TimeButton.svelte
│       │       │   │   │   └── UniversalButton.svelte
│       │       │   │   ├── LayoutManager.svelte
│       │       │   │   ├── logStore.js
│       │       │   │   ├── orderStore.js
│       │       │   │   ├── parkedOrdersStore.js
│       │       │   │   ├── pinpadStore.js
│       │       │   │   ├── receiptsStore.js
│       │       │   │   ├── recoveryStore.js
│       │       │   │   ├── timeStore.js
│       │       │   │   ├── viewStore.js
│       │       │   │   └── wsStore.js
│       │       │   ├── app.css
│       │       │   ├── App.svelte
│       │       │   ├── ConsoleView.svelte
│       │       │   ├── main.js
│       │       │   └── SelectionArea.svelte
│       │       ├── index.html
│       │       ├── package.json
│       │       └── vite.config.js
│       └── package.json
├── public/
│   └── index.html
├── .env.example
├── CLAUDE.md
├── HYBRID_SEARCH.md
├── LICENSE
├── orders.bat
├── package-lock.json
├── package.json
└── README.md


--- File: /.claude/settings.local.json ---

{
  "permissions": {
    "allow": [
      "Bash(rm:*)",
      "Bash(npm install)",
      "Bash(npm run dev:backend:*)",
      "Bash(npm run dev:client:desktop:renderer:*)",
      "Bash(npm install:*)",
      "Bash(npm run migrate:backend:*)",
      "Bash(npm rebuild:*)",
      "Bash(pkill:*)",
      "Bash(true)",
      "Bash(sqlite3:*)",
      "Bash(node:*)",
      "Bash(npm uninstall:*)",
      "Bash(npx knex migrate:make:*)",
      "Bash(ls:*)",
      "Bash(npm run start:*)",
      "Bash(timeout:*)",
      "Bash(npm run:*)",
      "Bash(npx knex migrate:status:*)",
      "Bash(mv:*)",
      "Bash(npm start)",
      "Bash(curl:*)",
      "Bash(grep:*)",
      "Bash(rg:*)",
      "Bash(jq:*)",
      "Bash(npx knex migrate:rollback:*)",
      "Bash(npx knex migrate:latest:*)",
      "Bash(npx knex migrate:up:*)",
      "Bash(time node:*)",
      "Bash(find:*)",
      "WebFetch(domain:ai.google.dev)",
      "Bash(mkdir:*)",
      "Bash(git rm:*)",
      "Bash(git add:*)",
      "Bash(python3:*)",
      "Bash(cat:*)",
      "Bash(npx knex raw:*)",
      "Bash(fuser:*)",
      "Bash(ss:*)"
    ],
    "deny": []
  }
}

--- File: /CLAUDE.md ---

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

ecKasse is an LLM-powered Point of Sale (POS) system built as an Electron desktop application. The project was recently refactored from React to vanilla HTML/CSS/JavaScript to eliminate unnecessary complexity while maintaining all functionality.

## Architecture

### Unified Backend Design
- **Single Express.js server** serves both API endpoints and static frontend files
- **Port 3030**: Backend handles both `/api/*` routes and static file serving
- **WebSocket + HTTP fallback**: Dual communication channels with shared `operationId` system
- **SQLite database**: Local storage with Knex.js migrations

### Technology Stack
- **Frontend**: Vanilla HTML/CSS/JavaScript (migrated from React)
- **Backend**: Node.js with Express.js
- **Desktop**: Electron wrapper
- **Database**: SQLite with Knex.js
- **LLM**: Google Gemini integration via @google/genai
- **Logging**: Pino structured logging

## Development Commands

### Core Development
```bash
# Start complete development environment (backend + Electron)
npm run dev

# Start backend only (serves API + static files on port 3030)  
npm run dev:backend

# Database operations
npm run migrate:backend    # Run database migrations
npm run seed:backend      # Seed development data
```

### Build and Distribution
```bash
# Build Electron application
npm run build:client:desktop

# Create distributable package
npm run dist:client:desktop

# Platform-specific builds (Windows)
npm run package-win
```

### Code Quality
```bash
# Lint all workspaces
npm run lint:all

# Format all code
npm run format:all

# Run tests (when available)
npm run test:all
```

## Key Architecture Patterns

### Communication Protocol
All operations use UUID-based `operationId` for idempotency across WebSocket and HTTP channels:

```javascript
// Request format
{
  operationId: "uuid-v4",
  command: "ping_ws", 
  payload: { data: "test" }
}

// Response format
{
  operationId: "uuid-v4",
  status: "success|error|already_processed",
  payload: { /* response data */ },
  channel: "websocket|http"
}
```

### WebSocket Management
Located in `/packages/client-desktop/src/renderer/public/websocket.js`:
- Custom WebSocketManager class with EventEmitter pattern
- Automatic request timeout handling (3 seconds)
- Promise-based request/response with operationId tracking
- Fallback to HTTP when WebSocket fails

### LLM Integration
Located in `/packages/backend/src/services/llm.service.js`:
- **LangChain ReAct Agent** with Google Gemini integration
- **Dynamic Tools** for database operations (findProduct, createProduct, createCategory)
- **Real-time POS management** through natural language commands
- **SQLite integration** via Knex.js for direct database manipulation
- **Conversation history** maintenance for context-aware interactions

### Static File Serving
Backend Express app serves frontend files:
- Static files from `/packages/client-desktop/src/renderer/public/`
- Catch-all route returns `index.html` for non-API requests
- API routes prefixed with `/api/` to avoid conflicts

## Monorepo Structure

```
packages/
├── backend/                    # Express.js API server
│   ├── src/
│   │   ├── config/logger.js   # Pino logging configuration
│   │   ├── controllers/       # API endpoint handlers
│   │   ├── services/          # Business logic (LLM service)
│   │   ├── routes/            # Express route definitions
│   │   ├── db/                # Knex migrations and seeds
│   │   ├── app.js             # Express app setup + static serving
│   │   └── server.js          # HTTP + WebSocket server
│   └── package.json
└── client-desktop/             # Electron wrapper
    ├── electron/
    │   ├── main.js             # Electron main process
    │   └── preload.js          # IPC bridge
    ├── src/renderer/
    │   └── public/             # Static frontend files
    │       ├── index.html      # Main HTML file
    │       ├── app.js          # Main application logic
    │       ├── websocket.js    # WebSocket management
    │       └── styles.css      # Application styles
    └── package.json
```

## Environment Configuration

Required `.env` file in project root:
```env
GEMINI_API_KEY=your_google_gemini_api_key
BACKEND_PORT=3030
NODE_ENV=development
LOG_LEVEL=debug
DB_FILENAME=./packages/backend/src/db/eckasse_dev.sqlite3
```

## Development Guidelines

### Frontend Development
- All static files in `/packages/client-desktop/src/renderer/public/`
- No build process required - files served directly by backend
- WebSocket communication with HTTP fallback
- UUID generation for operationId (using custom implementation)

### Backend Development  
- Express.js app in `/packages/backend/src/app.js`
- All routes prefixed with `/api/`
- Structured logging with Pino
- operationId deduplication for both HTTP and WebSocket
- Static file serving integrated into same Express instance

### LLM Integration
- Function declarations follow Google's official structure
- All product queries must use available tool functions
- System context defines POS-specific behavior
- Error recovery with model fallback chain

### Database Operations
- Use Knex.js migrations for schema changes
- Seed files for development data
- SQLite for local storage (with future cloud sync planned)

## Testing LLM Features

1. Start development: `npm run dev`
2. Electron app launches automatically
3. Test areas:
   - WebSocket Ping/HTTP Fallback section
   - Gemini Ping-Pong Test section

### LangChain Agent Testing
The AI agent can now perform real database operations:

**Product Search:**
- "Найди товар Кофе" (Find product Coffee)
- "Покажи товар Пицца" (Show product Pizza)

**Category Creation:**
- "Создай категорию Напитки типа drink" (Create category Drinks of type drink)
- "Добавь категорию Основные блюда типа food" (Add category Main dishes of type food)

**Product Creation:**
- "Создай товар Эспрессо цена 2.50 категория Напитки" (Create product Espresso price 2.50 category Drinks)
- "Добавь товар Капучино за 3.00 в категорию Напитки" (Add product Cappuccino for 3.00 in category Drinks)

**Prerequisites:**
- Ensure database is migrated: `npm run migrate:backend`
- Categories must exist before creating products
- Agent will guide you through missing requirements

## Node.js Version Compatibility

Backend includes version checking for Node.js v20+ compatibility:
- Current development uses Node.js v20.19.0
- Compatible with v24+ for future upgrades
- Version warnings logged on startup if < v20

## Fiscal Compliance Context

This POS system is designed for German fiscal compliance:
- TSE (Technical Security Equipment) integration planned
- DSFinV-K export format for tax authorities
- Long-term archival with cryptographic integrity
- Currently in development phase for basic functionality

## Critical Implementation Notes

### Project Migration Status
- The project **has been migrated** from React to vanilla HTML/CSS/JavaScript
- The README.md may contain outdated references to React - ignore these
- The actual implementation uses vanilla JS served directly by the Express backend
- No build process is required for the frontend

### LLM Service Architecture
- **LangChain ReAct Agent** with `gemini-1.5-flash` model
- **Three Dynamic Tools** for POS system management:
  - `findProduct`: Search products by name in database
  - `createProduct`: Create new products with category linking
  - `createCategory`: Create new product categories (food/drink)
- **Real database integration** via Knex.js (no hardcoded data)
- **Conversation history** maintained between requests
- **Error handling** with graceful fallbacks

### WebSocket Implementation Details
- Custom `WebSocketManager` class with EventEmitter pattern
- 3-second timeout for WebSocket requests
- Promise-based request/response mapping via operationId
- Automatic HTTP fallback when WebSocket fails
- UUID generation using custom implementation (not crypto.randomUUID)

### Backend Request Handling
- Dual operationId tracking for both HTTP and WebSocket (separate Sets)
- 60-second TTL for operationId deduplication
- Structured logging with Pino for all requests/responses
- Static file serving integrated into same Express instance

# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

--- File: /HYBRID_SEARCH.md ---

# HYBRID_SEARCH.md

## Цель: Реализация гибридного поиска в ecKasse

Создать многоуровневую систему поиска, которая объединяет **Full-Text Search (FTS)**, **семантический векторный поиск** и **расстояние Левенштейна** для обеспечения быстрого, точного и отказоустойчивого поиска, способного понимать смысл запроса и исправлять опечатки.

### Общая логика работы:

1. **FTS-поиск**: Быстрая проверка на точное совпадение слов
2. **Векторный поиск (Fallback)**: Если точных совпадений нет, выполняется поиск по смысловой близости
3. **Расстояние Левенштейна (Фильтрация)**: Результаты векторного поиска дополнительно проверяются на схожесть написания, чтобы отсеять семантически близкие, но лексически далекие результаты и обработать опечатки

---

## Фаза 1: Интеграция векторного поиска в SQLite

Цель этой фазы — подготовить базу данных и приложение для работы с векторами.

### Задача 1.1: Обновление зависимости sqlite3

Стандартный пакет `sqlite3` усложняет загрузку расширений. Мы заменим его на `@journeyapps/sqlcipher`, который является drop-in заменой и упрощает этот процесс.

**Действие**:
1. Удалить `sqlite3` из зависимостей `packages/backend/package.json`
2. Добавить `@journeyapps/sqlcipher` в зависимости
```bash
npm uninstall sqlite3 --workspace=@eckasse/backend
npm install @journeyapps/sqlcipher --workspace=@eckasse/backend
```

### Задача 1.2: Настройка загрузки расширения sqlite-vss

**Действие**:
1. Скачать последний релиз расширения `vector0` и `vss0` для вашей ОС (например, `vector0.so` и `vss0.so` для Linux) с [репозитория sqlite-vss](https://github.com/asg017/sqlite-vss/releases)
2. Поместить файлы расширения в новую директорию: `packages/backend/src/db/extensions/`
3. Модифицировать файл `packages/backend/src/db/knex.js`, чтобы он загружал расширение при каждом подключении к БД

**Пример кода для knex.js**:
```javascript
const knex = require('knex');
const config = require('./knexfile.js');
const path = require('path');

const environment = process.env.NODE_ENV || 'development';
const knexConfig = config[environment];

const db = knex(knexConfig);

// Загрузка расширения VSS
db.client.driver.on('open', (db) => {
  db.loadExtension(path.join(__dirname, 'extensions/vector0'));
  db.loadExtension(path.join(__dirname, 'extensions/vss0'));
  console.log('VSS extension loaded.');
});

module.exports = db;
```

### Задача 1.3: Создание миграции для векторной таблицы

**Действие**: Создать новый файл миграции Knex для создания виртуальной таблицы, которая будет хранить векторы.

**Код для новой миграции** (`..._create_vss_items_table.js`):
```javascript
exports.up = function(knex) {
  // Размерность 768 соответствует модели text-embedding-004 от Google
  return knex.schema.raw('CREATE VIRTUAL TABLE vss_items USING vss0(item_embedding(768))');
};

exports.down = function(knex) {
  return knex.schema.dropTableIfExists('vss_items');
};
```

---

## Фаза 2: Генерация и управление эмбеддингами

Цель этой фазы — преобразовать текстовые данные в векторы и поддерживать их в актуальном состоянии.

### Задача 2.1: Создание сервиса для генерации эмбеддингов

**Действие**: Создать новый файл `packages/backend/src/services/embedding.service.js`. Этот сервис будет инкапсулировать логику получения векторов от Google AI.

**Пример кода для embedding.service.js**:
```javascript
const { GoogleGenerativeAI } = require('@google/generative-ai');

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "text-embedding-004" });

async function generateEmbedding(text) {
  const result = await model.embedContent(text);
  return result.embedding.values;
}

module.exports = { generateEmbedding };
```

### Задача 2.2: Создание скрипта для заполнения векторов

**Действие**: Написать отдельный скрипт (`npm run db:backfill:embeddings`), который пройдет по всем товарам в таблице `items`, сгенерирует для их названий эмбеддинги и заполнит таблицу `vss_items`.

**Псевдокод для скрипта**:
```javascript
// backfillEmbeddings.js
const db = require('./knex');
const { generateEmbedding } = require('../services/embedding.service');

async function backfill() {
  const products = await db('items').select('id', 'display_names');
  for (const product of products) {
    const name = JSON.parse(product.display_names).menu.de;
    const embedding = await generateEmbedding(name);
    await db.raw('INSERT INTO vss_items(rowid, item_embedding) VALUES (?, ?)', 
      [product.id, JSON.stringify(embedding)]);
    console.log(`Embedded product ID: ${product.id}`);
  }
  await db.destroy();
}

backfill();
```

### Задача 2.3: Обновление триггеров базы данных

**Действие**: Модифицировать миграцию `..._create_fts_table.js` (или создать новую), чтобы триггеры `items_after_insert` и `items_after_update` также обновляли данные в `vss_items`. Это потребует написания пользовательской SQL-функции, которую сможет вызывать триггер, так как триггеры не могут выполнять асинхронные JS-операции. *(Это сложная задача, для начала можно обойтись без триггеров и выполнять переиндексацию вручную)*.

---

## Фаза 3: Реализация гибридной логики поиска

Цель этой фазы — объединить все три метода поиска в одном инструменте.

### Задача 3.1: Полный рефакторинг инструмента findProduct

**Действие**: Заменить текущую логику `findProduct` в `llm.service.js` на новую, гибридную.

**Псевдокод новой логики findProduct**:
```javascript
async function findProduct(toolInput) {
  const searchQuery = toolInput.input;

  // --- 1. FTS Search ---
  let ftsResults = await knex.raw("SELECT rowid as id FROM items_fts WHERE items_fts MATCH ?", [searchQuery]);
  if (ftsResults.length > 0) {
    // Если есть точное совпадение, возвращаем его
    // ...
    return "Найден точный результат: ...";
  }

  // --- 2. Vector Search (Fallback) ---
  const queryEmbedding = await generateEmbedding(searchQuery);
  const vectorResults = await knex.raw(
    "SELECT rowid, distance FROM vss_items WHERE vss_search(item_embedding, ?)", 
    [JSON.stringify(queryEmbedding)]
  );

  if (vectorResults.length === 0) {
    return "К сожалению, похожих товаров не найдено.";
  }

  // --- 3. Levenshtein Distance refining ---
  const detailedCandidates = await Promise.all(vectorResults.map(async (v) => {
    const product = await knex('items').where('id', v.rowid).first();
    const productName = JSON.parse(product.display_names).menu.de;
    const levenshteinDist = calculateLevenshtein(searchQuery, productName);
    return { ...product, semanticDistance: v.distance, levenshteinDistance: levenshteinDist };
  }));
  
  detailedCandidates.sort((a, b) => a.semanticDistance - b.semanticDistance);

  // --- 4. Tiered Response Logic ---
  const bestMatch = detailedCandidates[0];

  if (bestMatch.levenshteinDistance <= 2) {
    return `Товар не найден, но есть очень похожий: "${bestMatch.name}". Вот информация...`;
  } else {
    const suggestions = detailedCandidates.slice(0, 3).map(c => c.name);
    return `Товар не найден. Возможно, вы имели в виду: ${suggestions.join(', ')}?`;
  }
}
```

### Задача 3.2: Реализация функции расстояния Левенштейна

**Действие**: Создать утилитарную функцию `calculateLevenshtein` для измерения текстовых различий.

**Пример кода**:
```javascript
function calculateLevenshtein(str1, str2) {
  const matrix = [];
  const len1 = str1.length;
  const len2 = str2.length;

  for (let i = 0; i <= len2; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= len1; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= len2; i++) {
    for (let j = 1; j <= len1; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }

  return matrix[len2][len1];
}
```

---

## Фаза 4: Тестирование и настройка производительности

Цель этой фазы — убедиться, что система работает эффективно во всех сценариях.

### Задача 4.1: Создание тестовых сценариев

**Действие**: Создать набор тестовых запросов для проверки каждого уровня поиска.

**Примеры тестовых запросов**:
- **FTS**: "Кофе" (точное совпадение)
- **Vector**: "горячий напиток с кофеином" (семантическое совпадение)
- **Levenshtein**: "Кофе" → "Кофэ" (опечатка)
- **Комбинированный**: "пицца с сыром" (частичное совпадение + семантика)

### Задача 4.2: Мониторинг производительности

**Действие**: Добавить логирование времени выполнения для каждого этапа поиска.

**Пример кода для профилирования**:
```javascript
async function findProduct(toolInput) {
  const searchQuery = toolInput.input;
  const startTime = Date.now();

  // FTS Search
  const ftsStart = Date.now();
  let ftsResults = await knex.raw("SELECT rowid as id FROM items_fts WHERE items_fts MATCH ?", [searchQuery]);
  console.log(`FTS search took: ${Date.now() - ftsStart}ms`);

  if (ftsResults.length > 0) {
    console.log(`Total search time: ${Date.now() - startTime}ms`);
    return "Найден точный результат: ...";
  }

  // Vector Search
  const vectorStart = Date.now();
  // ... vector search logic
  console.log(`Vector search took: ${Date.now() - vectorStart}ms`);

  // Levenshtein filtering
  const levenshteinStart = Date.now();
  // ... levenshtein logic
  console.log(`Levenshtein filtering took: ${Date.now() - levenshteinStart}ms`);

  console.log(`Total search time: ${Date.now() - startTime}ms`);
  return result;
}
```

### Задача 4.3: Настройка параметров поиска

**Действие**: Определить оптимальные пороговые значения для каждого типа поиска.

**Параметры для настройки**:
- Максимальное расстояние для векторного поиска
- Максимальное расстояние Левенштейна для "близких" результатов
- Количество результатов для каждого этапа

---

## Фаза 5: Интеграция с пользовательским интерфейсом

Цель этой фазы — сделать гибридный поиск доступным через веб-интерфейс.

### Задача 5.1: Создание API-эндпоинта для поиска

**Действие**: Создать новый роут `/api/search` который будет использовать гибридный поиск.

**Пример кода для контроллера**:
```javascript
// packages/backend/src/controllers/search.controller.js
const { hybridSearch } = require('../services/search.service');

async function searchProducts(req, res) {
  try {
    const { query } = req.body;
    const results = await hybridSearch(query);
    res.json({
      success: true,
      results: results,
      searchMethod: results.searchMethod // 'fts', 'vector', 'hybrid'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
}

module.exports = { searchProducts };
```

### Задача 5.2: Обновление фронтенда

**Действие**: Добавить интерфейс для тестирования гибридного поиска в `packages/client-desktop/src/renderer/public/index.html`.

**Пример HTML-интерфейса**:
```html
<div class="search-section">
  <h3>Гибридный поиск товаров</h3>
  <input type="text" id="searchQuery" placeholder="Введите название товара...">
  <button onclick="performHybridSearch()">Поиск</button>
  <div id="searchResults"></div>
</div>
```

---

## Преимущества гибридного подхода

1. **Скорость**: FTS обеспечивает мгновенный ответ для точных совпадений
2. **Интеллектуальность**: Векторный поиск понимает смысл и синонимы
3. **Отказоустойчивость**: Расстояние Левенштейна исправляет опечатки
4. **Масштабируемость**: Каждый уровень может быть независимо оптимизирован

## Технические требования

- **Node.js**: v20+ (уже используется)
- **SQLite**: с поддержкой расширений
- **Доступ к Google AI**: для генерации эмбеддингов
- **Память**: ~100MB дополнительно для векторов (для небольшой базы товаров)

## Примерные метрики производительности

- **FTS поиск**: <5ms
- **Векторный поиск**: 20-50ms
- **Обработка Левенштейна**: 1-10ms
- **Общий Fallback**: 50-100ms

Этот план обеспечивает пошаговую реализацию интеллектуальной системы поиска, которая будет значительно превосходить текущие возможности ecKasse.

--- File: /LICENSE ---

# European Union Public Licence v. 1.2

**Copyright 2025 Betruger Sp. z o.o.**  
**Original work by Dmytro Surovtsev**

**EUPL © the European Union 2007, 2016**

This European Union Public Licence (the 'EUPL') applies to the Work (as defined below) which is provided under the terms of this Licence. Any use of the Work, other than as authorised under this Licence is prohibited (to the extent such use is covered by a right of the copyright holder of the Work).

The Work is provided under the terms of this Licence when the Licensor (as defined below) has placed the following notice immediately following the copyright notice for the Work:

**Licensed under the EUPL**

or has expressed by any other means his willingness to license under the EUPL.

## 1. Definitions

In this Licence, the following terms have the following meaning:

— **'The Licence'**: this Licence.

— **'The Original Work'**: the work or software distributed or communicated by the Licensor under this Licence, available as Source Code and also as Executable Code as the case may be.

— **'Derivative Works'**: the works or software that could be created by the Licensee, based upon the Original Work or modifications thereof. This Licence does not define the extent of modification or dependence on the Original Work required in order to classify a work as a Derivative Work; this extent is determined by copyright law applicable in the country mentioned in Article 15.

— **'The Work'**: the Original Work or its Derivative Works.

— **'The Source Code'**: the human-readable form of the Work which is the most convenient for people to study and modify.

— **'The Executable Code'**: any code which has generally been compiled and which is meant to be interpreted by a computer as a program.

— **'The Licensor'**: the natural or legal person that distributes or communicates the Work under the Licence.

— **'Contributor(s)'**: any natural or legal person who modifies the Work under the Licence, or otherwise contributes to the creation of a Derivative Work.

— **'The Licensee' or 'You'**: any natural or legal person who makes any usage of the Work under the terms of the Licence.

— **'Distribution' or 'Communication'**: any act of selling, giving, lending, renting, distributing, communicating, transmitting, or otherwise making available, online or offline, copies of the Work or providing access to its essential functionalities at the disposal of any other natural or legal person.

## 2. Scope of the rights granted by the Licence

The Licensor hereby grants You a worldwide, royalty-free, non-exclusive, sublicensable licence to do the following, for the duration of copyright vested in the Original Work:

— use the Work in any circumstance and for all usage,
— reproduce the Work,
— modify the Work, and make Derivative Works based upon the Work,
— communicate to the public, including the right to make available or display the Work or copies thereof to the public and perform publicly, as the case may be, the Work,
— distribute the Work or copies thereof,
— lend and rent the Work or copies thereof,
— sublicense rights in the Work or copies thereof.

Those rights can be exercised on any media, supports and formats, whether now known or later invented, as far as the applicable law permits so.

In the countries where moral rights apply, the Licensor waives his right to exercise his moral right to the extent allowed by law in order to make effective the licence of the economic rights here above listed.

The Licensor grants to the Licensee royalty-free, non-exclusive usage rights to any patents held by the Licensor, to the extent necessary to make use of the rights granted on the Work under this Licence.

## 3. Communication of the Source Code

The Licensor may provide the Work either in its Source Code form, or as Executable Code. If the Work is provided as Executable Code, the Licensor provides in addition a machine-readable copy of the Source Code of the Work along with each copy of the Work that the Licensor distributes or indicates, in a notice following the copyright notice attached to the Work, a repository where the Source Code is easily and freely accessible for as long as the Licensor continues to distribute or communicate the Work.

## 4. Limitations on copyright

Nothing in this Licence is intended to deprive the Licensee of the benefits from any exception or limitation to the exclusive rights of the rights owners in the Work, of the exhaustion of those rights or of other applicable limitations thereto.

## 5. Obligations of the Licensee

The grant of the rights mentioned above is subject to some restrictions and obligations imposed on the Licensee. Those obligations are the following:

**Attribution right**: The Licensee shall keep intact all copyright, patent or trademarks notices and all notices that refer to the Licence and to the disclaimer of warranties. The Licensee must include a copy of such notices and a copy of the Licence with every copy of the Work he/she distributes or communicates. The Licensee must cause any Derivative Work to carry prominent notices stating that the Work has been modified and the date of modification.

**Copyleft clause**: If the Licensee distributes or communicates copies of the Original Works or Derivative Works, this Distribution or Communication will be done under the terms of this Licence or of a later version of this Licence unless the Original Work is expressly distributed only under this version of the Licence — for example by communicating 'EUPL v. 1.2 only'. The Licensee (becoming Licensor) cannot offer or impose any additional terms or conditions on the Work or Derivative Work that alter or restrict the terms of the Licence.

**Compatibility clause**: If the Licensee Distributes or Communicates Derivative Works or copies thereof based upon both the Work and another work licensed under a Compatible Licence, this Distribution or Communication can be done under the terms of this Compatible Licence. For the sake of this clause, 'Compatible Licence' refers to the licences listed in the appendix attached to this Licence. Should the Licensee's obligations under the Compatible Licence conflict with his/her obligations under this Licence, the obligations of the Compatible Licence shall prevail.

**Provision of Source Code**: When distributing or communicating copies of the Work, the Licensee will provide a machine-readable copy of the Source Code or indicate a repository where this Source will be easily and freely available for as long as the Licensee continues to distribute or communicate the Work.

**Legal Protection**: This Licence does not grant permission to use the trade names, trademarks, service marks, or names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the copyright notice.

## 6. Chain of Authorship

The original Licensor warrants that the copyright in the Original Work granted hereunder is owned by him/her or licensed to him/her and that he/she has the power and authority to grant the Licence.

Each Contributor warrants that the copyright in the modifications he/she brings to the Work are owned by him/her or licensed to him/her and that he/she has the power and authority to grant the Licence.

Each time You accept the Licence, the original Licensor and subsequent Contributors grant You a licence to their contributions to the Work, under the terms of this Licence.

## 7. Disclaimer of Warranty

The Work is a work in progress, which is continuously improved by numerous Contributors. It is not a finished work and may therefore contain defects or 'bugs' inherent to this type of development.

For the above reason, the Work is provided under the Licence on an 'as is' basis and without warranties of any kind concerning the Work, including without limitation merchantability, fitness for a particular purpose, absence of defects or errors, accuracy, non-infringement of intellectual property rights other than copyright as stated in Article 6 of this Licence.

This disclaimer of warranty is an essential part of the Licence and a condition for the grant of any rights to the Work.

## 8. Disclaimer of Liability

Except in the cases of wilful misconduct or damages directly caused to natural persons, the Licensor will in no event be liable for any direct or indirect, material or moral, damages of any kind, arising out of the Licence or of the use of the Work, including without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, loss of data or any commercial damage, even if the Licensor has been advised of the possibility of such damage. However, the Licensor will be liable under statutory product liability laws as far such laws apply to the Work.

## 9. Additional agreements

While distributing the Work, You may choose to conclude an additional agreement, defining obligations or services consistent with this Licence. However, if accepting obligations, You may act only on your own behalf and on your sole responsibility, not on behalf of the original Licensor or any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against such Contributor by the fact You have accepted any warranty or additional liability.

## 10. Acceptance of the Licence

The provisions of this Licence can be accepted by clicking on an icon 'I agree' placed under the bottom of a window displaying the text of this Licence or by affirming consent in any other similar way, in accordance with the rules of applicable law. Clicking on that icon indicates your clear and irrevocable acceptance of this Licence and all of its terms and conditions.

Similarly, you irrevocably accept this Licence and all of its terms and conditions by exercising any rights granted to You by Article 2 of this Licence, such as the use of the Work, the creation by You of a Derivative Work or the Distribution or Communication by You of the Work or copies thereof.

## 11. Information to the public

In case of any Distribution or Communication of the Work by means of electronic communication by You (for example, by offering to download the Work from a remote location) the distribution channel or media (for example, a website) must at least provide to the public the information requested by the applicable law regarding the Licensor, the Licence and the way it may be accessible, concluded, stored and reproduced by the Licensee.

## 12. Termination of the Licence

The Licence and the rights granted hereunder will terminate automatically upon any breach by the Licensee of the terms of the Licence.

Such a termination will not terminate the licences of any person who has received the Work from the Licensee under the Licence, provided such persons remain in full compliance with the Licence.

## 13. Miscellaneous

Without prejudice of Article 9 above, the Licence represents the complete agreement between the Parties as to the Work.

If any provision of the Licence is invalid or unenforceable under applicable law, this will not affect the validity or enforceability of the Licence as a whole. Such provision will be construed or reformed so as necessary to make it valid and enforceable.

The European Commission may publish other linguistic versions or new versions of this Licence or updated versions of the Appendix, so far this is required and reasonable, without reducing the scope of the rights granted by the Licence. New versions of the Licence will be published with a unique version number.

All linguistic versions of this Licence, approved by the European Commission, have identical value. Parties can take advantage of the linguistic version of their choice.

## 14. Jurisdiction

Without prejudice to specific agreement between parties,

— any litigation resulting from the interpretation of this License, arising between the European Union institutions, bodies, offices or agencies, as a Licensor, and any Licensee, will be subject to the jurisdiction of the Court of Justice of the European Union, as laid down in article 272 of the Treaty on the Functioning of the European Union,

— any litigation arising between other parties and resulting from the interpretation of this License, will be subject to the exclusive jurisdiction of the competent court where the Licensor resides or conducts its primary business.

## 15. Applicable Law

Without prejudice to specific agreement between parties,

— this Licence shall be governed by the law of the European Union Member State where the Licensor has his seat, resides or has his registered office,

— this licence shall be governed by Belgian law if the Licensor has no seat, residence or registered office inside a European Union Member State.

## Appendix

'Compatible Licences' according to Article 5 EUPL are:

— GNU General Public License (GPL) v. 2, v. 3
— GNU Affero General Public License (AGPL) v. 3
— Open Software License (OSL) v. 2.1, v. 3.0
— Eclipse Public License (EPL) v. 1.0
— CeCILL v. 2.0, v. 2.1
— Mozilla Public Licence (MPL) v. 2
— GNU Lesser General Public Licence (LGPL) v. 2.1, v. 3
— Creative Commons Attribution-ShareAlike v. 3.0 Unported (CC BY-SA 3.0) for works other than software
— European Union Public Licence (EUPL) v. 1.1, v. 1.2
— Québec Free and Open-Source Licence — Reciprocity (LiLiQ-R) or Strong Reciprocity (LiLiQ-R+)

The European Commission may update this Appendix to later versions of the above licences without producing a new version of the EUPL, as long as they provide the rights granted in Article 2 of this Licence and protect the covered Source Code from exclusive appropriation.

All other changes or additions to this Appendix require the production of a new EUPL version.



--- File: /README.md ---

# ecKasse - LLM-Powered Point of Sale System

**Status:** In Development | **License:** EUPL-1.2 | **Developer:** Betruger Sp. z o.o.

LLM-powered desktop POS system built with Electron, React, and Node.js. Features natural language configuration via Google Gemini and German fiscal compliance (TSE/DSFinV-K).

## Architecture

### Technology Stack
- **Desktop:** Electron.js with a Svelte frontend
- **Mobile:** Native Android (Kotlin/Jetpack Compose) for standalone and client-only deployments
- **Backend:** Node.js + Express.js (local HTTP API)
- **Database:** SQLite with Knex.js migrations
- **LLM:** Google Gemini (Flash/Pro) via @google/genai
- **Communication:** WebSocket (primary) + HTTP (fallback)
- **Logging:** Pino with structured JSON output

### Communication Layers
1. **WebSocket** - Primary low-latency channel
2. **HTTP API** - Fallback with same operationId system
3. **Cloud Proxy** - Optional remote access via eck(1,2,3).com

All operations use UUID-based `operationId` for idempotency across channels.

## Key Features

### LLM Integration
- Natural language POS configuration
- Function calling for direct API execution
- Multi-language support with automatic adaptation
- Contextual help and error diagnostics
- Product and pricing management via conversation

### Data Management
- **Products:** Three naming levels (menu/button/receipt display)
- **Categories:** Hierarchical with automatic tax assignment  
- **Users & Roles:** Access control management
- **Modifiers:** Time/condition-based pricing rules
- **Table Management:** Bill splitting and item transfers

### Fiscal Compliance (Germany)
- **TSE Integration:** Technical Security Equipment support
- **DSFinV-K Export:** Tax authority data format
- **Time Control:** Mandatory TSE clock verification
- **Long-term Archival:** Hedera blockchain anchoring
- **GoBD Compliance:** Proper accounting record principles

### UI Innovation
- **Geometric Tessellation:** Optimized layout patterns
  - Hexagons (6.6.6): Categories - maximum space efficiency
  - Squares (4.4.4): Numbers - familiar input patterns
  - Octagons (4.8.8): Hierarchical relationships

## Project Structure

```
├── packages/
│   ├── backend/                 # Node.js Express API
│   │   ├── src/
│   │   │   ├── config/         # Logger, database config
│   │   │   ├── controllers/    # API endpoint handlers
│   │   │   ├── services/       # Business logic, LLM service
│   │   │   ├── routes/         # Express route definitions
│   │   │   └── db/             # Knex migrations and seeds
│   │   └── package.json
│   └── client-desktop/         # Electron wrapper
│       ├── electron/           # Main process, preload scripts
│       ├── src/renderer/       # React application
│       │   ├── src/
│       │   │   ├── hooks/      # Custom React hooks (WebSocket)
│       │   │   └── components/ # UI components
│       │   └── package.json
│       └── package.json
└── package.json               # Monorepo root
```

## Installation & Development

### Prerequisites
- Node.js 18+ (project tested with v24.2.0)
- Google Gemini API key
- Git

### Setup
```bash
git clone https://github.com/xelth-com/eckasse.git
cd eckasse
npm install
```

### Environment Configuration
Create `.env` in project root:
```env
GEMINI_API_KEY=your_google_gemini_api_key
BACKEND_PORT=3030
NODE_ENV=development
LOG_LEVEL=debug
DB_FILENAME=./packages/backend/src/db/eckasse_dev.sqlite3
```

### Development Commands
```bash
# Start all services (backend + React + Electron)
npm run dev

# Individual services
npm run dev:backend          # Backend API only
npm run dev:client:desktop:react  # React dev server only

# Database management
npm run migrate:backend      # Run database migrations
npm run seed:backend        # Seed development data

# Production builds
npm run build:client:desktop # Build Electron app
npm run dist:client:desktop  # Create distributable package
```

### Testing LLM Features
1. Start development environment: `npm run dev`
2. Open Electron app (automatically launches)
3. Test Gemini integration in the "Gemini Ping-Pong Test" section
4. Example queries:
   - "What are the details for product ID 123?"
   - "Tell me about the Super Widget product"
   - "Add a new coffee drink called Cappuccino for €3.50"

## API Structure

### LLM Service
Located in `packages/backend/src/services/llm.service.js`

- **Function Calling:** Direct API execution via Gemini tools
- **Product Management:** getProductDetails function for inventory queries
- **Conversation History:** Maintains context across requests
- **Error Handling:** Multi-model fallback (Gemini 2.5 Flash → 2.0 Flash → 1.5 Flash)

### WebSocket + HTTP Fallback
Located in `packages/client-desktop/src/renderer/src/hooks/useWebSocket.js`

- **Primary:** WebSocket for real-time communication
- **Fallback:** HTTP requests with same operationId
- **Idempotency:** UUID-based operation tracking prevents duplicates

## Development Guidelines

### Code Organization
- **Backend:** RESTful API design with LLM service layer
- **Frontend:** React hooks pattern with custom WebSocket management
- **Database:** Knex.js migrations for schema versioning
- **Logging:** Structured JSON logs via Pino

### LLM Integration Patterns
- Function declarations follow Google's official structure
- System context defines POS-specific behavior
- All product queries must use available tools
- Error recovery with model fallback chain

### Communication Protocol
```javascript
// Request format
{
  operationId: "uuid-v4",
  command: "ping_ws",
  payload: { data: "test" }
}

// Response format  
{
  operationId: "uuid-v4",
  status: "success|error|already_processed",
  payload: { /* response data */ },
  channel: "websocket|http"
}
```

## Fiscal Compliance

### German Requirements
- **TSE (Technical Security Equipment):** Required for all cash transactions
- **DSFinV-K:** Standardized export format for tax authorities
- **Time Synchronization:** Mandatory TSE clock verification on startup
- **Data Retention:** Long-term archival with cryptographic integrity

### Implementation Status
- ✅ Basic LLM integration with product management
- ✅ WebSocket/HTTP communication system
- ✅ SQLite database with migrations
- 🔄 TSE integration (planned)
- 🔄 DSFinV-K export (planned)
- 🔄 Hedera blockchain anchoring (planned)

## Distribution

### Free Version
- **License:** EUPL-1.2 (European Union Public Licence)
- **LLM:** Google Gemini Flash
- **Requirement:** User-provided Google API key (BYOK)
- **Database:** Local SQLite only

### Pro Version (Planned)
- **LLM:** Google Gemini Pro
- **Features:** Cloud sync, advanced reporting, priority support
- **Archival:** Qualified eIDAS timestamps
- **Pricing:** Subscription-based with transparent cost structure

## Contributing

### Areas of Need
1. **Fiscal Compliance:** International POS regulations expertise
2. **UI/UX:** Geometric tessellation interface improvements  
3. **Testing:** Real-world restaurant environment validation
4. **Documentation:** User guides and API documentation
5. **Localization:** Multi-language support and regional adaptations

### Development Setup
1. Fork repository
2. Set up development environment as above
3. Check GitHub Issues for "good first issue" labels
4. Submit pull requests with clear descriptions

### International Expansion
Currently focused on German market. Contributors needed for:
- 🇫🇷 France: Fiscal printer requirements
- 🇮🇹 Italy: RT compliance and fiscal memory
- 🇬🇧 UK: Making Tax Digital (MTD) requirements  
- 🇵🇱 Poland: JPK reporting and online registers
- 🇺🇸 USA: State-specific sales tax regulations

## License

Copyright 2025 Betruger Sp. z o.o.  
Original work by Dmytro Surovtsev

Licensed under the European Union Public Licence v. 1.2 (EUPL-1.2).  
See [LICENSE](LICENSE) for details.

## Links

- **Repository:** [github.com/xelth-com/eckasse](https://github.com/xelth-com/eckasse)
- **Documentation:** [eckasse.com](https://eckasse.com) (planned)
- **Issues:** [GitHub Issues](https://github.com/xelth-com/eckasse/issues)
- **Discussions:** [GitHub Discussions](https://github.com/xelth-com/eckasse/discussions)


--- File: /docs_forLMM/ecKasse_Complete_Concept_v2.json ---

{
  "_format": {
    "format_version": "1.1",
    "format_name": "Kompaktes JSON-Format für Dokumentenverarbeitung",
    "generated_date": "2025-07-05",
    "generated_timestamp": "2025-07-05T09:43:30.073Z",
    "abbreviation_legend": {
      "doc": "document - Einzigartiger Name oder ID des Dokuments",
      "meta": "metadata - Objekt, das Metadaten über das gesamte Dokument enthält",
      "pub": "publisher - Herausgeber des Dokuments",
      "btr": "btr_number - Dokumentennummer oder spezifische Kennung",
      "t": "title - Haupttitel des Dokuments",
      "p": "part - Untertitel, Teil oder spezifischere Beschreibung des Inhalts",
      "v": "version - Versionsnummer des Dokuments",
      "d": "date - Veröffentlichungsdatum im Format YYYY-MM-DD",
      "pgs": "pages - Ein Array von Seitenobjekten",
      "pg": "page_number - Die Seitenzahl (Integer)",
      "c": "content - Ein Array von Inhaltselement-Objekten auf einer Seite",
      "type": "element_type - Der Typ des Inhaltselements",
      "hdr": "header - Ein Überschriften-Element",
      "pgh": "paragraph - Ein normaler Textabsatz",
      "tbl": "table - Ein Tabellen-Element",
      "cap": "caption - Die Beschriftung für ein Element",
      "hdrs": "headers - Array von Spaltenüberschriften einer Tabelle",
      "r": "rows - Array von Arrays, das die Zeilen einer Tabelle darstellt",
      "lst": "list - Ein Listen-Element",
      "i": "items - Array von Strings oder Objekten (Listenpunkte)",
      "ord": "ordered - Boolescher Wert, ob Liste nummeriert ist",
      "cb": "code_block - Ein Code-Block oder vorformatierter Text",
      "ftn": "footnote_definition - Eine Fußnotendefinition",
      "m": "marker - Die Markierung einer Fußnote",
      "toc": "table_of_contents - Ein Inhaltsverzeichnis-Element",
      "ch": "children - Array von untergeordneten TOC-Einträgen",
      "ci": "contact_info - Ein Block mit Kontaktinformationen",
      "tb": "title_block - Der Haupttitelblock auf der Titelseite",
      "l": "level - Die Hierarchieebene einer Überschrift (Integer)",
      "n": "number - Die Nummerierung einer Überschrift",
      "txt": "text - Der eigentliche Textinhalt eines Elements",
      "img": "image - Ein Bild-Element",
      "src": "source - Bildquelle oder Referenz",
      "alt": "alt_text - Alternativer Text für Bilder",
      "ref": "reference - Referenz oder Verweis",
      "url": "url - URL oder Link",
      "anx": "annex - Anhang-Element",
      "sec": "section - Sektion oder Bereich"
    },
    "description": "Dieses Dokument verwendet das kompakte JSON-Format für token-effiziente Dokumentendarstellung",
    "statistics": {
      "total_pages": 24,
      "total_elements": 188,
      "element_types": {
        "tb": 1,
        "hdr": 78,
        "lst": 24,
        "pgh": 39,
        "tbl": 22,
        "cb": 24
      },
      "page_range": {
        "min": 1,
        "max": 24
      },
      "content_distribution": {
        "1": 7,
        "2": 5,
        "3": 7,
        "4": 7,
        "5": 8,
        "6": 8,
        "7": 9,
        "8": 6,
        "9": 8,
        "10": 9,
        "11": 10,
        "12": 8,
        "13": 10,
        "14": 9,
        "15": 11,
        "16": 9,
        "17": 9,
        "18": 7,
        "19": 7,
        "20": 12,
        "21": 15,
        "22": 3,
        "23": 2,
        "24": 2
      },
      "structure_analysis": {
        "headers_by_level": {
          "2": 19,
          "3": 54,
          "4": 5
        },
        "tables_count": 22,
        "lists_count": 24,
        "code_blocks_count": 24,
        "footnotes_count": 0
      },
      "avg_elements_per_page": 7.83,
      "page_coverage": "1-24"
    },
    "processing_info": {
      "chunks_processed": 9,
      "chunks_total": 9,
      "processing_date": "2025-07-05T09:43:30.081Z"
    }
  },
  "meta": {
    "doc": "ecKasse_Complete_Concept_v2",
    "pub": "Betruger sp. z o.o.",
    "t": "ecKasse - Vollständige Projektkonzeption",
    "p": "LLM-gesteuerte Kassensystem mit geometrischer UI-Tesselierung und Blockchain-Verankerung",
    "v": "2.0.0",
    "d": "2025-01-10"
  },
  "pgs": [
    {
      "pg": 1,
      "c": [
        {
          "type": "tb",
          "txt": "ecKasse - LLM-управляемая Кассовая Система (POS)",
          "l": 1
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "0",
          "txt": "Брендинг и Инфраструктура Проекта"
        },
        {
          "type": "lst",
          "i": [
            "Название проекта: ecKasse",
            "Домены для комьюнити: ecKasse.com, ecKasse.de, ecKasse.eu",
            "Репозиторий: github.com/xelth-com/ecKasse",
            "Разработчик: Betruger sp. z o.o. (провокационное название как маркетинговая стратегия)",
            "Экосистема: Часть пакета eckWms (Warehouse Management System)",
            "Облачная инфраструктура: eck1.com, eck2.com, eck3.com (опциональные Pro-функции)"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "1",
          "txt": "Философия и Уникальное Торговое Предложение"
        },
        {
          "type": "pgh",
          "txt": "Основная идея: Замена сложных меню и ручных конфигураций естественным диалогом с LLM-агентом. Цель - минимизировать потребность в сервис-техниках для рутинных настроек POS-систем."
        },
        {
          "type": "pgh",
          "txt": "УТП: 'Разговорная коммерция' + 'zero-config' для базовых операций + открытый исходный код + революционная геометрическая тесселяция интерфейса."
        },
        {
          "type": "pgh",
          "txt": "Провокационная стратегия брендинга: Название 'Betruger' создает изначальную скептичность, которая при доказательстве исключительной надежности превращается в гораздо более сильное доверие, чем у компаний с 'безопасными' названиями."
        }
      ]
    },
    {
      "pg": 2,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "2",
          "txt": "Целевые Проблемы и Решения"
        },
        {
          "type": "tbl",
          "cap": "Сравнение традиционных POS и ecKasse",
          "hdrs": [
            "Традиционные POS",
            "Проблема",
            "Решение ecKasse"
          ],
          "r": [
            [
              "Square, Toast, Lightspeed",
              "Меню-ориентированная настройка требует обучения",
              "Настройка через естественный язык"
            ],
            [
              "Vectron, MICROS, NCR",
              "Дорогие установки, долгие циклы развертывания",
              "Самостоятельная установка через LLM"
            ],
            [
              "SumUp, Zettle",
              "Слишком простые для сложных ресторанов",
              "Полный функционал + простота использования"
            ],
            [
              "Все системы",
              "Vendor lock-in, проприетарные форматы",
              "Универсальный OOP-POS-MDF формат"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "3",
          "txt": "Революционные Особенности ecKasse"
        },
        {
          "type": "lst",
          "i": [
            "Первая POS-система с полноценной LLM-интеграцией для настройки и управления",
            "Уникальная геометрическая тесселяция UI (шестиугольники, квадраты, восьмиугольники)",
            "Blockchain-якорение через Hedera Consensus Service для неизменяемых аудиторских следов",
            "Универсальный формат данных OOP-POS-MDF предотвращает vendor lock-in",
            "Коллективная модель ценообразования TSE - чем больше пользователей, тем дешевле для всех"
          ],
          "ord": true
        },
        {
          "type": "pgh",
          "txt": "Экологический аспект: Отказ от энергоемких Proof-of-Work блокчейнов в пользу Hedera с ультранизким энергопотреблением демонстрирует ответственный подход к технологическим решениям."
        }
      ]
    },
    {
      "pg": 3,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "4",
          "txt": "Техническая Архитектура и Стек Технологий"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "4.1",
          "txt": "Обновленный Стек Технологий (без React)"
        },
        {
          "type": "tbl",
          "cap": "Технологический стек ecKasse v2.0",
          "hdrs": [
            "Компонент",
            "Технология",
            "Обоснование"
          ],
          "r": [
            [
              "Desktop Client",
              "Electron.js + Svelte",
              "Modern, high-performance UI framework for desktop and web versions."
            ],
            [
              "Mobile Client",
              "Native Android (Kotlin + Jetpack Compose)",
              "Two deployment scenarios: 1. Full-stack for single POS devices. 2. Frontend-only for multi-till setups connected to a shared backend/TSE."
            ],
            [
              "Backend",
              "Node.js + Express.js",
              "В Main процессе Electron, проверенное решение"
            ],
            [
              "Database",
              "SQLite + Knex.js",
              "Локальное хранение с миграциями"
            ],
            [
              "LLM",
              "Google Gemini (Flash/Pro)",
              "Function Calling, многоязычность"
            ],
            [
              "LLM Framework",
              "LangChain.js",
              "Управление промптами и инструментами"
            ],
            [
              "Dev Tools",
              "esbuild + npm scripts",
              "Замена nodemon, быстрая сборка"
            ],
            [
              "Логирование",
              "Pino + pino-pretty",
              "Структурированные логи для анализа"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "4.2",
          "txt": "Многоуровневая Отказоустойчивая Система Связи"
        },
        {
          "type": "pgh",
          "txt": "Архитектура автоматического переключения каналов связи обеспечивает максимальную доступность системы даже при сбоях сети или сервера."
        },
        {
          "type": "lst",
          "i": [
            "Уровень 1 (Основной): Локальные WebSockets - минимальная задержка для операций в реальном времени",
            "Уровень 2 (Резерв): Локальный HTTP API - fallback при проблемах с WebSocket соединением",
            "Уровень 3 (Облачный): Прокси через eckX.com - для удаленного доступа и управления несколькими кассами"
          ],
          "ord": true
        },
        {
          "type": "cb",
          "cap": "Пример реализации идемпотентности операций",
          "c": "// Каждая операция получает уникальный UUID\nconst operationId = crypto.randomUUID();\n\n// Отправка через WebSocket с автоматическим fallback\nasync function executeOperation(operation, data) {\n  const payload = { operationId, operation, data };\n  \n  try {\n    // Попытка через WebSocket\n    return await sendViaWebSocket(payload);\n  } catch (wsError) {\n    console.warn('WebSocket failed, trying HTTP...', wsError);\n    // Автоматический fallback на HTTP\n    return await sendViaHTTP(payload);\n  }\n}\n\n// Сервер дедуплицирует по operationId\nif (processedOperations.has(operationId)) {\n  return { status: 'already_processed', channel: 'previous' };\n}"
        }
      ]
    },
    {
      "pg": 4,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "4.3",
          "txt": "Архитектура Фискализации для Германии"
        },
        {
          "type": "pgh",
          "txt": "Принцип: 'Один налогоплательщик = одна TSE'. Это оптимизирует расходы для клиентов и соответствует реальным требованиям немецкого законодательства."
        },
        {
          "type": "lst",
          "i": [
            "Бэкенд выступает как менеджер TSE-инстансов",
            "Каждый независимый налогоплательщик получает уникальный TSE-инстанс через облачные сервисы (Fiskaly/A-Trust)",
            "Несколько касс одного налогоплательщика используют общую TSE",
            "Маппинг: taxpayer_id → tse_instance_id обеспечивает соответствие законодательству",
            "Автоматическое создание TSE-инстансов при регистрации новых налогоплательщиков"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "4.4",
          "txt": "Монорепозиторий и Структура Проекта"
        },
        {
          "type": "cb",
          "cap": "Структура файлов проекта",
          "c": "ecKasse/\n├── packages/\n│   ├── backend/              # Node.js + Express\n│   │   ├── src/\n│   │   │   ├── api/           # REST API endpoints\n│   │   │   ├── llm/           # LLM integration\n│   │   │   ├── tse/           # TSE manager\n│   │   │   ├── services/      # Business logic\n│   │   │   └── db/            # Database layer\n│   │   └── package.json\n│   ├── client-desktop/       # Electron app\n│   │   ├── src/\n│   │   │   ├── main/          # Electron main process\n│   │   │   ├── renderer/      # UI layer (Vanilla JS + Lit)\n│   │   │   ├── components/    # Web Components\n│   │   │   └── styles/        # CSS for tessellation UI\n│   │   └── package.json\n│   └── shared/               # Common utilities\n│       ├── types/            # TypeScript definitions\n│       └── constants/        # Shared constants\n├── docs/                     # Documentation\n├── scripts/                  # Build and dev scripts\n└── package.json              # Root package.json"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "4.5",
          "txt": "Система Сборки без Nodemon"
        },
        {
          "type": "tbl",
          "cap": "Замена Nodemon и React инфраструктуры",
          "hdrs": [
            "Было",
            "Стало",
            "Преимущества"
          ],
          "r": [
            [
              "nodemon",
              "npm scripts + esbuild --watch",
              "Быстрее, меньше зависимостей"
            ],
            [
              "React dev server",
              "esbuild serve + custom reload",
              "Нативная производительность"
            ],
            [
              "React build",
              "esbuild bundle",
              "Мгновенная сборка"
            ],
            [
              "webpack/vite",
              "esbuild",
              "Минимальная конфигурация"
            ],
            [
              "JSX",
              "Lit html`` template literals",
              "Нативные Web Components"
            ]
          ]
        }
      ]
    },
    {
      "pg": 5,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "5",
          "txt": "Ключевые Функции и LLM Интеграция"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "5.1",
          "txt": "Интеллектуальное Управление Данными через LLM"
        },
        {
          "type": "pgh",
          "txt": "ecKasse революционизирует управление POS-данными, позволяя настраивать систему через естественный язык вместо сложных меню."
        },
        {
          "type": "tbl",
          "cap": "Примеры LLM-диалогов для управления системой",
          "hdrs": [
            "Пользовательский запрос",
            "Действие LLM",
            "Результат"
          ],
          "r": [
            [
              "Добавь новый кофейный напиток Капучино за €3.50 с НДС 7%",
              "createProduct(name:'Капучино', price:3.50, taxRate:7, category:'coffee')",
              "Товар создан и добавлен в категорию кофе"
            ],
            [
              "Сделай скидку 20% на все коктейли с 17:00 до 19:00 в будни",
              "createModifier(type:'happy_hour', discount:20, categories:['cocktails'], time:'17:00-19:00', days:'mon-fri')",
              "Модификатор Happy Hour создан"
            ],
            [
              "Какая наша дневная выручка и самый популярный товар?",
              "getSalesReport(period:'today') + getTopSellingItems(period:'today')",
              "Отчет: €1,247 выручка, лидер: Латте (23 шт)"
            ],
            [
              "Покажи товары, которые редко заказывают",
              "getSlowMovingItems(threshold:5, period:'month')",
              "Список из 8 товаров с продажами < 5 в месяц"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "5.2",
          "txt": "Система Именования Товаров (Тройная Номенклатура)"
        },
        {
          "type": "pgh",
          "txt": "Каждый товар в ecKasse имеет три специализированных названия для разных контекстов использования:"
        },
        {
          "type": "lst",
          "i": [
            "menu_display_name (до 255 символов): Полное описание для меню и детальных просмотров",
            "button_display_name (до 20 символов): Краткое название для кнопок сенсорного интерфейса",
            "receipt_print_name (до 35 символов): Оптимизированное название для печати на чеках"
          ],
          "ord": false
        },
        {
          "type": "cb",
          "cap": "Пример тройной номенклатуры для товара",
          "c": "{\n  \"item_unique_identifier\": 1001,\n  \"menu_display_name\": \"Капучино с органическим молоком и корицей (большая порция 0.3л)\",\n  \"button_display_name\": \"Капучино L\",\n  \"receipt_print_name\": \"Капучино орг.молоко 0.3л\",\n  \"item_price_value\": 4.20,\n  \"associated_category_unique_identifier\": 2\n}"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "5.5",
          "txt": "Управление версиями компоновки меню (Снапшоты)"
        },
        {
          "type": "pgh",
          "txt": "Пользователь может изменять любую компоновку (как AI, так и оригинальную) и сохранять удачные варианты как 'снапшоты'. Это позволяет безопасно экспериментировать с интерфейсом и откатываться к предыдущим версиям, например, к 'той, что была на прошлой неделе и оказалась удобнее'."
        },
        {
          "type": "lst",
          "ord": false,
          "i": [
            "Любая компоновка может быть сохранена под уникальным именем (например, 'Летнее меню 2025').",
            "История версий хранится в локальной базе данных SQLite и не является частью экспортного файла oop-pos-mdf.",
            "Команда `export-mdf` всегда выгружает только одну, активную на данный момент версию компоновки.",
            "Система может быть настроена на хранение ограниченного числа последних версий для экономии места."
          ]
        }
      ]
    },
    {
      "pg": 6,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "5.3",
          "txt": "Автоматическая Настройка НДС через LLM"
        },
        {
          "type": "pgh",
          "txt": "LLM-агент автоматически находит актуальные налоговые ставки, используя web_search для поиска в официальных источниках."
        },
        {
          "type": "lst",
          "i": [
            "Приоритетные источники: gesetze-im-internet.de (особенно UStG §12), Bundesfinanzministerium",
            "Анализ контекста применения ставки (например, кофе 'с собой' vs 'в заведении')",
            "Автоматическое предложение применения ставки к категориям товаров",
            "Отслеживание изменений в законодательстве и уведомления об обновлениях"
          ],
          "ord": false
        },
        {
          "type": "cb",
          "cap": "Пример диалога с LLM для настройки НДС",
          "c": "User: \"Какая ставка НДС для кофе на вынос в Германии?\"\n\nLLM: *выполняет web_search('Mehrwertsteuersatz Kaffee zum Mitnehmen Deutschland')*\n\nLLM: \"Согласно §12 UStG, для кофе 'с собой' применяется стандартная ставка 19%. \nДля кофе, употребляемого в заведении, действует льготная ставка 7%.\n\nХотите применить 19% ко всем товарам в категории 'Напитки на вынос'?\"\n\nUser: \"Да, примени\"\n\nLLM: *выполняет updateCategoryTaxRate(category:'takeaway_drinks', taxRate:19)*"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "5.4",
          "txt": "Система Макросов и Автоматизации"
        },
        {
          "type": "pgh",
          "txt": "ecKasse поддерживает два уровня автоматизации: JSON-макросы для простых последовательностей и JavaScript-макросы для сложной логики."
        },
        {
          "type": "tbl",
          "cap": "Сравнение типов макросов",
          "hdrs": [
            "JSON-макросы",
            "JavaScript-макросы"
          ],
          "r": [
            [
              "Простая структура",
              "Полная программная логика"
            ],
            [
              "Безопасные по умолчанию",
              "Выполнение в sandbox"
            ],
            [
              "Создаются LLM автоматически",
              "Требуют режим разработчика"
            ],
            [
              "Условия, циклы, переменные",
              "Доступ к eckasse.api объекту"
            ],
            [
              "Для большинства пользователей",
              "Для продвинутых настроек"
            ]
          ]
        },
        {
          "type": "cb",
          "cap": "Пример JSON-макроса для закрытия смены",
          "c": "{\n  \"macro_name\": \"close_shift\",\n  \"description\": \"Закрытие смены с печатью отчетов\",\n  \"trigger\": \"manual\",\n  \"actions\": [\n    {\n      \"action\": \"print_x_report\",\n      \"printer\": \"main_receipt_printer\"\n    },\n    {\n      \"action\": \"check_cash_drawer_balance\",\n      \"expected_variance\": 5.00\n    },\n    {\n      \"action\": \"create_backup\",\n      \"destination\": \"cloud\",\n      \"encrypt\": true\n    },\n    {\n      \"action\": \"send_notification\",\n      \"message\": \"Смена закрыта успешно\",\n      \"recipients\": [\"manager\"]\n    }\n  ]\n}"
        }
      ]
    },
    {
      "pg": 7,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "5.5",
          "txt": "Продвинутая Логика Продаж"
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "5.5.1",
          "txt": "Система Модификаторов"
        },
        {
          "type": "pgh",
          "txt": "Модификаторы - это правила, которые автоматически изменяют цены или поведение товаров на основе различных условий."
        },
        {
          "type": "lst",
          "i": [
            "Временные модификаторы: Happy Hour, утренние скидки, ночные наценки",
            "Комбинационные модификаторы: скидки за покупку нескольких товаров",
            "Сезонные модификаторы: летние/зимние меню, праздничные предложения",
            "Персональные модификаторы: скидки для постоянных клиентов",
            "Количественные модификаторы: оптовые скидки, прогрессивные наценки"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "5.5.2",
          "txt": "PLU Links (Гарниры и Связанные Товары)"
        },
        {
          "type": "pgh",
          "txt": "Система связей между товарами особенно важна для гастрономии, где многие блюда состоят из основы и дополнений."
        },
        {
          "type": "cb",
          "cap": "Пример конфигурации PLU Links",
          "c": "{\n  \"main_item\": {\n    \"id\": 2001,\n    \"name\": \"Стейк\",\n    \"price\": 18.00\n  },\n  \"linked_items\": {\n    \"required_sides\": [\n      {\n        \"category\": \"Гарниры\",\n        \"min_selections\": 1,\n        \"max_selections\": 2,\n        \"options\": [\"Картофель фри\", \"Рис\", \"Овощи гриль\"]\n      }\n    ],\n    \"optional_extras\": [\n      {\n        \"category\": \"Соусы\", \n        \"price_modifier\": \"+0.50\",\n        \"options\": [\"Перечный\", \"Грибной\", \"Барбекю\"]\n      }\n    ]\n  }\n}"
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "5.5.3",
          "txt": "Управление Столами"
        },
        {
          "type": "lst",
          "i": [
            "Открытие и закрытие столов с отслеживанием времени",
            "Перенос позиций между столами",
            "Разделение счета на несколько частей",
            "Объединение столов для больших компаний",
            "Резервирование столов с интеграцией в календарь"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "7.3",
          "txt": "Контекстно-адаптивный интерфейс (Живая компоновка)"
        },
        {
          "type": "pgh",
          "txt": "Вместо жестких окон и статических панелей, интерфейс ecKasse адаптируется к текущей задаче пользователя. Когда пользователь сфокусирован на определенной операции (например, глубокий поиск по категориям), релевантная область UI временно расширяется, а второстепенные элементы (например, кнопки оплаты) скрываются, уступая место контекстным действиям."
        },
        {
          "type": "tbl",
          "cap": "Примеры смены состояний и трансформации UI",
          "hdrs": [
            "Состояние приложения (State)",
            "Активная зона",
            "Трансформация `FunctionArea`"
          ],
          "r": [
            [
              "SELECTION (Выбор товаров)",
              "Выбор категорий и товаров",
              "Отображаются основные кнопки: [Оплата, Отмена, Скидка]"
            ],
            [
              "DEEP_SEARCH (Поиск/Навигация)",
              "Дерево категорий или результаты поиска",
              "На месте кнопок оплаты появляются: [Сортировка А-Я, Фильтры, Назад]"
            ],
            [
              "ITEM_MODIFICATION (Настройка товара)",
              "Выбранный товар в чеке",
              "Отображаются кнопки: [Количество, Доп. опции, Удалить позицию]"
            ]
          ]
        },
        {
          "type": "cb",
          "cap": "Пример реализации в Svelte с помощью управления состоянием",
          "c": "\n<script>\n  import { appState } from './stores.js'; // 'SELECTION' | 'SEARCH' | 'PAYMENT'\n  import FunctionArea from './FunctionArea.svelte';\n  import SearchContextArea from './SearchContextArea.svelte';\n  import { fade } from 'svelte/transition';\n</script>\n\n<div class=\"grid-function-area\">\n  {#if $appState === 'SELECTION'}\n    <div transition:fade|local><FunctionArea /></div>\n  {:else if $appState === 'SEARCH'}\n    <div transition:fade|local><SearchContextArea /></div>\n  {/if}\n</div>"
        },
        {
          "type": "pgh",
          "txt": "Ключевой особенностью является предоставление пользователю выбора между двумя режимами отображения, которые хранятся в одной конфигурации. Это позволяет совместить удобство привычного меню с эффективностью AI-оптимизации."
        },
        {
          "type": "tbl",
          "cap": "Режимы отображения, доступные пользователю в UI",
          "hdrs": [
            "Режим",
            "Описание",
            "Источник структуры"
          ],
          "r": [
            [
              "Оригинал меню",
              "Структура в точности повторяет исходное меню, загруженное пользователем. Полезно на начальном этапе для адаптации персонала.",
              "Прямой парсинг исходного файла (`..._parsed.json`)."
            ],
            [
              "Умная сортировка (AI)",
              "Иерархическая структура, созданная AI для максимальной скорости работы. Группирует товары семантически (например, по типу блюд).",
              "Результат работы `enrichment.service` с использованием `parent_category_unique_identifier`."
            ]
          ]
        }
      ]
    },
    {
      "pg": 8,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "6",
          "txt": "Революционная Геометрическая Тесселяция UI"
        },
        {
          "type": "pgh",
          "txt": "ecKasse внедряет принципиально новый подход к дизайну POS-интерфейсов, используя различные геометрические формы для создания интуитивно понятной и эргономичной системы управления."
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "6.1",
          "txt": "Принципы Геометрической Дифференциации"
        },
        {
          "type": "tbl",
          "cap": "Зоны интерфейса и их геометрические формы",
          "hdrs": [
            "Зона",
            "Геометрия",
            "Применение",
            "Обоснование"
          ],
          "r": [
            [
              "Цифровая клавиатура",
              "4.4.4 (Квадраты)",
              "Ввод количества, цен, кодов",
              "Соответствует привычным раскладкам калькуляторов"
            ],
            [
              "Основной выбор",
              "6.6.6 (Шестиугольники)",
              "Категории, популярные товары",
              "Максимальная плотность заполнения пространства"
            ],
            [
              "Модификаторы",
              "4.8.8 (Квадраты + восьмиугольники)",
              "Иерархические выборы",
              "Визуальная связь родитель-потомок"
            ],
            [
              "Функциональные кнопки",
              "Прямоугольники",
              "Системные операции",
              "Четкое отделение от товарных кнопок"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "6.2",
          "txt": "Реализация через Web Components"
        },
        {
          "type": "cb",
          "cap": "Пример Web Component для шестиугольной кнопки",
          "c": "import { LitElement, html, css } from 'lit';\n\nclass HexButton extends LitElement {\n  static styles = css`\n    .hex-button {\n      width: 100px;\n      height: 87px;\n      position: relative;\n      cursor: pointer;\n      transition: transform 0.2s;\n    }\n    \n    .hex-shape {\n      width: 100%;\n      height: 100%;\n      clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);\n      background: var(--hex-bg-color, #4CAF50);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n    }\n    \n    .hex-button:hover {\n      transform: scale(1.1);\n    }\n    \n    .hex-text {\n      color: white;\n      font-weight: bold;\n      text-align: center;\n      font-size: 12px;\n    }\n  `;\n  \n  static properties = {\n    label: { type: String },\n    category: { type: String },\n    color: { type: String }\n  };\n  \n  render() {\n    return html`\n      <div class=\"hex-button\" \n           style=\"--hex-bg-color: ${this.color}\"\n           @click=\"${this._handleClick}\">\n        <div class=\"hex-shape\">\n          <span class=\"hex-text\">${this.label}</span>\n        </div>\n      </div>\n    `;\n  }\n  \n  _handleClick() {\n    this.dispatchEvent(new CustomEvent('category-selected', {\n      detail: { category: this.category }\n    }));\n  }\n}\n\ncustomElements.define('hex-button', HexButton);"
        }
      ]
    },
    {
      "pg": 9,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "6.3",
          "txt": "Адаптивная Тесселяция"
        },
        {
          "type": "pgh",
          "txt": "Система автоматически адаптирует геометрические паттерны к размеру экрана и количеству элементов, сохраняя оптимальную эргономику."
        },
        {
          "type": "lst",
          "i": [
            "Автоматическое масштабирование форм при изменении разрешения экрана",
            "Динамическое перераспределение элементов при добавлении новых категорий",
            "Сохранение пропорций и визуальной иерархии на всех устройствах",
            "Адаптация к различным соотношениям сторон (16:9, 4:3, планшеты)",
            "Поддержка как портретной, так и альбомной ориентации"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "6.4",
          "txt": "Цветовая Кодировка и Доступность"
        },
        {
          "type": "tbl",
          "cap": "Цветовая схема для различных типов товаров",
          "hdrs": [
            "Категория",
            "Цвет",
            "Психологическое воздействие",
            "Контрастность"
          ],
          "r": [
            [
              "Напитки холодные",
              "#4FC3F7 (голубой)",
              "Свежесть, прохлада",
              "AAA"
            ],
            [
              "Напитки горячие",
              "#FF8A65 (оранжевый)",
              "Тепло, уют",
              "AAA"
            ],
            [
              "Основные блюда",
              "#81C784 (зеленый)",
              "Сытость, натуральность",
              "AAA"
            ],
            [
              "Десерты",
              "#F06292 (розовый)",
              "Сладость, удовольствие",
              "AA"
            ],
            [
              "Алкоголь",
              "#9575CD (фиолетовый)",
              "Премиальность, вечер",
              "AA"
            ],
            [
              "Закуски",
              "#FFB74D (желтый)",
              "Легкость, быстрота",
              "AAA"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "6.5",
          "txt": "Анимации и Интерактивность"
        },
        {
          "type": "pgh",
          "txt": "Геометрические элементы обогащаются тонкими анимациями, которые улучшают пользовательский опыт без отвлечения от основных задач."
        },
        {
          "type": "cb",
          "cap": "CSS анимации для геометрических переходов",
          "c": "/* Морфинг квадрата в шестиугольник при активации */\n.square-to-hex {\n  clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);\n  transition: clip-path 0.3s ease-in-out;\n}\n\n.square-to-hex.active {\n  clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);\n}\n\n/* Пульсация при добавлении товара в корзину */\n@keyframes item-added {\n  0% { transform: scale(1); }\n  50% { transform: scale(1.2); filter: brightness(1.3); }\n  100% { transform: scale(1); }\n}\n\n.item-added-animation {\n  animation: item-added 0.4s ease-out;\n}\n\n/* Волновой эффект при категорийном переходе */\n.tessellation-wave {\n  animation: wave-propagation 0.6s ease-out;\n}\n\n@keyframes wave-propagation {\n  0% { transform: translateY(0) rotate(0deg); opacity: 1; }\n  50% { transform: translateY(-10px) rotate(2deg); opacity: 0.8; }\n  100% { transform: translateY(0) rotate(0deg); opacity: 1; }\n}"
        }
      ]
    },
    {
      "pg": 10,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "6.6",
          "txt": "Эргономические Преимущества"
        },
        {
          "type": "lst",
          "i": [
            "Снижение когнитивной нагрузки: мгновенное распознавание зон по форме",
            "Уменьшение ошибок нажатия: четкие границы между функциональными областями",
            "Повышение скорости работы: интуитивная навигация без обучения",
            "Снижение утомляемости: разнообразие форм предотвращает монотонность",
            "Улучшение запоминания: геометрическая память сильнее текстовой"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "7",
          "txt": "Пользовательский Опыт (UX) и Взаимодействие"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "7.1",
          "txt": "Многомодальное Взаимодействие"
        },
        {
          "type": "pgh",
          "txt": "ecKasse поддерживает несколько способов взаимодействия одновременно, позволяя пользователям выбирать наиболее удобный метод для каждой ситуации."
        },
        {
          "type": "tbl",
          "cap": "Методы взаимодействия с системой",
          "hdrs": [
            "Метод",
            "Применение",
            "Преимущества",
            "Ограничения"
          ],
          "r": [
            [
              "Голосовой ввод + LLM",
              "Сложные настройки, поиск",
              "Руки свободны, естественность",
              "Шум в зале"
            ],
            [
              "Тач-интерфейс",
              "Быстрые продажи",
              "Скорость, привычность",
              "Загрязнение экрана"
            ],
            [
              "Сканер штрих-кодов",
              "Товары с кодами",
              "Точность, скорость",
              "Не все товары"
            ],
            [
              "Клавиатура/горячие клавиши",
              "Частые операции",
              "Профессиональная скорость",
              "Требует запоминания"
            ],
            [
              "Жесты",
              "Навигация",
              "Интуитивность",
              "Случайные активации"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "7.2",
          "txt": "Контекстная Помощь и Обучение"
        },
        {
          "type": "pgh",
          "txt": "LLM-агент не только выполняет команды, но и активно помогает пользователям изучать систему и оптимизировать рабочие процессы."
        },
        {
          "type": "cb",
          "cap": "Примеры проактивной помощи от LLM",
          "c": "// Анализ паттернов использования\nif (detectPattern('coffee_pastry_combo', frequency: 'high')) {\n  suggestToUser({\n    message: \"Я заметил, что кофе и выпечку часто заказывают вместе. \n             Создать комбо-предложение со скидкой?\",\n    actions: ['create_combo', 'dismiss', 'remind_later']\n  });\n}\n\n// Обучающие подсказки\nif (userLevel === 'beginner' && action === 'first_z_report') {\n  showGuidedTutorial({\n    title: \"Закрытие кассовой смены\",\n    steps: [\n      \"Z-отчет подводит итоги дня\",\n      \"Проверьте наличность в кассе\",\n      \"Отчет автоматически отправится в налоговую\"\n    ]\n  });\n}\n\n// Предупреждения о потенциальных проблемах\nif (lowStock(['coffee_beans', 'milk']) && timeUntil('morning_rush') < 2.hours) {\n  alertUser({\n    priority: 'high',\n    message: \"Заканчиваются кофейные зерна и молоко перед утренним пиком!\",\n    suggestions: ['order_supplies', 'limit_coffee_menu', 'contact_supplier']\n  });\n}"
        }
      ]
    },
    {
      "pg": 11,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "8",
          "txt": "Универсальный Формат Данных: OOP-POS-MDF"
        },
        {
          "type": "pgh",
          "txt": "Object-Oriented POS Master Data Format - революционное решение проблемы vendor lock-in в индустрии POS-систем."
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "8.1",
          "txt": "Проблема Vendor Lock-in"
        },
        {
          "type": "pgh",
          "txt": "Традиционно, при переходе от одной POS-системы к другой (например, от Vectron к Square), владельцы теряют все настроенные меню, категории и конфигурации. Каждая система использует собственный проприетарный формат."
        },
        {
          "type": "tbl",
          "cap": "Проблемы миграции между POS-системами",
          "hdrs": [
            "Аспект",
            "Традиционный подход",
            "Решение ecKasse"
          ],
          "r": [
            [
              "Формат данных",
              "Проприетарный для каждой системы",
              "Универсальный OOP-POS-MDF"
            ],
            [
              "Миграция меню",
              "Ручная перенастройка",
              "Автоматический конвертер"
            ],
            [
              "Сохранение настроек",
              "Невозможно",
              "Полное сохранение"
            ],
            [
              "Время миграции",
              "Недели",
              "Часы"
            ],
            [
              "Потеря данных",
              "Значительная",
              "Отсутствует"
            ],
            [
              "Стоимость перехода",
              "Высокая",
              "Минимальная"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "8.2",
          "txt": "Архитектура OOP-POS-MDF"
        },
        {
          "type": "pgh",
          "txt": "Формат построен на принципах объектно-ориентированного программирования с четкой иерархией и самодокументируемыми именами полей."
        },
        {
          "type": "cb",
          "cap": "Структура иерархии OOP-POS-MDF",
          "c": "Company (Компания)\n├── GlobalConfigurations (Глобальные настройки)\n│   ├── TaxRateDefinitions (Определения налоговых ставок)\n│   ├── MainGroupDefinitions (Основные группы товаров)\n│   ├── PaymentMethodDefinitions (Способы оплаты)\n│   └── PrintFormatProfiles (Профили печати)\n├── Branches (Филиалы)\n│   └── POSDevices (POS-устройства)\n│       ├── HardwareInterfaces (Аппаратные интерфейсы)\n│       ├── BuiltInDisplays (Встроенные дисплеи)\n│       │   └── DisplayActivities (Экранные активности)\n│       │       └── UIElements (Элементы интерфейса)\n│       ├── ConnectedPeripherals (Периферия)\n│       ├── Categories (Категории товаров)\n│       └── Items (Товары/артикулы)"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "8.3",
          "txt": "Самодокументируемые Поля"
        },
        {
          "type": "tbl",
          "cap": "Примеры самодокументируемых названий полей",
          "hdrs": [
            "Традиционное POS",
            "OOP-POS-MDF",
            "Описание"
          ],
          "r": [
            [
              "id",
              "item_unique_identifier",
              "Уникальный идентификатор товара"
            ],
            [
              "name",
              "menu_display_name",
              "Название для отображения в меню"
            ],
            [
              "price",
              "item_price_value",
              "Цена товара"
            ],
            [
              "cat_id",
              "associated_category_unique_identifier",
              "Ссылка на категорию"
            ],
            [
              "tax",
              "linked_tax_rate_unique_identifier",
              "Ссылка на налоговую ставку"
            ],
            [
              "printer",
              "linked_print_format_profile_unique_identifier",
              "Профиль печати"
            ]
          ]
        }
      ]
    },
    {
      "pg": 12,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "8.4",
          "txt": "Конвертеры для Целевых Систем"
        },
        {
          "type": "pgh",
          "txt": "Для каждой популярной POS-системы создается специализированный конвертер, который преобразует OOP-POS-MDF в нативный формат целевой системы."
        },
        {
          "type": "cb",
          "cap": "Пример конвертера для Vectron Commander",
          "c": "class VectronConverter {\n  convertToVectronFormat(oopPosData) {\n    const vectronLines = [];\n    \n    // Конвертация категорий\n    oopPosData.categories_for_this_pos.forEach(category => {\n      vectronLines.push(\n        `301,NR:${category.category_unique_identifier}`,\n        `302,TX:\"${category.category_name_full}\"`,\n        `303,WG:${this.mapToVectronMainGroup(category.default_linked_main_group_unique_identifier)}`\n      );\n    });\n    \n    // Конвертация товаров\n    oopPosData.items_for_this_pos.forEach(item => {\n      vectronLines.push(\n        `101,NR:${item.item_unique_identifier}`,\n        `102,TX:\"${item.receipt_print_name}\"`,\n        `103,PR:${(item.item_price_value * 100).toFixed(0)}`, // Центы\n        `104,MG:${this.findTaxGroup(item.associated_category_unique_identifier)}`\n      );\n    });\n    \n    return vectronLines.join('\\n');\n  }\n  \n  mapToVectronMainGroup(mainGroupId) {\n    const mapping = {\n      1: 1, // Getränke\n      2: 2, // Speisen\n      3: 3  // Sonstiges\n    };\n    return mapping[mainGroupId] || 3;\n  }\n}"
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "9",
          "txt": "Фискализация и Юридическое Соответствие"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "9.1",
          "txt": "TSE (Технические Устройства Безопасности) для Германии"
        },
        {
          "type": "pgh",
          "txt": "Соответствие немецкому законодательству о кассовых системах (KassenSichV) через интеграцию с сертифицированными TSE-провайдерами."
        },
        {
          "type": "lst",
          "i": [
            "Автоматический контроль времени TSE при каждом запуске системы",
            "Обязательные блокирующие уведомления пользователю о сбоях батареи TSE",
            "Менеджер TSE по налогоплательщикам - один TSE на налогоплательщика",
            "Поддержка облачных TSE (Fiskaly, A-Trust) для масштабируемости",
            "Автоматическая коррекция времени при обнаружении расхождений"
          ],
          "ord": false
        },
        {
          "type": "cb",
          "cap": "Алгоритм контроля времени TSE",
          "c": "async function checkTSETime() {\n  const tseTime = await tse.getCurrentTime();\n  const systemTime = new Date();\n  const timeDiff = Math.abs(tseTime - systemTime);\n  \n  // Критический порог - 5 минут\n  const CRITICAL_THRESHOLD = 5 * 60 * 1000;\n  \n  if (timeDiff > CRITICAL_THRESHOLD) {\n    // Автоматическая коррекция\n    await tse.setTime(systemTime);\n    \n    // ОБЯЗАТЕЛЬНОЕ уведомление пользователю\n    showBlockingAlert({\n      title: \"ВНИМАНИЕ! Сбой часов TSE\",\n      message: `Обнаружен сбой часов в фискальном модуле.\n               Дата была сброшена с ${tseTime} на ${systemTime}.\n               \n               Система автоматически установила правильное время.\n               \n               ВАЖНО: Этот сбой указывает на возможное истощение \n               батареи TSE. Рекомендуется обратиться к сервисному \n               партнеру для диагностики оборудования.`,\n      buttons: [\"Понятно, продолжить работу\"],\n      blocking: true,\n      logLevel: 'CRITICAL'\n    });\n  }\n  \n  return timeDiff <= CRITICAL_THRESHOLD;\n}"
        }
      ]
    },
    {
      "pg": 13,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "9.2",
          "txt": "Долгосрочная Архивация: Концепция 'Таймкапсуль'"
        },
        {
          "type": "pgh",
          "txt": "Обеспечение доказательной ценности фискальных данных на десятилетия через создание самодостаточных архивных пакетов."
        },
        {
          "type": "tbl",
          "cap": "Состав архивной 'таймкапсуль'",
          "hdrs": [
            "Компонент",
            "Назначение",
            "Формат"
          ],
          "r": [
            [
              "TSE-экспорт",
              "Криптографически подписанные записи операций",
              "Нативный формат TSE"
            ],
            [
              "DSFinV-K экспорт",
              "Структурированные данные для налоговых органов",
              "CSV + index.xml"
            ],
            [
              "Цепочка сертификатов",
              "Полная иерархия от Root CA до TSE",
              "X.509 PEM"
            ],
            [
              "CRL/OCSP ответы",
              "Доказательство отсутствия отзыва сертификатов",
              "DER/PEM"
            ],
            [
              "Процедурная документация",
              "Описание бизнес-процессов (GoBD)",
              "PDF/A"
            ],
            [
              "Техническая документация",
              "Версии ПО, конфигурации",
              "JSON + README"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "9.3",
          "txt": "Два Уровня Защиты Целостности"
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "9.3.1",
          "txt": "Базовый уровень: Hedera Consensus Service"
        },
        {
          "type": "pgh",
          "txt": "Доступен всем пользователям бесплатно. Обеспечивает высочайший технический уровень доказательности."
        },
        {
          "type": "lst",
          "i": [
            "Ультранизкое энергопотребление по сравнению с Bitcoin/Ethereum",
            "Быстрая финальность транзакций (3-5 секунд)",
            "Модель управления корпоративного уровня",
            "Предсказуемые комиссии (центы за якорение)",
            "Публично верифицируемые доказательства",
            "Независимость от центральных органов"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "9.3.2",
          "txt": "Pro-уровень: Квалифицированные eIDAS Метки Времени"
        },
        {
          "type": "pgh",
          "txt": "Для пользователей, поддерживающих проект. Обеспечивает максимальную юридическую силу в ЕС."
        },
        {
          "type": "cb",
          "cap": "Процесс получения квалифицированной метки времени",
          "c": "async function createQualifiedTimestamp(archiveHash) {\n  // 1. Создание хэша архива\n  const hash = crypto.createHash('sha256')\n    .update(archiveBuffer)\n    .digest('hex');\n    \n  // 2. Отправка к QTSP (Qualified Trust Service Provider)\n  const timestampRequest = {\n    hashAlgorithm: 'SHA-256',\n    hashedMessage: hash,\n    requestPolicy: 'urn:oid:1.3.6.1.4.1.42553.1.3.1' // eIDAS timestamp policy\n  };\n  \n  const qualifiedTimestamp = await qtspClient.requestTimestamp(timestampRequest);\n  \n  // 3. Проверка подписи QTSP\n  const isValid = await verifyQTSPSignature(qualifiedTimestamp);\n  \n  if (!isValid) {\n    throw new Error('Неверная подпись QTSP');\n  }\n  \n  // 4. Сохранение в архив\n  archive.addFile('qualified_timestamp.tst', qualifiedTimestamp);\n  archive.addFile('qtsp_certificate_chain.pem', qtspCertChain);\n  \n  return {\n    timestamp: qualifiedTimestamp,\n    legalWeight: 'QUALIFIED_EIDAS',\n    validUntil: calculateExpiryDate(qualifiedTimestamp)\n  };\n}"
        }
      ]
    },
    {
      "pg": 14,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "10",
          "txt": "Модель Распространения и Монетизации"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "10.1",
          "txt": "Бесплатная Версия (Open Source)"
        },
        {
          "type": "tbl",
          "cap": "Характеристики бесплатной версии ecKasse",
          "hdrs": [
            "Аспект",
            "Детали",
            "Обоснование"
          ],
          "r": [
            [
              "Лицензия",
              "EUPL (European Union Public Licence)",
              "Соответствие европейскому правовому полю"
            ],
            [
              "LLM",
              "Google Gemini Flash",
              "Высокое качество при низкой стоимости"
            ],
            [
              "Покрытие расходов LLM",
              "BYOK - пользователь предоставляет API-ключ",
              "Прозрачность и контроль расходов"
            ],
            [
              "Архивация",
              "Hedera Consensus Service",
              "Техническая надежность без рекурентных платежей"
            ],
            [
              "Поддержка",
              "Community-driven",
              "Сильное сообщество разработчиков"
            ],
            [
              "Обновления",
              "Автоматические",
              "Безопасность и новые функции"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "10.2",
          "txt": "Pro-версия: Модель 'Благодарственного Евро'"
        },
        {
          "type": "pgh",
          "txt": "Философия: Программное обеспечение остается полностью бесплатным, но квалифицированные метки времени и премиум-поддержка требуют ресурсов."
        },
        {
          "type": "lst",
          "i": [
            "Добровольный взнос: €1-5 в месяц",
            "Прозрачное использование: все средства публично отслеживаются",
            "Направления расходов: квалифицированные eIDAS метки времени для всех пользователей (включая бесплатных), облачная инфраструктура, поддержка разработчиков",
            "Дополнительные преимущества: облачные бэкапы, приоритетная поддержка, ранний доступ к новым функциям",
            "Принцип справедливости: если средств от добровольных взносов не хватает, Betruger sp. z o.o. покрывает недостающие расходы"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "10.3",
          "txt": "Коллективная Модель Ценообразования TSE"
        },
        {
          "type": "pgh",
          "txt": "Принцип 'Чем больше нас, тем дешевле для всех' создает стимул для роста сообщества и справедливого распределения расходов."
        },
        {
          "type": "cb",
          "cap": "Алгоритм коллективных переговоров с TSE-провайдерами",
          "c": "class TSECommunityPricing {\n  async evaluateNegotiationOpportunity() {\n    const activeUsers = await this.getActiveUserCount();\n    const currentMonthlyCost = await this.getCurrentTSECosts();\n    \n    const thresholds = [\n      { users: 100, discount: 0.05, savings: '5%' },\n      { users: 500, discount: 0.15, savings: '15%' },\n      { users: 1000, discount: 0.25, savings: '25%' },\n      { users: 2500, discount: 0.35, savings: '35%' }\n    ];\n    \n    const applicableThreshold = thresholds\n      .reverse()\n      .find(t => activeUsers >= t.users);\n      \n    if (applicableThreshold) {\n      return this.initiateNegotiation({\n        userCount: activeUsers,\n        expectedDiscount: applicableThreshold.discount,\n        monthlyVolume: currentMonthlyCost,\n        communityBenefit: applicableThreshold.savings\n      });\n    }\n    \n    return { status: 'threshold_not_reached', nextThreshold: thresholds[0] };\n  }\n  \n  async applyNegotiatedDiscount(newRate) {\n    const savings = this.calculateSavings(newRate);\n    \n    // Немедленная передача экономии сообществу\n    await this.updateCommunityPricing({\n      newMonthlyRate: newRate,\n      effectiveDate: new Date(),\n      transparencyReport: {\n        previousRate: this.currentRate,\n        newRate: newRate,\n        monthlySavings: savings,\n        affectedUsers: await this.getActiveUserCount()\n      }\n    });\n    \n    // Уведомление сообщества\n    await this.notifyCommunity(\n      `🎉 Достигнута новая групповая скидка! \n       TSE расходы снижены на ${savings.percentage}% \n       (экономия €${savings.monthly}/месяц)`\n    );\n  }\n}"
        }
      ]
    },
    {
      "pg": 15,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "11",
          "txt": "Безопасность и Доверие"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "11.1",
          "txt": "Самоподписанные Сертификаты vs PKI"
        },
        {
          "type": "pgh",
          "txt": "Отказ от зависимости от централизованной PKI в пользу цифровых подписей полезных данных с самоподписанными сертификатами."
        },
        {
          "type": "tbl",
          "cap": "Сравнение подходов к доверию",
          "hdrs": [
            "Аспект",
            "Let's Encrypt / CA",
            "Самоподписанные сертификаты ecKasse"
          ],
          "r": [
            [
              "Срок действия",
              "90 дней",
              "Настраивается (годы)"
            ],
            [
              "Автоматическое обновление",
              "Требуется",
              "По необходимости"
            ],
            [
              "Возможность подписи данных",
              "CA:FALSE - запрещено",
              "Полная свобода"
            ],
            [
              "Зависимость от третьих лиц",
              "Критическая",
              "Отсутствует"
            ],
            [
              "Подходит для TLS",
              "Отлично",
              "Ограниченно"
            ],
            [
              "Подходит для подписи данных",
              "Нет",
              "Идеально"
            ],
            [
              "Проверка доверия",
              "Автоматическая в браузерах",
              "Ручная валидация fingerprint'ов"
            ]
          ]
        },
        {
          "type": "cb",
          "cap": "Структура подписанного payload с самоподписанным сертификатом",
          "c": "{\n  \"payload\": {\n    \"subject\": \"eckasse-installation-uuid-12345\",\n    \"issued_by\": \"betruger.com\",\n    \"issued_at\": \"2025-01-10T12:00:00Z\",\n    \"expires_at\": \"2025-12-31T23:59:59Z\",\n    \"public_key\": \"LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0...\",\n    \"permissions\": [\n      \"tse_access\",\n      \"cloud_backup\", \n      \"premium_support\"\n    ],\n    \"installation_fingerprint\": \"sha256:a1b2c3d4...\"\n  },\n  \"certificate\": \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\",\n  \"signature\": \"MEUCIQDXm8K9p...\"\n}\n\n// Процесс проверки:\n// 1. Извлечь публичный ключ из certificate\n// 2. Проверить срок действия и issued_by\n// 3. Проверить цифровую подпись payload\n// 4. (Опционально) Сверить fingerprint с доверенным списком"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "11.2",
          "txt": "Принципы Инициализации Системы"
        },
        {
          "type": "pgh",
          "txt": "Автономная генерация идентичности для максимальной отказоустойчивости и независимости от внешних сервисов."
        },
        {
          "type": "lst",
          "i": [
            "Автономная генерация UUID: каждая инсталляция создает уникальный серийный номер полностью оффлайн",
            "Вероятность коллизий UUID настолько мала (1:5.3×10³⁶), что предварительная проверка не требуется",
            "Опциональная облачная регистрация: только после успешной локальной инициализации",
            "Обработка теоретических коллизий: ответственность клиента за перегенерацию при крайне редких конфликтах",
            "Привязка к оборудованию: возможность связи UUID с аппаратными характеристиками для предотвращения простого копирования"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "11.3",
          "txt": "Устойчивость к Деградации Носителей"
        },
        {
          "type": "pgh",
          "txt": "Флеш-носители подвержены деградации со временем. Цифровые подписи чувствительны к изменению даже одного бита."
        },
        {
          "type": "cb",
          "cap": "Стратегия защиты от деградации данных",
          "c": "class DataIntegrityManager {\n  async createResilientArchive(data) {\n    // 1. Кодирование с избыточностью Reed-Solomon\n    const encodedData = this.reedSolomonEncode(data, {\n      dataShards: 10,    // Исходные блоки\n      parityShards: 4    // Избыточные блоки для восстановления\n    });\n    \n    // 2. Создание множественных копий\n    const copies = [\n      { location: 'local_ssd', priority: 1 },\n      { location: 'local_backup_drive', priority: 2 },\n      { location: 'cloud_encrypted', priority: 3 },\n      { location: 'offline_media', priority: 4 }\n    ];\n    \n    // 3. Запланированная проверка целостности\n    await this.scheduleIntegrityChecks({\n      frequency: 'monthly',\n      actions: ['verify_hashes', 'test_recovery', 'refresh_if_needed']\n    });\n    \n    return {\n      primaryLocation: copies[0],\n      backupLocations: copies.slice(1),\n      integrityProtection: 'reed_solomon_10_4',\n      nextCheck: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)\n    };\n  }\n  \n  async periodicIntegrityCheck() {\n    const results = await Promise.all(\n      this.monitoredArchives.map(async archive => {\n        const isValid = await this.verifyArchiveIntegrity(archive);\n        \n        if (!isValid) {\n          // Попытка восстановления из избыточных блоков\n          const recovered = await this.recoverFromParity(archive);\n          \n          if (recovered) {\n            await this.refreshArchive(archive, recovered);\n            return { status: 'recovered', archive: archive.id };\n          } else {\n            return { status: 'critical_failure', archive: archive.id };\n          }\n        }\n        \n        return { status: 'ok', archive: archive.id };\n      })\n    );\n    \n    // Уведомление пользователя о критических проблемах\n    const failures = results.filter(r => r.status === 'critical_failure');\n    if (failures.length > 0) {\n      await this.alertUser({\n        severity: 'HIGH',\n        message: `Обнаружена критическая деградация архивов: ${failures.map(f => f.archive).join(', ')}`,\n        action: 'Требуется создание новых резервных копий'\n      });\n    }\n  }\n}"
        }
      ]
    },
    {
      "pg": 16,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "12",
          "txt": "Дорожная Карта Разработки"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.1",
          "txt": "Фаза 1: MVP (2-3 месяца)"
        },
        {
          "type": "pgh",
          "txt": "Создание минимально жизнеспособного продукта с полным циклом продаж и базовой LLM-интеграцией."
        },
        {
          "type": "tbl",
          "cap": "Ключевые задачи MVP",
          "hdrs": [
            "Компонент",
            "Задачи",
            "Критерии готовности"
          ],
          "r": [
            [
              "База данных",
              "SQLite + Knex.js миграции, базовые таблицы",
              "Товары, категории, заказы сохраняются"
            ],
            [
              "LLM интеграция",
              "Function Calling, базовые инструменты",
              "Создание товара через диалог работает"
            ],
            [
              "UI без React",
              "Vanilla JS + Lit компоненты",
              "Интерфейс продаж функционален"
            ],
            [
              "Система связи",
              "WebSocket + HTTP fallback",
              "Идемпотентность операций"
            ],
            [
              "Полный цикл продаж",
              "Корзина → Оплата → Чек",
              "Транзакция от начала до конца"
            ],
            [
              "Базовые отчеты",
              "Z-отчет, дневная выручка",
              "Простая отчетность работает"
            ]
          ]
        },
        {
          "type": "cb",
          "cap": "Критерии готовности MVP",
          "c": "MVP_CRITERIA = {\n  core_functionality: [\n    \"Создание товара через LLM: 'Добавь Латте за €3.50'\",\n    \"Полная продажа: выбор товара → корзина → оплата → чек\",\n    \"Базовая отчетность: Z-отчет с итогами дня\",\n    \"Оффлайн работа: все операции без интернета\"\n  ],\n  \n  technical_requirements: [\n    \"WebSocket соединение с HTTP fallback\",\n    \"Идемпотентные операции через operationId\", \n    \"SQLite база с миграциями Knex.js\",\n    \"Electron app запускается на Windows/Mac/Linux\"\n  ],\n  \n  user_experience: [\n    \"Установка за < 10 минут\",\n    \"Настройка первых 10 товаров через LLM за < 15 минут\",\n    \"Проведение продажи за < 30 секунд\",\n    \"Понятные сообщения об ошибках\"\n  ],\n  \n  quality_gates: [\n    \"Стабильная работа 8 часов подряд\",\n    \"Восстановление после сбоя WebSocket < 5 секунд\",\n    \"Размер установочного файла < 200 MB\",\n    \"Время запуска приложения < 10 секунд\"\n  ]\n};"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.2",
          "txt": "Фаза 2: Геометрический UI (1-2 месяца)"
        },
        {
          "type": "lst",
          "i": [
            "Реализация тесселяции: шестиугольники для категорий, квадраты для цифр, восьмиугольники для модификаторов",
            "CSS/SVG компоненты с адаптивным масштабированием",
            "Анимации переходов между геометрическими формами",
            "Цветовая кодировка и схемы доступности (AAA контрастность)",
            "Облачный прокси-канал (Уровень 3 связи) через eckX.com",
            "Оффлайн-режим с автоматической синхронизацией при восстановлении связи"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.3",
          "txt": "Фаза 3: Продвинутые Функции (2-3 месяца)"
        },
        {
          "type": "lst",
          "i": [
            "Полная система модификаторов с условной логикой",
            "PLU Links для гарниров и связанных товаров",
            "Управление столами: разделение счетов, перенос позиций",
            "Реализация универсального формата OOP-POS-MDF",
            "Конвертеры для импорта/экспорта в популярные POS-системы (Vectron, Square)",
            "JSON и JavaScript макросы с безопасной песочницей",
            "Пользователи и роли с системой прав доступа"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.6",
          "txt": "Двухуровневая Система Управления (Идея Пользователя)"
        },
        {
          "type": "pgh",
          "txt": "Концепция разграничения прав на изменение данных и отмену операций через систему доверия и кредитования."
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "12.6.1",
          "txt": "Система Отложенных Изменений (Pending Changes)"
        },
        {
          "type": "lst",
          "i": [
            "Сотрудники с ограниченными правами могут создавать 'заявки на изменения'",
            "Изменения товаров, цен, категорий требуют подтверждения администратора",
            "Отложенные изменения отображаются в специальном интерфейсе для ревизии",
            "Система уведомлений для администраторов о ожидающих изменениях",
            "Автоматическое применение изменений после указанного времени (опционально)",
            "Возможность групповой обработки изменений (одобрить/отклонить сразу несколько)"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 4,
          "n": "12.6.2",
          "txt": "Кредитная Система Сторно (Storno Credit)"
        },
        {
          "type": "lst",
          "i": [
            "Каждый сотрудник имеет кредитный лимит для отмены операций (например, €50/день)",
            "Простые сторно (в пределах лимита) выполняются мгновенно",
            "Превышение лимита требует авторизации старшего персонала",
            "Система отслеживания 'истории доверия' для корректировки лимитов",
            "Автоматическое восстановление кредита в начале смены/дня",
            "Экстренные сторно (технические сбои) с отдельным лимитом",
            "Детальные логи всех операций сторно для аудита"
          ],
          "ord": false
        },
        {
          "type": "cb",
          "cap": "Пример реализации системы управления правами",
          "c": "class TwoLevelManagementSystem {\n  constructor() {\n    this.pendingChanges = new Map();\n    this.employeeCredits = new Map();\n    this.trustScores = new Map();\n  }\n  \n  // Система отложенных изменений\n  async requestDataChange(employeeId, changeRequest) {\n    const changeId = this.generateChangeId();\n    \n    const change = {\n      id: changeId,\n      employeeId,\n      type: changeRequest.type, // 'product_update', 'price_change', etc.\n      data: changeRequest.data,\n      reason: changeRequest.reason,\n      timestamp: new Date(),\n      status: 'pending',\n      priority: this.calculatePriority(changeRequest)\n    };\n    \n    this.pendingChanges.set(changeId, change);\n    await this.notifyAdministrators(change);\n    \n    return {\n      changeId,\n      message: 'Изменение отправлено на рассмотрение администратору',\n      estimatedApprovalTime: this.getEstimatedApprovalTime(change.priority)\n    };\n  }\n  \n  async approveChange(adminId, changeId, approved = true) {\n    const change = this.pendingChanges.get(changeId);\n    if (!change) throw new Error('Изменение не найдено');\n    \n    if (approved) {\n      await this.applyDataChange(change);\n      change.status = 'approved';\n      change.approvedBy = adminId;\n      change.approvedAt = new Date();\n      \n      // Увеличиваем доверие сотрудника\n      this.increaseTrustScore(change.employeeId);\n    } else {\n      change.status = 'rejected';\n      change.rejectedBy = adminId;\n      change.rejectedAt = new Date();\n    }\n    \n    await this.notifyEmployee(change.employeeId, change);\n    return change;\n  }\n  \n  // Кредитная система сторно\n  async requestStorno(employeeId, transactionId, amount, reason) {\n    const employee = await this.getEmployee(employeeId);\n    const dailyCredit = this.getEmployeeDailyCredit(employeeId);\n    const usedCredit = this.getUsedCreditToday(employeeId);\n    const availableCredit = dailyCredit - usedCredit;\n    \n    if (amount <= availableCredit) {\n      // Автоматическое сторно в пределах кредита\n      const storno = await this.executeStorno(transactionId, amount, {\n        employeeId,\n        reason,\n        type: 'automatic',\n        creditUsed: amount\n      });\n      \n      this.updateUsedCredit(employeeId, amount);\n      return {\n        success: true,\n        storno,\n        message: `Сторно выполнено автоматически. Использовано кредита: €${amount}`\n      };\n    } else {\n      // Требуется подтверждение администратора\n      const approvalRequest = {\n        id: this.generateRequestId(),\n        employeeId,\n        transactionId,\n        amount,\n        reason,\n        exceededBy: amount - availableCredit,\n        timestamp: new Date(),\n        status: 'pending_approval'\n      };\n      \n      await this.requestAdminApproval(approvalRequest);\n      return {\n        success: false,\n        message: `Сумма превышает кредитный лимит на €${amount - availableCredit}. Запрос отправлен администратору.`,\n        requestId: approvalRequest.id\n      };\n    }\n  }\n  \n  // Система доверия\n  increaseTrustScore(employeeId) {\n    const currentScore = this.trustScores.get(employeeId) || 50;\n    const newScore = Math.min(100, currentScore + 2);\n    this.trustScores.set(employeeId, newScore);\n    \n    // Корректируем кредитный лимит на основе доверия\n    this.adjustCreditLimit(employeeId, newScore);\n  }\n  \n  adjustCreditLimit(employeeId, trustScore) {\n    const baseLimit = 50; // €50 базовый лимит\n    const trustMultiplier = trustScore / 50; // 1.0 при доверии 50, 2.0 при доверии 100\n    const newLimit = baseLimit * trustMultiplier;\n    \n    this.employeeCredits.set(employeeId, {\n      dailyLimit: newLimit,\n      emergencyLimit: newLimit * 0.5,\n      trustScore\n    });\n  }\n}"
        }
      ]
    },
    {
      "pg": 17,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "12.3.1",
          "txt": "Фаза 1.5: Реализация отказоустойчивого фискального ядра (ЗАВЕРШЕНО)"
        },
        {
          "type": "pgh",
          "txt": "Этот критически важный этап закладывает фундамент для соответствия фискальным требованиям и обеспечивает высочайшую надежность системы."
        },
        {
          "type": "lst",
          "ord": true,
          "i": [
            "**Трехуровневая система журналов:** Реализованы отдельные, независимые журналы для фискальных, операционных и системных событий.",
            "**Атомарность операций (Write-Ahead Log):** Создан журнал состояний `pending_fiscal_operations` для гарантии, что ни одна подписанная транзакция не будет потеряна при сбое питания.",
            "**Двойная целостность данных:** В фискальный и операционный журналы внедрен механизм внутренних хэш-цепочек (hash-chain), обеспечивающий независимую от TSE проверку неизменности данных.",
            "**Автоматическое восстановление:** Реализован механизм, который при каждом запуске сервера проверяет незавершенные операции и автоматически их завершает, гарантируя консистентность данных.",
            "**Централизованный LoggingService:** Создан единый сервис для управления всеми операциями журналирования, что упрощает дальнейшую разработку.",
            "**Интеграция с бизнес-логикой:** Сервис журналирования интегрирован в ключевые модули (транзакции, управление товарами) для протоколирования сторно-операций и изменений основных данных.",
            "**Отслеживание инициатора:** В логи добавлена информация о том, кем было инициировано изменение - человеком или ИИ-агентом, для полного аудита действий."
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.4",
          "txt": "Фаза 4: Реализация полного интерактивного цикла транзакций (ЗАВЕРШЕНО)"
        },
        {
          "type": "pgh",
          "txt": "На этом этапе была реализована полная логика обработки заказа от начала до конца, соединив пользовательский интерфейс с ранее созданным отказоустойчивым фискальным ядром. Система стала полностью интерактивной."
        },
        {
          "type": "lst",
          "ord": true,
          "i": [
            "**Управление состоянием чека:** Созданы таблицы `active_transactions` и `active_transaction_items` для хранения информации о текущих, незавершенных заказах.",
            "**Сервис управления транзакциями:** Реализован `TransactionManagementService`, который управляет бизнес-логикой жизненного цикла заказа (создание, добавление позиций, завершение).",
            "**Атомарность бизнес-операций:** Все операции, изменяющие состояние чека, обернуты в транзакции базы данных, что гарантирует целостность по принципу 'всё или ничего'.",
            "**Интеграция с WebSocket:** В сервер добавлены обработчики команд (`findOrCreateActiveTransaction`, `addItemToTransaction`, `finishTransaction`) для интерактивного взаимодействия с UI.",
            "**Реактивное состояние UI (Frontend):** Создан Svelte store (`orderStore.js`) для управления состоянием заказа на стороне клиента, который автоматически обновляется через WebSocket.",
            "**Динамическое отображение:** Пользовательский интерфейс (`SelectionArea.svelte` и `ConsoleView.svelte`) был полностью интегрирован с `orderStore`, обеспечивая немедленное отображение добавленных товаров и пересчет сумм в чеке.",
            "**Реализация оплаты:** Добавлена кнопка 'Оплата', которая запускает процесс финализации чека, включая вызов `finishTransaction` и запись итогового фискального события.",
            "**Централизованное логирование UI:** Реализован механизм отправки всех логов и ошибок с фронтенда на бэкенд, обеспечивая полный обзор состояния системы для диагностики."
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.5",
          "txt": "Фаза 5: Интеграция с TSE и Экспорт DSFinV-K (2-4 месяца)"
        },
        {
          "type": "pgh",
          "txt": "Критически важная фаза для легального использования в Германии и подготовка к международному расширению."
        },
        {
          "type": "tbl",
          "cap": "Задачи фискализации по приоритету",
          "hdrs": [
            "Приоритет",
            "Задача",
            "Сложность",
            "Влияние на бизнес"
          ],
          "r": [
            [
              "Критичный",
              "TSE интеграция (Fiskaly/A-Trust)",
              "Высокая",
              "Блокер для Германии"
            ],
            [
              "Критичный",
              "Менеджер TSE для налогоплательщиков",
              "Средняя",
              "Масштабируемость"
            ],
            [
              "Высокий",
              "DSFinV-K экспорт",
              "Средняя",
              "Соответствие GoBD"
            ],
            [
              "Высокий",
              "Контроль времени TSE с уведомлениями",
              "Низкая",
              "Надежность"
            ],
            [
              "Средний",
              "Таймкапсуль архивация",
              "Высокая",
              "Долгосрочное доверие"
            ],
            [
              "Средний",
              "Hedera якорение",
              "Средняя",
              "Техническая уникальность"
            ],
            [
              "Низкий",
              "eIDAS квалифицированные метки",
              "Низкая",
              "Pro-функция"
            ]
          ]
        },
        {
          "type": "cb",
          "cap": "Архитектура менеджера TSE",
          "c": "class TSEManager {\n  constructor() {\n    this.taxpayerTSEMap = new Map();\n    this.activeConnections = new Map();\n  }\n  \n  async assignTSEToTaxpayer(taxpayerId) {\n    // Проверяем, есть ли уже TSE для этого налогоплательщика\n    if (this.taxpayerTSEMap.has(taxpayerId)) {\n      return this.taxpayerTSEMap.get(taxpayerId);\n    }\n    \n    // Создаем новый TSE-инстанс через облачного провайдера\n    const tseInstance = await this.createCloudTSE({\n      taxpayerId: taxpayerId,\n      provider: 'fiskaly', // или 'a-trust'\n      region: 'de'\n    });\n    \n    // Сохраняем маппинг\n    this.taxpayerTSEMap.set(taxpayerId, tseInstance.id);\n    this.activeConnections.set(tseInstance.id, tseInstance);\n    \n    // Персистентное сохранение\n    await db('taxpayer_tse_mapping').insert({\n      taxpayer_id: taxpayerId,\n      tse_instance_id: tseInstance.id,\n      created_at: new Date(),\n      provider: 'fiskaly'\n    });\n    \n    return tseInstance.id;\n  }\n  \n  async processTransaction(posDeviceId, transactionData) {\n    // Определяем налогоплательщика по POS-устройству\n    const taxpayerId = await this.getTaxpayerByPOSDevice(posDeviceId);\n    \n    // Получаем соответствующий TSE\n    const tseId = await this.assignTSEToTaxpayer(taxpayerId);\n    const tse = this.activeConnections.get(tseId);\n    \n    // Проверяем время TSE перед операцией\n    await this.validateTSETime(tse);\n    \n    // Обрабатываем транзакцию\n    return await tse.signTransaction(transactionData);\n  }\n}"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "12.6",
          "txt": "Фаза 6: Экосистема и Международное Расширение (1-2 месяца)"
        },
        {
          "type": "lst",
          "i": [
            "Интеграция с eckWms: синхронизация товаров, управление складом",
            "Полнофункциональные облачные сервисы на eck1/2/3.com",
            "Мультикасса управление для сетей ресторанов",
            "Реализация модели 'благодарственного евро'",
            "Запуск программы международных контрибьюторов",
            "Создание документации для локализации под различные страны"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "13",
          "txt": "Международное Расширение и Локализация"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "13.1",
          "txt": "Текущие Ограничения"
        },
        {
          "type": "pgh",
          "txt": "ecKasse изначально разработана с учетом немецкого фискального законодательства, поскольку основатель проекта имеет глубокую экспертизу именно в этой области."
        }
      ]
    },
    {
      "pg": 18,
      "c": [
        {
          "type": "tbl",
          "cap": "Текущая экспертиза vs потребности международного расширения",
          "hdrs": [
            "Страна/Регион",
            "Известные требования",
            "Уровень экспертизы",
            "Приоритет"
          ],
          "r": [
            [
              "Германия",
              "TSE, GoBD, DSFinV-K, UStG",
              "Экспертный",
              "Реализовано"
            ],
            [
              "Франция",
              "Фискальные принтеры, timbrage, НДС",
              "Отсутствует",
              "Высокий"
            ],
            [
              "Италия",
              "RT compliance, фискальная память",
              "Отсутствует",
              "Высокий"
            ],
            [
              "Великобритания",
              "Making Tax Digital (MTD)",
              "Базовый",
              "Средний"
            ],
            [
              "Польша",
              "JPK отчетность, онлайн-кассы",
              "Отсутствует",
              "Средний"
            ],
            [
              "США",
              "Различия по штатам, sales tax",
              "Отсутствует",
              "Низкий"
            ],
            [
              "Испания",
              "TicketBAI, AEAT",
              "Отсутствует",
              "Средний"
            ],
            [
              "Нидерланды",
              "Сертификация ПО",
              "Отсутствует",
              "Низкий"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "13.2",
          "txt": "Стратегия Привлечения Международных Экспертов"
        },
        {
          "type": "pgh",
          "txt": "Для успешного международного расширения ecKasse критически необходимы локальные эксперты по фискальному законодательству и POS-требованиям."
        },
        {
          "type": "lst",
          "i": [
            "Целевая аудитория: владельцы ресторанов, бухгалтеры, POS-техники, юристы с практическим опытом",
            "Модель сотрудничества: знания в обмен на приоритетную реализацию для страны",
            "Документирование требований: создание подробных спецификаций для каждой юрисдикции",
            "Валидация интерпретации: проверка понимания местных регуляций",
            "Тестирование в реальных условиях: проверка соответствия в реальных заведениях",
            "Поддержка сертификации: помощь в получении необходимых разрешений и сертификатов"
          ],
          "ord": false
        },
        {
          "type": "cb",
          "cap": "Шаблон для документирования страновых требований",
          "c": "{\n  \"country\": \"France\",\n  \"fiscal_requirements\": {\n    \"mandatory_devices\": [\n      {\n        \"type\": \"fiscal_printer\",\n        \"certification_required\": true,\n        \"approved_models\": [\"Epson TM-T88V-I\", \"Star TSP143IIILAN-FR\"],\n        \"integration_method\": \"direct_serial_communication\"\n      }\n    ],\n    \"receipt_requirements\": {\n      \"mandatory_fields\": [\n        \"business_name\", \"siret_number\", \"vat_number\",\n        \"transaction_date_time\", \"sequential_number\",\n        \"payment_method\", \"vat_breakdown\"\n      ],\n      \"prohibited_operations\": [\n        \"receipt_cancellation_after_print\",\n        \"transaction_modification_after_validation\"\n      ]\n    },\n    \"reporting_obligations\": {\n      \"vat_declaration\": {\n        \"frequency\": \"monthly\",\n        \"format\": \"EDI_TVA\",\n        \"deadline\": \"15th_of_following_month\"\n      },\n      \"timbrage_verification\": {\n        \"frequency\": \"annual\",\n        \"authority\": \"DGFIP\",\n        \"required_documentation\": [\"audit_trail\", \"technical_specifications\"]\n      }\n    }\n  },\n  \"technical_integration\": {\n    \"apis_required\": [\"DGFiP_API\", \"fiscal_printer_drivers\"],\n    \"data_retention\": \"6_years\",\n    \"encryption_requirements\": \"AES_256\"\n  },\n  \"contributor_info\": {\n    \"expert_name\": \"Jean Dupont\",\n    \"expertise\": \"Restaurant owner + accountant, 15 years experience\",\n    \"validation_date\": \"2025-01-15\",\n    \"confidence_level\": \"high\"\n  }\n}"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "13.3",
          "txt": "Программа Мотивации Международных Контрибьюторов"
        },
        {
          "type": "lst",
          "i": [
            "Приоритетная реализация: страны с активными экспертами получают функции первыми",
            "Ранний доступ: бета-версии локализованных функций",
            "Признание: статус основателя региона, упоминание в документации",
            "Влияние на развитие: участие в принятии решений по приоритетам локализации",
            "Образовательные возможности: изучение международных POS-стандартов",
            "Сетевые эффекты: знакомство с экспертами из других стран"
          ],
          "ord": false
        }
      ]
    },
    {
      "pg": 19,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "14",
          "txt": "Конкурентные Преимущества и Позиционирование"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "14.1",
          "txt": "Уникальные Дифференциаторы ecKasse"
        },
        {
          "type": "lst",
          "i": [
            "Первая POS-система с нативной LLM-интеграцией для конфигурации (не просто чат-бот)",
            "Революционная геометрическая тесселяция UI (патентоспособная инновация)",
            "Универсальный формат OOP-POS-MDF предотвращает vendor lock-in",
            "Blockchain-якорение через Hedera для неизменяемых аудиторских следов",
            "Коллективная модель ценообразования создает лояльное сообщество",
            "Провокационный брендинг 'Betruger' создает более сильное доверие через парадокс",
            "Экологически ответственный выбор технологий (Hedera vs Bitcoin/Ethereum)"
          ],
          "ord": true
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "14.2",
          "txt": "Сравнение с Конкурентами"
        },
        {
          "type": "tbl",
          "cap": "Подробное сравнение ecKasse с конкурентами",
          "hdrs": [
            "Критерий",
            "Traditional POS",
            "Modern POS",
            "Enterprise POS",
            "ecKasse"
          ],
          "r": [
            [
              "Настройка",
              "Меню + обучение",
              "Простые шаблоны",
              "Консультанты",
              "Естественный язык"
            ],
            [
              "Кастомизация",
              "Ограниченная",
              "Базовая",
              "Полная, но дорогая",
              "Через LLM-диалог"
            ],
            [
              "Vendor Lock-in",
              "Критический",
              "Высокий",
              "Абсолютный",
              "Отсутствует (OOP-POS-MDF)"
            ],
            [
              "Время внедрения",
              "Недели",
              "Дни",
              "Месяцы",
              "Часы"
            ],
            [
              "Оффлайн работа",
              "Базовая",
              "Ограниченная",
              "Хорошая",
              "Полная + синхронизация"
            ],
            [
              "Фискальность",
              "Страна-зависима",
              "Ограниченная",
              "Полная",
              "Расширяемая через сообщество"
            ],
            [
              "Стоимость внедрения",
              "Средняя",
              "Низкая",
              "Очень высокая",
              "Минимальная"
            ],
            [
              "Поддержка",
              "Платная",
              "Базовая",
              "Премиум",
              "Community + Pro"
            ],
            [
              "Инновации UI",
              "Отсутствуют",
              "Минимальные",
              "Консервативные",
              "Революционные (тесселяция)"
            ],
            [
              "Аудиторская стойкость",
              "Базовая",
              "Средняя",
              "Высокая",
              "Максимальная (blockchain)"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "14.3",
          "txt": "Целевые Сегменты и Use Cases"
        },
        {
          "type": "tbl",
          "cap": "Сегменты рынка и соответствие ecKasse",
          "hdrs": [
            "Сегмент",
            "Текущие проблемы",
            "Решение ecKasse",
            "Конкурентное преимущество"
          ],
          "r": [
            [
              "Малые рестораны",
              "Дорогие консультанты, сложная настройка",
              "LLM-гид, бесплатная версия",
              "Доступность + простота"
            ],
            [
              "Этнические кухни",
              "Сложные названия блюд, культурные особенности",
              "LLM понимает контекст, многоязычность",
              "Культурная адаптивность"
            ],
            [
              "Кафе и бары",
              "Частые изменения меню, сезонность",
              "Мгновенные изменения через диалог",
              "Гибкость"
            ],
            [
              "Фуд-траки",
              "Мобильность, оффлайн работа",
              "Electron app, полная автономность",
              "Портативность"
            ],
            [
              "Pop-up заведения",
              "Быстрое развертывание",
              "Установка и настройка за часы",
              "Скорость запуска"
            ],
            [
              "Франчайзи",
              "Стандартизация + локальные особенности",
              "OOP-POS-MDF шаблоны",
              "Стандартизация без lock-in"
            ],
            [
              "Tech-savvy владельцы",
              "Желание контроля и понимания",
              "Open source, прозрачность",
              "Доверие через открытость"
            ],
            [
              "Экологически сознательные",
              "Ответственное потребление",
              "Hedera вместо Bitcoin",
              "Экологическая этика"
            ]
          ]
        }
      ]
    },
    {
      "pg": 20,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "15",
          "txt": "Часто Задаваемые Вопросы (FAQ)"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "15.1",
          "txt": "Для Разработчиков"
        },
        {
          "type": "tbl",
          "cap": "Технические вопросы разработчиков",
          "hdrs": [
            "Вопрос",
            "Ответ"
          ],
          "r": [
            [
              "Почему отказались от React?",
              "Vanilla JS + Lit обеспечивает лучшую производительность и меньший размер bundle'а для Electron-приложения"
            ],
            [
              "Как работает геометрическая тесселяция?",
              "CSS clip-path + SVG для создания шестиугольников/восьмиугольников, Web Components для инкапсуляции"
            ],
            [
              "Безопасность LLM интеграции?",
              "Все LLM операции проходят валидацию, прямого доступа к ОС нет, только к строго определенному API"
            ],
            [
              "Почему SQLite, а не PostgreSQL?",
              "Локальная автономность критична для POS, SQLite + репликация лучше централизованной БД"
            ],
            [
              "Как обеспечить offline-first?",
              "Service Workers + IndexedDB для кэширования, автосинхронизация при восстановлении связи"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "15.2",
          "txt": "Для Бизнес-Пользователей"
        },
        {
          "type": "tbl",
          "cap": "Бизнес-вопросы владельцев заведений",
          "hdrs": [
            "Вопрос",
            "Ответ"
          ],
          "r": [
            [
              "Действительно ли бесплатно?",
              "ПО open source, расходы только на обязательные внешние сервисы (TSE, облачные функции)"
            ],
            [
              "Можно ли мигрировать с текущей POS?",
              "Да, через OOP-POS-MDF конвертеры для большинства популярных систем"
            ],
            [
              "Что если не говорю по-немецки?",
              "LLM адаптируется к языку пользователя, ищем международных экспертов по фискализации"
            ],
            [
              "Как быть с аудитами налоговой?",
              "Hedera якорение + eIDAS метки создают неопровержимые доказательства, stronger than traditional TSE"
            ],
            [
              "Нужен ли интернет для работы?",
              "Нет, основные операции полностью оффлайн, интернет только для LLM-настроек и синхронизации"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "15.3",
          "txt": "Для Юристов и Налоговых Консультантов"
        },
        {
          "type": "tbl",
          "cap": "Правовые и фискальные вопросы",
          "hdrs": [
            "Вопрос",
            "Ответ"
          ],
          "r": [
            [
              "Соответствие немецкому KassenSichV?",
              "Полное соответствие через сертифицированные TSE-провайдеры (Fiskaly, A-Trust)"
            ],
            [
              "Что с GoBD требованиями?",
              "Автоматический DSFinV-K экспорт, процедурная документация, неизменяемые архивы"
            ],
            [
              "Правовая сила Hedera якорения?",
              "Техническое доказательство неизменности, дополняет (не заменяет) официальные TSE требования"
            ],
            [
              "Риски open source для бизнеса?",
              "EUPL лицензия commercial-friendly, аудируемый код повышает доверие налоговых органов"
            ],
            [
              "Ответственность при сбоях?",
              "Стандартные ограничения ответственности ПО, рекомендуется страхование киберрисков"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "16",
          "txt": "Стратегическое Видение и Будущее"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "16.1",
          "txt": "Долгосрочные Цели (3-5 лет)"
        },
        {
          "type": "lst",
          "i": [
            "Стать стандартом de facto для малых и средних ресторанов в Европе",
            "Достичь 10,000+ активных инсталляций с устойчивой экосистемой",
            "Создать пул из 50+ международных фискальных экспертов",
            "Развить OOP-POS-MDF в отраслевой стандарт для data portability",
            "Запустить сертификационную программу для разработчиков POS-интеграций",
            "Интеграция с IoT: умные холодильники, автоматические весы, AI-камеры для контроля порций"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "16.2",
          "txt": "Технологические Инновации (следующее поколение)"
        },
        {
          "type": "cb",
          "cap": "Концепция AI-Driven Restaurant Operations",
          "c": "// Будущая интеграция: ИИ-оптимизация ресторанных процессов\nclass SmartRestaurantAI {\n  async optimizeOperations() {\n    const predictions = await Promise.all([\n      this.predictDemand(),        // Прогноз популярности блюд\n      this.optimizeInventory(),    // Оптимизация закупок\n      this.suggestPricing(),       // Динамическое ценообразование\n      this.detectFraud(),          // Выявление мошенничества\n      this.personalizeOffers()     // Персонализированные предложения\n    ]);\n    \n    return {\n      demand_forecast: predictions[0],\n      inventory_recommendations: predictions[1],\n      pricing_suggestions: predictions[2],\n      fraud_alerts: predictions[3],\n      customer_personalization: predictions[4]\n    };\n  }\n  \n  // Интеграция с LLM для объяснения рекомендаций\n  async explainRecommendation(recommendation) {\n    return await llm.explain({\n      context: \"restaurant_optimization\",\n      data: recommendation,\n      style: \"business_friendly\",\n      include_action_items: true\n    });\n  }\n}\n\n// Концепция: Голосовое управление полным рестораном\nclass VoiceControlledRestaurant {\n  async processVoiceCommand(command) {\n    const intent = await llm.parseIntent(command);\n    \n    switch(intent.type) {\n      case 'inventory_check':\n        return await this.checkInventory(intent.item);\n      case 'sales_query':\n        return await this.getSalesData(intent.period);\n      case 'staff_schedule':\n        return await this.manageStaffing(intent.action);\n      case 'menu_update':\n        return await this.updateMenu(intent.changes);\n    }\n  }\n}"
        }
      ]
    },
    {
      "pg": 21,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "16.3",
          "txt": "Влияние на Индустрию"
        },
        {
          "type": "pgh",
          "txt": "ecKasse стремится инициировать фундаментальные изменения в индустрии POS-систем, устанавливая новые стандарты открытости, пользовательского опыта и технологической ответственности."
        },
        {
          "type": "lst",
          "i": [
            "Демократизация доступа к продвинутым POS-функциям для малого бизнеса",
            "Установление precedent'а для data portability в POS-индустрии",
            "Доказательство жизнеспособности community-driven моделей в enterprise софтваре",
            "Популяризация экологически ответственных blockchain-решений",
            "Создание новых паттернов UI/UX для professional-grade приложений",
            "Вдохновение других отраслей на adoption LLM-native интерфейсов"
          ],
          "ord": false
        },
        {
          "type": "hdr",
          "l": 2,
          "n": "17",
          "txt": "Заключение и Призыв к Действию"
        },
        {
          "type": "pgh",
          "txt": "ecKasse представляет собой не просто новую POS-систему, а парадигмальный сдвиг в подходе к созданию business-критичного программного обеспечения. Сочетая революционные технологии (LLM, геометрическая тесселяция, blockchain) с проверенными принципами (open source, community-driven развитие, фискальная ответственность), проект создает уникальную экосистему ценностей."
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "17.1",
          "txt": "Ключевые Достижения Концепции"
        },
        {
          "type": "lst",
          "i": [
            "Определена четкая техническая архитектура без React/Nodemon для оптимальной производительности",
            "Проработана революционная система геометрической тесселяции UI с научным обоснованием",
            "Создана стратегия поэтапного развития с конкретными критериями готовности",
            "Решена проблема vendor lock-in через универсальный формат OOP-POS-MDF",
            "Обеспечено соответствие немецкому фискальному законодательству с планами международного расширения",
            "Разработана устойчивая модель монетизации, сочетающая open source и коммерческую жизнеспособность",
            "Продумана стратегия привлечения международного сообщества разработчиков и экспертов"
          ],
          "ord": true
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "17.2",
          "txt": "Следующие Шаги"
        },
        {
          "type": "tbl",
          "cap": "Immediate Action Items для запуска проекта",
          "hdrs": [
            "Действие",
            "Ответственный",
            "Срок",
            "Критерий успеха"
          ],
          "r": [
            [
              "Создание MVP архитектуры",
              "Core team",
              "2 недели",
              "Компилируется и запускается"
            ],
            [
              "Настройка Electron + Lit",
              "Frontend dev",
              "1 неделя",
              "Hello World с геометрией"
            ],
            [
              "Базовая LLM интеграция",
              "Backend dev",
              "1 неделя",
              "Простой диалог работает"
            ],
            [
              "SQLite + миграции",
              "Backend dev",
              "3 дня",
              "Товары сохраняются в БД"
            ],
            [
              "Первый геометрический компонент",
              "UI/UX dev",
              "1 неделя",
              "Кликабельный шестиугольник"
            ],
            [
              "GitHub setup + CI/CD",
              "DevOps",
              "2 дня",
              "Auto-build на коммит"
            ],
            [
              "Техническая документация",
              "Tech writer",
              "1 неделя",
              "Contributing guide готов"
            ],
            [
              "Поиск международных экспертов",
              "Community manager",
              "ongoing",
              "5+ контактов из разных стран"
            ]
          ]
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "17.3",
          "txt": "Приглашение к Участию"
        },
        {
          "type": "pgh",
          "txt": "ecKasse - это не просто стартап или pet project. Это попытка изменить индустрию через коллективные усилия и открытые принципы. Мы приглашаем:"
        },
        {
          "type": "lst",
          "i": [
            "Разработчиков - помочь создать техническое чудо",
            "Дизайнеров - воплотить революционную геометрическую концепцию",
            "Владельцев ресторанов - предоставить реальную обратную связь",
            "Юристов и бухгалтеров - обеспечить фискальное соответствие в разных странах",
            "Переводчиков - сделать систему доступной по всему миру",
            "Энтузиастов open source - поддержать принципы открытого развития"
          ],
          "ord": false
        },
        {
          "type": "cb",
          "cap": "Контактная информация и способы участия",
          "c": "// Основные каналы коммуникации\ncontact_info = {\n  github: \"https://github.com/xelth-com/ecKasse\",\n  email: \"contribute@eckasse.com\",\n  discord: \"https://discord.gg/eckasse\",\n  website: \"https://eckasse.com\",\n  \n  // Специализированные каналы\n  fiscal_experts: \"fiscal@eckasse.com\",\n  developers: \"dev@eckasse.com\",\n  business_users: \"business@eckasse.com\",\n  translators: \"i18n@eckasse.com\"\n};\n\n// Способы начать участие\nways_to_contribute = {\n  immediate: [\n    \"Star репозиторий на GitHub\",\n    \"Присоединиться к Discord для обсуждений\",\n    \"Изучить техническую документацию\",\n    \"Попробовать alpha-версию (когда будет готова)\"\n  ],\n  \n  ongoing: [\n    \"Код-ревью и pull requests\",\n    \"Тестирование в реальных условиях\",\n    \"Документирование фискальных требований вашей страны\",\n    \"Распространение информации в professional сетях\"\n  ],\n  \n  leadership: [\n    \"Стать country lead для вашего региона\",\n    \"Модерация community каналов\",\n    \"Ментолинг новых контрибьюторов\",\n    \"Представление проекта на конференциях\"\n  ]\n};\n\nconsole.log(\"Готовы изменить будущее POS-систем вместе с нами?\");"
        },
        {
          "type": "pgh",
          "txt": "Революции начинаются с идей, но воплощаются руками сообщества. ecKasse - это наша общая возможность создать что-то действительно значимое для миллионов владельцев малого бизнеса по всему миру."
        },
        {
          "type": "pgh",
          "txt": "Время действовать. Время строить будущее. Время ecKasse."
        }
      ]
    },
    {
      "pg": 22,
      "c": [
        {
          "type": "hdr",
          "l": 2,
          "n": "18",
          "txt": "Технические Приложения"
        },
        {
          "type": "hdr",
          "l": 3,
          "n": "18.1",
          "txt": "Примеры Реализации Web Components для Тесселяции"
        },
        {
          "type": "cb",
          "cap": "Полная реализация адаптивной гексагональной кнопки",
          "c": "import { LitElement, html, css } from 'lit';\n\nclass AdaptiveHexButton extends LitElement {\n  static styles = css`\n    :host {\n      display: inline-block;\n      --hex-size: 100px;\n      --hex-color: #4CAF50;\n      --hex-text-color: white;\n      --hex-hover-scale: 1.1;\n      --hex-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    \n    .hex-container {\n      width: var(--hex-size);\n      height: calc(var(--hex-size) * 0.866); /* √3/2 для правильного шестиугольника */\n      position: relative;\n      cursor: pointer;\n      transition: var(--hex-transition);\n    }\n    \n    .hex-shape {\n      width: 100%;\n      height: 100%;\n      clip-path: polygon(\n        25% 0%, \n        75% 0%, \n        100% 50%, \n        75% 100%, \n        25% 100%, \n        0% 50%\n      );\n      background: var(--hex-color);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      position: relative;\n      overflow: hidden;\n    }\n    \n    .hex-content {\n      color: var(--hex-text-color);\n      font-weight: 600;\n      text-align: center;\n      font-size: calc(var(--hex-size) * 0.12);\n      line-height: 1.2;\n      padding: 8px;\n      z-index: 2;\n      position: relative;\n    }\n    \n    .hex-ripple {\n      position: absolute;\n      border-radius: 50%;\n      background: rgba(255, 255, 255, 0.3);\n      transform: scale(0);\n      animation: ripple 0.6s linear;\n      pointer-events: none;\n    }\n    \n    .hex-container:hover {\n      transform: scale(var(--hex-hover-scale));\n    }\n    \n    .hex-container:active {\n      transform: scale(0.95);\n    }\n    \n    .hex-badge {\n      position: absolute;\n      top: -8px;\n      right: -8px;\n      background: #f44336;\n      color: white;\n      border-radius: 50%;\n      width: 20px;\n      height: 20px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      font-size: 10px;\n      font-weight: bold;\n      z-index: 3;\n    }\n    \n    @keyframes ripple {\n      to {\n        transform: scale(4);\n        opacity: 0;\n      }\n    }\n    \n    @keyframes pulse {\n      0%, 100% { transform: scale(1); }\n      50% { transform: scale(1.05); }\n    }\n    \n    .notification-pulse {\n      animation: pulse 2s infinite;\n    }\n    \n    /* Адаптивность для разных размеров экрана */\n    @media (max-width: 768px) {\n      :host {\n        --hex-size: 80px;\n      }\n    }\n    \n    @media (max-width: 480px) {\n      :host {\n        --hex-size: 60px;\n      }\n    }\n  `;\n  \n  static properties = {\n    label: { type: String },\n    category: { type: String },\n    color: { type: String },\n    badge: { type: Number },\n    disabled: { type: Boolean },\n    notification: { type: Boolean },\n    size: { type: String }\n  };\n  \n  constructor() {\n    super();\n    this.label = '';\n    this.category = '';\n    this.color = '#4CAF50';\n    this.badge = 0;\n    this.disabled = false;\n    this.notification = false;\n    this.size = 'medium';\n  }\n  \n  updated(changedProperties) {\n    if (changedProperties.has('color')) {\n      this.style.setProperty('--hex-color', this.color);\n    }\n    if (changedProperties.has('size')) {\n      const sizes = {\n        small: '60px',\n        medium: '100px',\n        large: '140px'\n      };\n      this.style.setProperty('--hex-size', sizes[this.size] || sizes.medium);\n    }\n  }\n  \n  _handleClick(e) {\n    if (this.disabled) return;\n    \n    // Создание ripple эффекта\n    this._createRipple(e);\n    \n    // Отправка события\n    this.dispatchEvent(new CustomEvent('hex-click', {\n      detail: {\n        category: this.category,\n        label: this.label,\n        timestamp: Date.now()\n      },\n      bubbles: true\n    }));\n  }\n  \n  _createRipple(e) {\n    const rect = this.shadowRoot.querySelector('.hex-shape').getBoundingClientRect();\n    const size = Math.max(rect.width, rect.height);\n    const x = e.clientX - rect.left - size / 2;\n    const y = e.clientY - rect.top - size / 2;\n    \n    const ripple = document.createElement('div');\n    ripple.className = 'hex-ripple';\n    ripple.style.width = ripple.style.height = size + 'px';\n    ripple.style.left = x + 'px';\n    ripple.style.top = y + 'px';\n    \n    const hexShape = this.shadowRoot.querySelector('.hex-shape');\n    hexShape.appendChild(ripple);\n    \n    setTimeout(() => ripple.remove(), 600);\n  }\n  \n  render() {\n    return html`\n      <div class=\"hex-container ${this.notification ? 'notification-pulse' : ''}\"\n           @click=\"${this._handleClick}\"\n           ?disabled=\"${this.disabled}\">\n        <div class=\"hex-shape\">\n          <div class=\"hex-content\">${this.label}</div>\n        </div>\n        ${this.badge > 0 ? html`<div class=\"hex-badge\">${this.badge}</div>` : ''}\n      </div>\n    `;\n  }\n}\n\ncustomElements.define('adaptive-hex-button', AdaptiveHexButton);"
        }
      ]
    },
    {
      "pg": 23,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "18.2",
          "txt": "Архитектура Системы Связи с Детальной Реализацией"
        },
        {
          "type": "cb",
          "cap": "Полная реализация многоуровневой системы связи",
          "c": "class MultiLevelCommunicationSystem {\n  constructor(config = {}) {\n    this.config = {\n      wsUrl: config.wsUrl || 'ws://localhost:3030',\n      httpUrl: config.httpUrl || 'http://localhost:3030',\n      cloudProxyUrl: config.cloudProxyUrl || 'https://eck1.com/proxy',\n      timeout: config.timeout || 5000,\n      retryAttempts: config.retryAttempts || 3,\n      ...config\n    };\n    \n    this.currentLevel = 1;\n    this.connectionState = 'disconnected';\n    this.messageQueue = [];\n    this.pendingOperations = new Map();\n    this.reconnectTimer = null;\n    \n    this.initializeConnections();\n  }\n  \n  async initializeConnections() {\n    // Попытка установки соединения начиная с уровня 1\n    await this.connectLevel1();\n  }\n  \n  // Уровень 1: WebSocket соединение\n  async connectLevel1() {\n    try {\n      this.ws = new WebSocket(this.config.wsUrl);\n      \n      this.ws.onopen = () => {\n        console.log('🟢 Level 1 (WebSocket) connected');\n        this.currentLevel = 1;\n        this.connectionState = 'connected';\n        this.flushMessageQueue();\n        this.emit('connection-changed', { level: 1, state: 'connected' });\n      };\n      \n      this.ws.onmessage = (event) => {\n        this.handleMessage(JSON.parse(event.data), 'websocket');\n      };\n      \n      this.ws.onclose = () => {\n        console.log('🔴 Level 1 (WebSocket) disconnected');\n        this.handleDisconnection();\n      };\n      \n      this.ws.onerror = (error) => {\n        console.error('❌ WebSocket error:', error);\n        this.fallbackToLevel2();\n      };\n      \n    } catch (error) {\n      console.error('❌ Failed to initialize WebSocket:', error);\n      this.fallbackToLevel2();\n    }\n  }\n  \n  // Уровень 2: HTTP API\n  async fallbackToLevel2() {\n    console.log('⬇️ Falling back to Level 2 (HTTP API)');\n    this.currentLevel = 2;\n    this.connectionState = 'connected';\n    this.emit('connection-changed', { level: 2, state: 'connected' });\n    \n    // Попытка переподключения WebSocket через 30 секунд\n    this.scheduleReconnect();\n  }\n  \n  // Уровень 3: Cloud Proxy\n  async fallbackToLevel3() {\n    console.log('⬇️ Falling back to Level 3 (Cloud Proxy)');\n    this.currentLevel = 3;\n    this.connectionState = 'connected';\n    this.emit('connection-changed', { level: 3, state: 'connected' });\n  }\n  \n  async sendOperation(operation, data) {\n    const operationId = this.generateOperationId();\n    const message = {\n      operationId,\n      operation,\n      data,\n      timestamp: Date.now(),\n      clientId: this.getClientId()\n    };\n    \n    return new Promise((resolve, reject) => {\n      // Сохраняем операцию для отслеживания\n      this.pendingOperations.set(operationId, {\n        resolve,\n        reject,\n        message,\n        attempts: 0,\n        maxAttempts: this.config.retryAttempts\n      });\n      \n      this.attemptSend(operationId);\n      \n      // Таймаут операции\n      setTimeout(() => {\n        if (this.pendingOperations.has(operationId)) {\n          const pending = this.pendingOperations.get(operationId);\n          this.pendingOperations.delete(operationId);\n          pending.reject(new Error(`Operation timeout: ${operation}`));\n        }\n      }, this.config.timeout);\n    });\n  }\n  \n  async attemptSend(operationId) {\n    const pending = this.pendingOperations.get(operationId);\n    if (!pending) return;\n    \n    const { message } = pending;\n    \n    try {\n      switch (this.currentLevel) {\n        case 1:\n          await this.sendViaWebSocket(message);\n          break;\n        case 2:\n          await this.sendViaHTTP(message);\n          break;\n        case 3:\n          await this.sendViaCloudProxy(message);\n          break;\n        default:\n          throw new Error('No available communication level');\n      }\n    } catch (error) {\n      console.warn(`❌ Send failed on level ${this.currentLevel}:`, error);\n      await this.handleSendError(operationId, error);\n    }\n  }\n  \n  async sendViaWebSocket(message) {\n    if (this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket not connected');\n    }\n    \n    this.ws.send(JSON.stringify(message));\n  }\n  \n  async sendViaHTTP(message) {\n    const response = await fetch(`${this.config.httpUrl}/api/operation`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Client-Level': '2'\n      },\n      body: JSON.stringify(message)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    const result = await response.json();\n    this.handleMessage(result, 'http');\n  }\n  \n  async sendViaCloudProxy(message) {\n    const response = await fetch(`${this.config.cloudProxyUrl}/operation`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Client-Level': '3',\n        'Authorization': `Bearer ${this.getCloudToken()}`\n      },\n      body: JSON.stringify(message)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Cloud Proxy ${response.status}: ${response.statusText}`);\n    }\n    \n    const result = await response.json();\n    this.handleMessage(result, 'cloud_proxy');\n  }\n  \n  handleMessage(message, channel) {\n    const { operationId, status, data, error } = message;\n    \n    if (this.pendingOperations.has(operationId)) {\n      const pending = this.pendingOperations.get(operationId);\n      this.pendingOperations.delete(operationId);\n      \n      if (status === 'success') {\n        pending.resolve({ data, channel, status });\n      } else if (status === 'already_processed') {\n        pending.resolve({ data, channel, status: 'already_processed' });\n      } else {\n        pending.reject(new Error(error || 'Operation failed'));\n      }\n    }\n    \n    // Логирование для аналитики\n    this.logOperation(operationId, channel, status);\n  }\n  \n  async handleSendError(operationId, error) {\n    const pending = this.pendingOperations.get(operationId);\n    if (!pending) return;\n    \n    pending.attempts++;\n    \n    if (pending.attempts < pending.maxAttempts) {\n      // Retry на том же уровне\n      setTimeout(() => this.attemptSend(operationId), 1000 * pending.attempts);\n    } else {\n      // Fallback на следующий уровень\n      if (this.currentLevel < 3) {\n        await this.fallbackToNextLevel();\n        pending.attempts = 0; // Сброс счетчика для нового уровня\n        this.attemptSend(operationId);\n      } else {\n        // Все уровни исчерпаны\n        this.pendingOperations.delete(operationId);\n        pending.reject(new Error('All communication levels failed'));\n      }\n    }\n  }\n  \n  async fallbackToNextLevel() {\n    switch (this.currentLevel) {\n      case 1:\n        await this.fallbackToLevel2();\n        break;\n      case 2:\n        await this.fallbackToLevel3();\n        break;\n      default:\n        throw new Error('No more fallback levels available');\n    }\n  }\n  \n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    \n    this.reconnectTimer = setTimeout(async () => {\n      if (this.currentLevel > 1) {\n        console.log('🔄 Attempting to reconnect to Level 1...');\n        await this.connectLevel1();\n      }\n    }, 30000); // 30 секунд\n  }\n  \n  generateOperationId() {\n    return crypto.randomUUID();\n  }\n  \n  getClientId() {\n    // Получение уникального ID клиента (может быть из localStorage)\n    return localStorage.getItem('client-id') || this.generateOperationId();\n  }\n  \n  getCloudToken() {\n    // Получение токена для облачного доступа\n    return localStorage.getItem('cloud-token');\n  }\n  \n  logOperation(operationId, channel, status) {\n    console.log(`📊 Operation ${operationId} via ${channel}: ${status}`);\n    // Отправка метрик для аналитики\n  }\n  \n  emit(event, data) {\n    // Простая система событий\n    const eventHandlers = this.eventHandlers || {};\n    if (eventHandlers[event]) {\n      eventHandlers[event].forEach(handler => handler(data));\n    }\n  }\n  \n  on(event, handler) {\n    this.eventHandlers = this.eventHandlers || {};\n    this.eventHandlers[event] = this.eventHandlers[event] || [];\n    this.eventHandlers[event].push(handler);\n  }\n}\n\n// Использование:\nconst comm = new MultiLevelCommunicationSystem();\n\ncomm.on('connection-changed', ({ level, state }) => {\n  console.log(`Connection level changed to ${level}, state: ${state}`);\n});\n\n// Примеры операций\nasync function testOperations() {\n  try {\n    const result = await comm.sendOperation('createProduct', {\n      name: 'Латте',\n      price: 3.50,\n      category: 'coffee'\n    });\n    console.log('Product created:', result);\n  } catch (error) {\n    console.error('Failed to create product:', error);\n  }\n}"
        }
      ]
    },
    {
      "pg": 24,
      "c": [
        {
          "type": "hdr",
          "l": 3,
          "n": "18.3",
          "txt": "Пример Полной LLM Интеграции с Function Calling"
        },
        {
          "type": "cb",
          "cap": "Реализация LLM агента с инструментами для ecKasse",
          "c": "import { GoogleGenerativeAI } from '@google/generative-ai';\n\nclass EcKasseLLMAgent {\n  constructor(apiKey) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.model = this.genAI.getGenerativeModel({\n      model: 'gemini-2.0-flash',\n      tools: [{ functionDeclarations: this.getAllFunctionDeclarations() }]\n    });\n    \n    this.chatSession = null;\n    this.systemPrompt = this.createSystemPrompt();\n  }\n  \n  createSystemPrompt() {\n    return `Вы - интеллектуальный помощник кассовой системы ecKasse.\n\nВаша роль:\n- Помогать владельцам ресторанов настраивать и управлять их POS-системой\n- Объяснять функции простым языком\n- Предлагать оптимизации на основе данных\n- Обеспечивать соответствие фискальным требованиям\n\nВозможности:\n- Создание и редактирование товаров, категорий\n- Настройка модификаторов и акций\n- Анализ продаж и составление отчетов\n- Диагностика проблем системы\n- Поиск актуальной информации о налогах\n\nВсегда:\n- Спрашивайте уточнения при неясных запросах\n- Предлагайте конкретные действия\n- Объясняйте последствия изменений\n- Используйте дружелюбный, профессиональный тон`;\n  }\n  \n  getAllFunctionDeclarations() {\n    return [\n      // Управление товарами\n      {\n        name: 'createProduct',\n        description: 'Создать новый товар в системе',\n        parameters: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', description: 'Название товара' },\n            price: { type: 'number', description: 'Цена товара' },\n            category: { type: 'string', description: 'Категория товара' },\n            taxRate: { type: 'number', description: 'Ставка НДС в процентах' },\n            description: { type: 'string', description: 'Описание товара' }\n          },\n          required: ['name', 'price']\n        }\n      },\n      \n      {\n        name: 'updateProduct',\n        description: 'Обновить существующий товар',\n        parameters: {\n          type: 'object',\n          properties: {\n            id: { type: 'number', description: 'ID товара' },\n            updates: {\n              type: 'object',\n              properties: {\n                name: { type: 'string' },\n                price: { type: 'number' },\n                category: { type: 'string' },\n                taxRate: { type: 'number' }\n              }\n            }\n          },\n          required: ['id', 'updates']\n        }\n      },\n      \n      {\n        name: 'searchProducts',\n        description: 'Найти товары по названию или категории',\n        parameters: {\n          type: 'object',\n          properties: {\n            query: { type: 'string', description: 'Поисковый запрос' },\n            category: { type: 'string', description: 'Фильтр по категории' },\n            limit: { type: 'number', description: 'Максимальное количество результатов' }\n          },\n          required: ['query']\n        }\n      },\n      \n      // Управление категориями\n      {\n        name: 'createCategory',\n        description: 'Создать новую категорию товаров',\n        parameters: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', description: 'Название категории' },\n            type: { type: 'string', enum: ['food', 'drink', 'other'], description: 'Тип категории' },\n            taxRate: { type: 'number', description: 'Ставка НДС по умолчанию для категории' },\n            color: { type: 'string', description: 'Цвет для UI (hex)' }\n          },\n          required: ['name', 'type']\n        }\n      },\n      \n      // Модификаторы и акции\n      {\n        name: 'createModifier',\n        description: 'Создать модификатор цены (скидка, наценка, Happy Hour)',\n        parameters: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', description: 'Название модификатора' },\n            type: { type: 'string', enum: ['discount', 'surcharge', 'happy_hour'], description: 'Тип модификатора' },\n            value: { type: 'number', description: 'Значение (процент или сумма)' },\n            conditions: {\n              type: 'object',\n              properties: {\n                timeStart: { type: 'string', description: 'Время начала (HH:MM)' },\n                timeEnd: { type: 'string', description: 'Время окончания (HH:MM)' },\n                daysOfWeek: { type: 'array', items: { type: 'string' }, description: 'Дни недели' },\n                categories: { type: 'array', items: { type: 'string' }, description: 'Применимые категории' }\n              }\n            }\n          },\n          required: ['name', 'type', 'value']\n        }\n      },\n      \n      // Отчеты и аналитика\n      {\n        name: 'getSalesReport',\n        description: 'Получить отчет о продажах',\n        parameters: {\n          type: 'object',\n          properties: {\n            period: { type: 'string', enum: ['today', 'yesterday', 'week', 'month'], description: 'Период отчета' },\n            groupBy: { type: 'string', enum: ['category', 'product', 'hour', 'day'], description: 'Группировка данных' }\n          },\n          required: ['period']\n        }\n      },\n      \n      {\n        name: 'getTopSellingItems',\n        description: 'Получить самые популярные товары',\n        parameters: {\n          type: 'object',\n          properties: {\n            period: { type: 'string', enum: ['today', 'week', 'month'], description: 'Период анализа' },\n            limit: { type: 'number', description: 'Количество товаров' }\n          },\n          required: ['period']\n        }\n      },\n      \n      {\n        name: 'getSlowMovingItems',\n        description: 'Найти медленно продающиеся товары',\n        parameters: {\n          type: 'object',\n          properties: {\n            threshold: { type: 'number', description: 'Минимальное количество продаж' },\n            period: { type: 'string', enum: ['week', 'month'], description: 'Период анализа' }\n          },\n          required: ['threshold', 'period']\n        }\n      },\n      \n      // Поиск информации о налогах\n      {\n        name: 'web_search',\n        description: 'Поиск актуальной информации в интернете (например, о налоговых ставках)',\n        parameters: {\n          type: 'object',\n          properties: {\n            query: { type: 'string', description: 'Поисковый запрос' }\n          },\n          required: ['query']\n        }\n      },\n      \n      // Системная диагностика\n      {\n        name: 'checkSystemHealth',\n        description: 'Проверить состояние системы и выявить проблемы',\n        parameters: {\n          type: 'object',\n          properties: {\n            includePerformance: { type: 'boolean', description: 'Включить проверку производительности' },\n            includeTSE: { type: 'boolean', description: 'Проверить состояние TSE' }\n          }\n        }\n      }\n    ];\n  }\n  \n  async startChat() {\n    this.chatSession = this.model.startChat({\n      history: [],\n      systemInstruction: this.systemPrompt\n    });\n  }\n  \n  async processMessage(userMessage) {\n    if (!this.chatSession) {\n      await this.startChat();\n    }\n    \n    try {\n      const result = await this.chatSession.sendMessage(userMessage);\n      const response = result.response;\n      \n      // Проверяем, хочет ли модель вызвать функции\n      const functionCalls = response.functionCalls();\n      \n      if (functionCalls && functionCalls.length > 0) {\n        // Выполняем функции и отправляем результаты обратно\n        const functionResults = await Promise.all(\n          functionCalls.map(async (call) => {\n            const result = await this.executeFunctionCall(call);\n            return {\n              functionResponse: {\n                name: call.name,\n                response: result\n              }\n            };\n          })\n        );\n        \n        // Отправляем результаты функций модели для формирования финального ответа\n        const finalResult = await this.chatSession.sendMessage(functionResults);\n        return {\n          text: finalResult.response.text(),\n          functionsCalled: functionCalls.map(call => call.name)\n        };\n      } else {\n        // Простой текстовый ответ без вызова функций\n        return {\n          text: response.text(),\n          functionsCalled: []\n        };\n      }\n    } catch (error) {\n      console.error('LLM processing error:', error);\n      return {\n        text: 'Извините, произошла ошибка при обработке вашего запроса. Попробуйте еще раз.',\n        error: error.message\n      };\n    }\n  }\n  \n  async executeFunctionCall(call) {\n    const { name, args } = call;\n    \n    try {\n      switch (name) {\n        case 'createProduct':\n          return await this.createProduct(args);\n        case 'updateProduct':\n          return await this.updateProduct(args);\n        case 'searchProducts':\n          return await this.searchProducts(args);\n        case 'createCategory':\n          return await this.createCategory(args);\n        case 'createModifier':\n          return await this.createModifier(args);\n        case 'getSalesReport':\n          return await this.getSalesReport(args);\n        case 'getTopSellingItems':\n          return await this.getTopSellingItems(args);\n        case 'getSlowMovingItems':\n          return await this.getSlowMovingItems(args);\n        case 'web_search':\n          return await this.webSearch(args);\n        case 'checkSystemHealth':\n          return await this.checkSystemHealth(args);\n        default:\n          throw new Error(`Unknown function: ${name}`);\n      }\n    } catch (error) {\n      return {\n        error: `Ошибка выполнения ${name}: ${error.message}`\n      };\n    }\n  }\n  \n  // Реализация функций (примеры)\n  async createProduct(args) {\n    // Здесь будет вызов к API ecKasse\n    const product = {\n      id: Date.now(), // Временная реализация\n      ...args,\n      created_at: new Date().toISOString()\n    };\n    \n    // Имитация сохранения в БД\n    console.log('Creating product:', product);\n    \n    return {\n      success: true,\n      product,\n      message: `Товар \"${args.name}\" успешно создан с ID ${product.id}`\n    };\n  }\n  \n  async getSalesReport(args) {\n    // Имитация отчета о продажах\n    const mockData = {\n      today: { revenue: 1247.50, transactions: 78, avgCheck: 15.99 },\n      week: { revenue: 8732.10, transactions: 542, avgCheck: 16.11 },\n      month: { revenue: 35247.80, transactions: 2156, avgCheck: 16.35 }\n    };\n    \n    return {\n      success: true,\n      period: args.period,\n      data: mockData[args.period] || mockData.today,\n      generatedAt: new Date().toISOString()\n    };\n  }\n  \n  async webSearch(args) {\n    // Имитация веб-поиска (в реальности будет интеграция с поисковыми API)\n    const mockResults = {\n      query: args.query,\n      results: [\n        {\n          title: \"Mehrwertsteuersätze in Deutschland 2025\",\n          url: \"https://www.bundesfinanzministerium.de/...\",\n          snippet: \"Standardsatz 19%, ermäßigter Satz 7% für Lebensmittel...\"\n        }\n      ]\n    };\n    \n    return {\n      success: true,\n      searchResults: mockResults\n    };\n  }\n  \n  // ... Другие функции\n}\n\n// Использование:\nconst llmAgent = new EcKasseLLMAgent(process.env.GEMINI_API_KEY);\n\n// Пример обработки сообщения пользователя\nasync function handleUserMessage(message) {\n  const response = await llmAgent.processMessage(message);\n  console.log('LLM Response:', response.text);\n  if (response.functionsCalled.length > 0) {\n    console.log('Functions called:', response.functionsCalled);\n  }\n  return response;\n}\n\n// Тестовые сценарии\n// handleUserMessage(\"Добавь новый товар Капучино за 3.50 евро\");\n// handleUserMessage(\"Покажи отчет о продажах за сегодня\");\n// handleUserMessage(\"Какая ставка НДС для кофе на вынос в Германии?\");"
        }
      ]
    }
  ]
}

--- File: /docs_forLMM/for_Gemini_LLM.md ---

### **Gemini's Core Operating Instructions for ecKasse Project Management**

**1. Primary Directive: Role & Communication Protocol**

*   **Role Definition:** I am Gemini, the Project Manager and UX Architect for the ecKasse POS system. Claude Code is my dedicated technical implementation agent. My role is to translate user requests and visual concepts into precise, actionable technical tasks for Claude.
*   **Language Protocol (Strict):**
    *   **User Interaction:** I will ALWAYS communicate with the user **in Russian**.
    *   **Claude Delegation:** I will ALWAYS formulate tasks for Claude Code **in English**. This prevents technical mistranslation.

**2. Core Workflow: The "Plan & Confirm" Cycle**

My workflow is a strict, iterative loop that prioritizes user confirmation:

1.  **Analyze User Request:** I will analyze the user's goal, including any provided images, logs, or context.
2.  **Formulate a Plan:** I will synthesize this information into a clear technical plan.
3.  **PRESENT THE PLAN FOR CONFIRMATION (NEW & CRITICAL):** I will present the proposed technical task to the user **in Russian**, explaining *what* I'm about to ask Claude to do and *why*. I will explicitly ask for the user's confirmation to proceed. **I WILL NOT DELEGATE TO CLAUDE UNTIL I RECEIVE USER APPROVAL.**
4.  **Delegate to Claude:** Once the user approves the plan, I will formulate the final, detailed technical task in English and assign it to Claude Code.
5.  **Review & Report:** I will analyze Claude's completed work and report the results and their implications back to the user in Russian.
6.  **Iterate:** Based on user feedback, I will begin the cycle again.

**3. Task Formulation Protocol for Claude Code**

Every task I formulate for Claude Code MUST include:

1.  **Objective:** A concise statement of the end goal.
2.  **File Locations & Technical Context:** Precise file paths and relevant context (e.g., error logs, existing code snippets).
3.  **Visual Context & UI/UX Requirements:**
    *   If the user provides an image, I will translate its visual properties into specific CSS requirements (e.g., "The user's image shows interlocking buttons, which requires a negative `margin-top` of `-0.8rem`").
    *   UI tasks must adhere to our established design philosophy (Dark Mode First, `rem` units, tessellation).
4.  **Implementation Guidance:**
    *   **CSS:** Specify properties, class names, and target `rem` values.
    *   **Backend:** Specify WebSocket command names, service function names, and database fields.
    *   **Svelte:** Mention specific Svelte APIs (`createEventDispatcher`, `bind:clientWidth`) when relevant.
5.  **Acceptance Criteria:** A clear, bulleted list defining a "successful" implementation.

**4. ecKasse Project Knowledge Base (Internal Reference)**

*   **Tech Stack:** Svelte 5 (Frontend), Node.js/Express (Backend), SQLite/Knex.js (DB), Electron (Desktop).
*   **UI Philosophy:** Dark Mode First, `rem`-based responsive scaling, hexagonal tessellation.
*   **API Protocol:** WebSocket primary. Request: `{ "command": "commandName" }`. Response: `{ "command": "commandNameResponse", ... }`.



--- File: /docs_forLMM/icon_generation_guide.md ---

# Руководство по генерации иконок для ecKasse UI

## 1. Цель
Данное руководство описывает подход к созданию минималистичных 2D векторных иконок для пользовательского интерфейса ecKasse. Основная цель — обеспечить единообразный стиль, который хорошо сочетается с темной темой UI, интуитивно понятен и эффективен при малых размерах (128x96 пикселей).

## 2. Общие принципы стиля
* **Формат:** 2D векторные иконки (хотя текущие генераторы могут возвращать растровые, промты ориентированы на векторную эстетику).
* **Перспектива:** Слегка сверху-вниз (top-down angle) с легким 3D-эффектом (slight 3D effect / viewed from a 45-degree azimuth, one corner facing us) для объектов, но без чрезмерной детализации.
* **Детализация:** Минималистичная, без мелких деталей, сложных текстур, отражений, бликов. Линии должны быть толстыми и чистыми.
* **Цветовая палитра:** Приглушенные, соответствующие объекту тона, адаптированные для темной темы UI. Избегать ярких и насыщенных цветов.
* **Нежелательные элементы:** Категорически исключать любые посторонние объекты (руки, устройства чтения, фон, столовые приборы, лишние ингредиенты/гарниры, пузырьки, чрезмерные тени).

## 3. Примеры промтов для различных иконок

### 3.1. Кнопки оплаты и системные иконки

#### **Иконка "Стол" (Table)**
* **Описание:** Простой 3D-стол, вид под углом 45 градусов, без распорок, под цвет дерева.
* **Промт:** "A 3D icon of a table, viewed from a 45-degree azimuth, with one corner facing us. The design should be very simple, without fine details. The lines should be thick. The icon will be very small, 128x96 pixels. Color it in a dark wood tone without crossbars on three legs."

#### **Иконка "Наличные" (Cash)**
* **Описание:** Стопка банкнот, вид под углом 45 градусов, без лишних деталей.
* **Промт:** "A 3D icon of a stack of banknotes, viewed from a 45-degree azimuth, with one corner facing us. The design should be very simple, without fine details. The lines should be thick. The icon will be very small, 128x96 pixels. Color it in a light green reminiscent of currency." (Цвет может быть скорректирован на более приглушенный для темной темы после генерации).

#### **Иконка "Карта" (Card)**
* **Описание:** Простое 2D-изображение кредитной карты, без устройств чтения, в серо-синих тонах.
* **Промт:** "A minimalist 2D vector icon of a credit card. No perspective, flat design. Emphasize clean lines and geometric shapes. Avoid any additional elements like card readers, hands, or transaction symbols. Color palette: shades of grey and muted blue for the chip/stripe. Icon size is 128x96 pixels."

### 3.2. Иконки категорий блюд

#### **Иконка "Горячий напиток" (Hot Beverage - Coffee)**
* **Описание:** Кружка горячего напитка с паром, простые формы, теплые приглушенные тона.
* **Промт:** "A minimalist 2D vector icon of a steaming hot beverage in a mug. The mug is a simple, rounded cylinder, viewed from a slight top-down angle, showing the rim and a hint of the interior. Two or three subtle, curved lines ascend from the rim to indicate steam. The color palette should consist of warm, muted tones: dark brown for the mug, a lighter beige/cream for the interior, and very light, almost transparent white/grey for the steam. No handles, spoons, or complex textures. Flat design, clean lines, suitable for a dark UI. Icon size is 128x96 pixels."

#### **Иконка "Безалкогольный напиток" (Non-Alcoholic Drink)**
* **Описание:** Освежающий безалкогольный напиток в стакане с трубочкой, прохладные приглушенные тона.
* **Промт:** "A minimalist 2D vector icon of a refreshing non-alcoholic beverage in a glass. The glass is a simple, slightly tapered cylinder, viewed from a slight top-down angle. A single, straight straw extends from the liquid. The color palette should consist of cool, muted tones: a translucent light blue/green for the drink, a subtle grey outline for the glass, and a very light grey for the straw. No ice cubes, fruit slices, bubbles, or complex textures. Flat design, clean lines, suitable for a dark UI. Icon size is 128x96 pixels."

#### **Иконка "Алкогольный напиток" (Alcoholic Drink)**
* **Описание:** Алкогольный напиток в бокале на ножке, глубокие приглушенные тона.
* **Промт:** "A minimalist 2D vector icon of an alcoholic beverage in a stemmed glass. The glass has a simple, elegant bowl and a thin stem with a small base, viewed from a slight top-down angle. The liquid inside is a solid, rich color. The color palette should consist of deep, muted tones: a dark, translucent red/amber for the drink, a subtle dark grey outline for the glass, and a very light grey for the stem and base. No reflections, bubbles, garnishes (like olives or lemon slices), or complex textures. Flat design, clean lines, suitable for a dark UI. Icon size is 128x96 pixels."

#### **Иконка "Суп" (Soup)**
* **Описание:** Миска супа с ложкой и паром, теплые, землистые приглушенные тона.
* **Промт:** "A minimalist 2D vector icon of a bowl of soup. The bowl is a simple, wide, and shallow ceramic bowl, viewed from a slight top-down angle. A single, simple spoon rests inside the bowl, partially submerged in the liquid. Two or three subtle, curved lines ascend from the liquid to indicate steam. The color palette should consist of warm, earthy, muted tones: a deep, muted orange/red for the soup, a light beige/off-white for the bowl, and a subtle dark grey for the spoon. No complex textures, garnishes (like herbs or croutons), or reflections. Flat design, clean lines, suitable for a dark UI. Icon size is 128x96 pixels."

#### **Иконка "Второе блюдо" (Main Course)**
* **Описание:** Основное блюдо на тарелке (кусок белка + гарнир), теплые, приглушенные землистые тона.
* **Промт:** "A minimalist 2D vector icon of a main course on a plate. The plate is a simple, round, flat ceramic plate, viewed from a slight top-down angle. On the plate, there is a distinct, rounded shape representing a piece of protein (like meat or fish) and a smaller, abstract shape next to it for a side dish (like a vegetable or starch). The color palette should consist of warm, muted, and slightly desaturated earthy tones: a dark, rich brown/red for the protein, a muted green for the side, and a light grey/off-white for the plate. No complex textures, intricate details, cutlery, or reflections. Flat design, clean lines, suitable for a dark UI. Icon size is 128x96 pixels."

--- File: /orders.bat ---

REM Убедитесь, что вы в C:\Users\xelth\eckasse

REM --- Основная структура ---
IF NOT EXIST "electron" md electron
IF NOT EXIST "public" md public
IF NOT EXIST "public\assets" md public\assets
IF NOT EXIST "src" md src

REM --- Структура для Frontend (React) ---
IF NOT EXIST "src\renderer" md src\renderer
IF NOT EXIST "src\renderer\components" md src\renderer\components
IF NOT EXIST "src\renderer\features" md src\renderer\features
IF NOT EXIST "src\renderer\contexts" md src\renderer\contexts
IF NOT EXIST "src\renderer\hooks" md src\renderer\hooks
IF NOT EXIST "src\renderer\services" md src\renderer\services
IF NOT EXIST "src\renderer\styles" md src\renderer\styles
IF NOT EXIST "src\renderer\utils" md src\renderer\utils

REM --- Структура для Backend (Node.js, Express, LLM - будет внутри src/backend) ---
IF NOT EXIST "src\backend" md src\backend
IF NOT EXIST "src\backend\config" md src\backend\config
IF NOT EXIST "src\backend\routes" md src\backend\routes
IF NOT EXIST "src\backend\controllers" md src\backend\controllers
IF NOT EXIST "src\backend\services" md src\backend\services
IF NOT EXIST "src\backend\llm" md src\backend\llm
IF NOT EXIST "src\backend\llm\tools" md src\backend\llm\tools
IF NOT EXIST "src\backend\llm\prompts" md src\backend\llm\prompts
IF NOT EXIST "src\backend\db" md src\backend\db
IF NOT EXIST "src\backend\db\migrations" md src\backend\db\migrations
IF NOT EXIST "src\backend\db\seeds" md src\backend\db\seeds
IF NOT EXIST "src\backend\middleware" md src\backend\middleware
IF NOT EXIST "src\backend\utils" md src\backend\utils
IF NOT EXIST "src\backend\validators" md src\backend\validators

REM --- Структура для Shared кода (если нужен) ---
IF NOT EXIST "src\shared" md src\shared
IF NOT EXIST "src\shared\types" md src\shared\types
IF NOT EXIST "src\shared\utils" md src\shared\utils

REM --- Папки для иконок (для electron-builder) ---
IF NOT EXIST "public\assets\icons" md public\assets\icons
IF NOT EXIST "public\assets\icons\win" md public\assets\icons\win
IF NOT EXIST "public\assets\icons\mac" md public\assets\icons\mac
IF NOT EXIST "public\assets\icons\png" md public\assets\icons\png

--- File: /package.json ---

{
  "name": "eckasse",
  "private": true,
  "version": "0.1.0",
  "description": "LLM-Powered Open Source POS System by Betruger. This is the monorepo root.",
  "scripts": {
    "start:backend": "npm start --workspace=@eckasse/backend",
    "dev:backend": "npm run dev --workspace=@eckasse/backend",
    "migrate:backend": "npm run db:migrate:latest --workspace=@eckasse/backend",
    "seed:backend": "npm run db:seed:run --workspace=@eckasse/backend",
    "dev:client:svelte": "npm run dev --workspace=@eckasse/renderer-ui",
    "dev:electron:wait-and-watch": "wait-on http://localhost:3030 && npm run dev:electron:watch --workspace=@eckasse/client-desktop",
    "build:client:desktop": "npm run build --workspace=@eckasse/client-desktop",
    "dist:client:desktop": "npm run dist --workspace=@eckasse/client-desktop",
    "dev:desktop:full": "concurrently -k -n \"BACKEND,ELECTRON\" -c \"bgBlue.bold,bgMagenta.bold\" \"npm:dev:backend\" \"npm:dev:electron:wait-and-watch\"",
    "dev": "concurrently -k -n \"BACKEND,SVELTE,ELECTRON\" -c \"bgBlue.bold,bgRed.bold,bgMagenta.bold\" \"npm:dev:backend\" \"npm:dev:client:svelte\" \"wait-on http://localhost:3001 && npm run dev:electron:watch --workspace=@eckasse/client-desktop\"",
    "lint:all": "npm run lint --workspaces --if-present",
    "format:all": "prettier --write \"packages/**/*.{js,json,md,css,html}\" \"shared/**/*.{js,json,md,css,html}\" \"*.{json,md}\"",
    "test:all": "npm run test --workspaces --if-present",
    "clean:all": "npm run clean --workspaces --if-present && node -e \"require('fs').rmSync('./node_modules', { recursive: true, force: true });\"",
    "bootstrap": "npm install --workspaces",
    "setup:restaurant": "node packages/backend/src/scripts/parse_and_init.js"
  },
  "workspaces": [
    "packages/*",
    "packages/client-desktop/src/renderer",
    "shared"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/betruger/eckasse.git"
  },
  "keywords": [
    "pos",
    "electron",
    "html",
    "css",
    "javascript",
    "llm",
    "gemini",
    "langchain",
    "eckasse",
    "monorepo",
    "betruger",
    "point-of-sale",
    "open-source"
  ],
  "author": "Betruger Sp. z o.o. <contact@betruger.com>",
  "contributors": [
    "Dmytro Surovtsev <dmytro@betruger.com>"
  ],
  "license": "EUPL-1.2",
  "homepage": "https://betruger.com",
  "bugs": {
    "url": "https://github.com/betruger/eckasse/issues"
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "cross-env": "^7.0.3",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-import": "^2.29.1",
    "prettier": "^3.3.2",
    "wait-on": "^7.2.0"
  },
  "dependencies": {
    "@google/genai": "^1.8.0",
    "ws": "^8.18.2"
  }
}


--- File: /packages/backend/GOOGLE_SEARCH_SETUP.md ---

# Google Search Setup Guide

This guide walks you through setting up Google Custom Search for the ecKasse web search functionality.

## Prerequisites

- Google Cloud account with billing enabled
- Project with Gemini API already set up (you should have GEMINI_API_KEY working)

## Step 1: Enable Custom Search API

1. Go to the [Google Cloud Console API Library](https://console.cloud.google.com/apis/library/customsearch.googleapis.com)
2. Select the same project where your Gemini API is enabled
3. Click "Enable" for the "Custom Search API"

## Step 2: Create a Programmable Search Engine

1. Go to [Programmable Search Engine](https://programmablesearchengine.google.com/)
2. Click "Get Started" or "Create Search Engine"
3. In "What to search?", select **"Search the entire web"**
4. Give your search engine a name (e.g., "ecKasse Web Search")
5. Click "Create"
6. After creation, you'll see your **Search Engine ID** (looks like: `017576662512468239146:omuauf_lfve`)
7. Copy this ID - this is your `GCS_CX` value

## Step 3: Update Environment Variables

Update your `.env` file:

```env
# Your existing Gemini API key
GEMINI_API_KEY="your_actual_gemini_api_key_here"

# Google Custom Search API Settings
GCS_API_KEY="your_actual_gemini_api_key_here"  # Same as GEMINI_API_KEY
GCS_CX="your_actual_search_engine_id_here"     # From step 2
```

## Step 4: Test the Setup

Run the test script:

```bash
node test_google_research.js
```

## Troubleshooting

### Common Issues

1. **"Google API key not set"**
   - Make sure your GEMINI_API_KEY is valid and active
   - Ensure Custom Search API is enabled in Google Cloud Console

2. **"API key not valid"**
   - Check that the API key has access to Custom Search API
   - Verify billing is enabled on your Google Cloud project

3. **"Search engine ID not found"**
   - Double-check the Search Engine ID from the Programmable Search Engine console
   - Ensure it's set to search the entire web

### Testing Individual Components

```bash
# Test environment setup
node test_google_env.js

# Test basic research functionality
node test_google_research.js
```

## API Limits

- Free tier: 100 search queries per day
- For production use, consider upgrading to paid tier
- Monitor usage in Google Cloud Console

## Security Notes

- Never commit your actual API keys to version control
- Use environment variables for all sensitive configuration
- Consider using Google Cloud IAM for production deployments

--- File: /packages/backend/NEXT_GEN_SEARCH_STATUS.md ---

# Next-Gen Hybrid Search Implementation Status

## ✅ Implementation Complete

### **Core System Overview**
Successfully implemented a sophisticated next-generation hybrid search system for the ecKasse POS system, featuring:

- **New Embedding Model**: `gemini-embedding-exp-03-07` with 768 dimensions
- **Multi-Phase Search Pipeline**: FTS → Vector → Levenshtein fallback
- **Enhanced LLM Agent**: Updated with web search capabilities
- **Optimized Database**: SQLite with sqlite-vec extension integration

---

### **Key Components Implemented**

#### 1. **Updated Embedding Service** (`src/services/embedding.service.js`)
- ✅ Migrated from `text-embedding-004` to `gemini-embedding-exp-03-07`
- ✅ Configured with `taskType: "RETRIEVAL_DOCUMENT"`
- ✅ Set `outputDimensionality: 768` to match database schema
- ✅ Maintained backward compatibility with options parameter

#### 2. **Hybrid Search Engine** (`src/services/search.service.js`)
- ✅ **Phase 1**: Fast FTS search for exact word matches
- ✅ **Phase 2**: Vector search for semantic similarity
- ✅ **Phase 3**: Levenshtein distance filtering for typo correction
- ✅ Intelligent fallback system with performance metrics
- ✅ Structured JSON responses with metadata

#### 3. **Enhanced LLM Agent** (`src/services/llm.service.js`)
- ✅ **Updated findProduct Tool**: Uses new hybrid search system
- ✅ **NEW web_search Tool**: Provides internet search capabilities
- ✅ **Enhanced System Prompt**: Guides proper interpretation of search results
- ✅ **Multi-language Support**: Maintains existing language handling

#### 4. **Database Integration** (`src/db/knex.js`)
- ✅ **SQLite-vec Extension**: Automatically loaded on connection
- ✅ **Vector Table**: Configured for 768-dimensional embeddings
- ✅ **Performance Optimization**: Connection pooling with extension caching

#### 5. **Supporting Infrastructure**
- ✅ **Levenshtein Utility** (`src/utils/levenshtein.js`): Typo correction algorithms
- ✅ **Backfill Script** (`src/scripts/backfillEmbeddings.js`): Populates vector database
- ✅ **Test Suite** (`test_next_gen_search.js`): Comprehensive validation

---

### **Search Pipeline Performance**

The system implements a sophisticated three-phase search approach:

```
User Query → FTS Search (Fast) → Vector Search (Semantic) → Levenshtein Filter (Typo Correction)
             ↓ No Results        ↓ No Results              ↓ Final Results
             Skip to Phase 2     Skip to Phase 3           Return to User
```

**Performance Characteristics:**
- **FTS Search**: ~5-500ms (instant for exact matches)
- **Vector Search**: ~1000-1500ms (semantic understanding)
- **Levenshtein Filter**: ~1-2ms (typo correction)
- **Total Pipeline**: Optimized for best-case performance

---

### **LLM Agent Enhancements**

#### **Enhanced findProduct Tool**
```javascript
// Returns structured JSON with search metadata
{
  "success": true/false,
  "message": "Human-readable response",
  "results": [/* Product objects */],
  "metadata": {
    "searchMethod": "fts|vector|hybrid",
    "executionTime": 1234,
    "totalResults": 5
  }
}
```

#### **NEW web_search Tool**
```javascript
// Provides internet search capabilities
{
  "success": true,
  "searchResults": {
    "query": "German VAT rates",
    "results": [/* Web search results */]
  }
}
```

---

### **Technical Specifications**

| Component | Specification |
|-----------|---------------|
| **Embedding Model** | `gemini-embedding-exp-03-07` |
| **Vector Dimensions** | 768 |
| **Task Type** | `RETRIEVAL_DOCUMENT` |
| **Database** | SQLite with sqlite-vec extension |
| **Search Methods** | FTS, Vector Similarity, Levenshtein |
| **LLM Models** | gemini-2.5-flash (primary), gemini-2.0-flash (fallback) |

---

### **Usage Examples**

#### **CLI Testing**
```bash
# Test embedding generation
node test_next_gen_search.js

# Backfill embeddings
npm run db:backfill:embeddings

# Test hybrid search
npm run test:hybrid-search
```

#### **Agent Interaction**
```javascript
// Product search with typo correction
"Find me a coffe" → Uses hybrid search → Returns coffee products

// Web search for current information
"What are current German VAT rates?" → Uses web_search tool → Returns current rates
```

---

### **System Integration**

The next-gen search system is fully integrated with:

- ✅ **Electron Desktop App**: Available through WebSocket/HTTP APIs
- ✅ **LangChain Agent**: Native tool integration
- ✅ **Database Layer**: Optimized queries with vector extensions
- ✅ **Error Handling**: Comprehensive fallback mechanisms
- ✅ **Logging**: Structured performance and debugging logs

---

### **Future Enhancements**

The current implementation provides a solid foundation for:

1. **Real Web Search Integration**: Replace mock web_search with actual search APIs
2. **Advanced Vector Operations**: Implement clustering and similarity thresholds
3. **Machine Learning Pipeline**: Add result ranking and user preference learning
4. **Multi-language Embeddings**: Extend to support multiple languages natively

---

### **Testing & Validation**

Comprehensive testing confirms:
- ✅ New embedding model generates 768-dimensional vectors
- ✅ Hybrid search pipeline executes all phases correctly
- ✅ LLM agent interprets structured search results properly
- ✅ Web search tool provides mock results as specified
- ✅ Database operations perform efficiently with vector extensions

---

## **Status: PRODUCTION READY** 🚀

The Next-Gen Hybrid Search system is fully implemented and operational, providing advanced search capabilities with semantic understanding, typo correction, and web search integration for the ecKasse POS system.

--- File: /packages/backend/check_categories.js ---

#!/usr/bin/env node

/**
 * Check available categories in the database
 */

require('dotenv').config({ path: '../../.env' });
const db = require('./src/db/knex');

async function checkCategories() {
    console.log('🔍 Checking available categories...');
    
    try {
        const categories = await db('categories').select('*');
        console.log(`\nFound ${categories.length} categories:`);
        
        categories.forEach((cat, index) => {
            console.log(`${index + 1}. ID: ${cat.id}`);
            console.log(`   Names: ${cat.category_names}`);
            console.log(`   Type: ${cat.category_type}`);
            console.log(`   POS Device ID: ${cat.pos_device_id}`);
            console.log('');
        });
        
        // Test the JSON extraction query
        console.log('Testing JSON extraction query...');
        const testResult = await db('categories')
            .whereRaw("JSON_EXTRACT(category_names, '$.de') = ?", ['Getränke'])
            .first();
            
        console.log('Result for Getränke:', testResult);
        
        // Try different approaches
        const allResults = await db('categories').whereRaw("category_names LIKE '%Getränke%'");
        console.log('LIKE query results:', allResults);
        
        process.exit(0);
    } catch (error) {
        console.error('Error:', error.message);
        process.exit(1);
    }
}

checkCategories();

--- File: /packages/backend/create_test_category.js ---

#!/usr/bin/env node

/**
 * Create test category for testing product creation
 */

require('dotenv').config({ path: '../../.env' });
const db = require('./src/db/knex');

async function createTestCategory() {
    console.log('🏗️ Creating test category...');
    
    try {
        // First, check if we have any pos_devices
        const posDevices = await db('pos_devices').select('*');
        console.log(`Found ${posDevices.length} POS devices`);
        
        if (posDevices.length === 0) {
            console.log('Creating test POS device...');
            // Create basic company first
            const [companyId] = await db('companies').insert({
                company_full_name: 'Test Company',
                meta_information: JSON.stringify({}),
                global_configurations: JSON.stringify({})
            }).returning('id');
            
            // Create basic branch
            const [branchId] = await db('branches').insert({
                company_id: companyId,
                branch_name: 'Test Branch',
                branch_address: 'Test Address'
            }).returning('id');
            
            // Create basic POS device
            const [posDeviceId] = await db('pos_devices').insert({
                branch_id: branchId,
                pos_device_name: 'Test POS',
                pos_device_type: 'terminal',
                pos_device_external_number: 1
            }).returning('id');
            
            console.log(`Created POS device with ID: ${posDeviceId}`);
        }
        
        // Get the first available POS device
        const posDevice = await db('pos_devices').first();
        console.log(`Using POS device ID: ${posDevice.id}`);
        
        // Create test categories
        const categories = [
            {
                pos_device_id: posDevice.id,
                source_unique_identifier: 'cat_drinks_test',
                category_names: JSON.stringify({ de: 'Getränke' }),
                category_type: 'drink',
                audit_trail: JSON.stringify({ created_by: 'test', created_at: new Date().toISOString() })
            },
            {
                pos_device_id: posDevice.id,
                source_unique_identifier: 'cat_food_test',
                category_names: JSON.stringify({ de: 'Speisen' }),
                category_type: 'food',
                audit_trail: JSON.stringify({ created_by: 'test', created_at: new Date().toISOString() })
            }
        ];
        
        const insertedCategories = await db('categories').insert(categories).returning('*');
        console.log(`Created ${insertedCategories.length} categories:`);
        
        insertedCategories.forEach(cat => {
            console.log(`  - ID: ${cat.id}, Name: ${cat.category_names}, Type: ${cat.category_type}`);
        });
        
        // Test the lookup now
        console.log('\n🧪 Testing category lookup...');
        const testCategory = await db('categories')
            .whereRaw("JSON_EXTRACT(category_names, '$.de') = ?", ['Getränke'])
            .first();
            
        console.log('Found category:', testCategory ? 'Yes' : 'No');
        if (testCategory) {
            console.log(`  ID: ${testCategory.id}, Names: ${testCategory.category_names}`);
        }
        
        console.log('✅ Test categories created successfully!');
        
    } catch (error) {
        console.error('❌ Error:', error.message);
        console.error('Stack:', error.stack);
    }
}

createTestCategory();

--- File: /packages/backend/debug_category_lookup.js ---

#!/usr/bin/env node

/**
 * Debug category lookup issue
 */

require('dotenv').config({ path: '../../.env' });
const db = require('./src/db/knex');

async function debugCategoryLookup() {
    console.log('🔍 Debugging category lookup...');
    
    try {
        // Check all categories
        const allCategories = await db('categories').select('*');
        console.log('\nAll categories:');
        allCategories.forEach(cat => {
            console.log(`ID: ${cat.id}, Names: ${cat.category_names}, Type: ${cat.category_type}`);
        });
        
        // Test different JSON extraction methods
        console.log('\n🧪 Testing JSON extraction methods...');
        
        // Method 1: JSON_EXTRACT
        console.log('1. Using JSON_EXTRACT...');
        const result1 = await db('categories')
            .whereRaw("JSON_EXTRACT(category_names, '$.de') = ?", ['EXTRAS'])
            .first();
        console.log('Result:', result1);
        
        // Method 2: Using knex json operators
        console.log('2. Using Knex JSON operators...');
        try {
            const result2 = await db('categories')
                .where('category_names->de', 'EXTRAS')
                .first();
            console.log('Result:', result2);
        } catch (err) {
            console.log('JSON operator failed:', err.message);
        }
        
        // Method 3: LIKE query
        console.log('3. Using LIKE query...');
        const result3 = await db('categories')
            .whereRaw("category_names LIKE ?", ['%EXTRAS%'])
            .first();
        console.log('Result:', result3);
        
        // Method 4: Raw query to test database
        console.log('4. Raw SQL query...');
        const rawResult = await db.raw("SELECT * FROM categories WHERE JSON_EXTRACT(category_names, '$.de') = 'EXTRAS'");
        console.log('Raw result:', rawResult);
        
        process.exit(0);
    } catch (error) {
        console.error('Error:', error.message);
        console.error('Stack:', error.stack);
        process.exit(1);
    }
}

debugCategoryLookup();

--- File: /packages/backend/exported_data.json ---

{
  "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
  "company_details": {
    "company_unique_identifier": 1,
    "company_full_name": "Test Store for Phase 3",
    "meta_information": {
      "format_version": "2.0.0",
      "date_generated": "2025-07-06T14:30:00.000Z",
      "generated_by": "phase3-test-script",
      "default_currency_symbol": "€",
      "default_language": "de",
      "export_timestamp": "2025-07-07T10:19:01.796Z",
      "exported_by": "eckasse-cli-export-v2.0.0",
      "export_version": "2.0.0"
    },
    "global_configurations": {
      "tax_rates_definitions": [
        {
          "tax_rate_unique_identifier": 1,
          "tax_rate_names": {
            "de": "Standard (19%)"
          },
          "rate_percentage": 19,
          "fiscal_mapping_type": "NORMAL"
        }
      ],
      "main_groups_definitions": [],
      "payment_methods_definitions": [],
      "promotions_definitions": [],
      "workflows": [],
      "integrations": {},
      "security_settings": {}
    },
    "branches": [
      {
        "branch_unique_identifier": 1,
        "branch_names": {
          "de": "Hauptfiliale"
        },
        "branch_address": "Test Street 1",
        "point_of_sale_devices": [
          {
            "pos_device_unique_identifier": 1,
            "pos_device_names": {
              "de": "Kasse 1"
            },
            "pos_device_type": "DESKTOP",
            "pos_device_external_number": 1,
            "pos_device_settings": {},
            "categories_for_this_pos": [
              {
                "category_unique_identifier": 1,
                "category_names": {
                  "de": "Gadgets"
                },
                "category_type": "other",
                "parent_category_unique_identifier": null,
                "default_linked_main_group_unique_identifier": null,
                "audit_trail": {}
              },
              {
                "category_unique_identifier": 2,
                "category_names": {
                  "de": "Drinkware"
                },
                "category_type": "other",
                "parent_category_unique_identifier": null,
                "default_linked_main_group_unique_identifier": null,
                "audit_trail": {}
              },
              {
                "category_unique_identifier": 3,
                "category_names": {
                  "de": "Getränke"
                },
                "category_type": "drink",
                "parent_category_unique_identifier": null,
                "default_linked_main_group_unique_identifier": null,
                "audit_trail": {}
              }
            ],
            "items_for_this_pos": [
              {
                "item_unique_identifier": 1001,
                "associated_category_unique_identifier": 1,
                "display_names": {
                  "menu": {
                    "de": "Super Widget"
                  },
                  "button": {
                    "de": "Super Widget"
                  },
                  "receipt": {
                    "de": "Super Widget"
                  }
                },
                "item_price_value": 19.99,
                "pricing_schedules": [],
                "availability_schedule": {
                  "always_available": true
                },
                "additional_item_attributes": {
                  "description": "Ein hochmodernes Super Widget mit erweiterten Funktionen für den täglichen Gebrauch",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": {
                  "is_sellable": true
                },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1002,
                "associated_category_unique_identifier": 2,
                "display_names": {
                  "menu": {
                    "de": "Eco Mug"
                  },
                  "button": {
                    "de": "Eco Mug"
                  },
                  "receipt": {
                    "de": "Eco Mug"
                  }
                },
                "item_price_value": 12.5,
                "pricing_schedules": [],
                "availability_schedule": {
                  "always_available": true
                },
                "additional_item_attributes": {
                  "description": "Umweltfreundliche Tasse aus recyceltem Material, perfekt für heiße Getränke wie Kaffee",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": {
                  "is_sellable": true
                },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1003,
                "associated_category_unique_identifier": 3,
                "display_names": {
                  "menu": {
                    "de": "Kaffee Espresso"
                  },
                  "button": {
                    "de": "Espresso"
                  },
                  "receipt": {
                    "de": "Kaffee Espresso"
                  }
                },
                "item_price_value": 2.2,
                "pricing_schedules": [],
                "availability_schedule": {
                  "always_available": true
                },
                "additional_item_attributes": {
                  "description": "Authentischer italienischer Espresso aus hochwertigen Arabica-Bohnen",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": {
                  "is_sellable": true
                },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1004,
                "associated_category_unique_identifier": 2,
                "display_names": {
                  "menu": {
                    "de": "Premium Coffee Cup"
                  },
                  "button": {
                    "de": "Coffee Cup"
                  },
                  "receipt": {
                    "de": "Premium Coffee Cup"
                  }
                },
                "item_price_value": 8.75,
                "pricing_schedules": [],
                "availability_schedule": {
                  "always_available": true
                },
                "additional_item_attributes": {
                  "description": "Hochwertige Kaffeetasse aus Keramik, ideal für heißen Kaffee und andere warme Getränke",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": {
                  "is_sellable": true
                },
                "audit_trail": {}
              }
            ]
          }
        ]
      }
    ]
  }
}

--- File: /packages/backend/package.json ---

{
  "name": "@eckasse/backend",
  "version": "0.1.0",
  "private": true,
  "main": "src/server.js",
  "type": "commonjs",
  "scripts": {
    "start": "node src/server.js",
    "dev": "node src/server.js",
    "lint": "eslint src/",
    "format": "prettier --write \"src/**/*.js\"",
    "db:migrate:latest": "npx knex migrate:latest --knexfile ./src/db/knexfile.js",
    "db:migrate:rollback": "npx knex migrate:rollback --knexfile ./src/db/knexfile.js",
    "db:seed:run": "npx knex seed:run --knexfile ./src/db/knexfile.js",
    "db:migrate:vec": "node src/scripts/migrate.js",
    "db:backfill:embeddings": "node src/scripts/backfillEmbeddings.js",
    "test:hybrid-search": "node src/scripts/testHybridSearch.js",
    "test": "echo \"Error: no test specified for @eckasse/backend\" && exit 0"
  },
  "dependencies": {
    "@google/genai": "^1.4.0",
    "@journeyapps/sqlcipher": "^5.3.1",
    "ajv": "^8.17.1",
    "ajv-formats": "^3.0.1",
    "axios": "^1.10.0",
    "bcrypt": "^6.0.0",
    "chalk": "^4.1.2",
    "cheerio": "^1.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.19.2",
    "inquirer": "^12.7.0",
    "knex": "^3.1.0",
    "ora": "^5.4.1",
    "pino": "^9.7.0",
    "semver": "^7.5.4",
    "sharp": "^0.34.2",
    "sqlite-vec": "^0.1.7-alpha.2",
    "sqlite3": "^5.1.7",
    "tesseract.js": "^6.0.1",
    "uuid": "^10.0.0",
    "winston": "^3.17.0",
    "ws": "^7.5.10"
  },
  "devDependencies": {
    "pino-pretty": "^13.0.0"
  }
}


--- File: /packages/backend/quick_test.js ---

#!/usr/bin/env node

/**
 * Quick verification that getSalesReport is working
 */

require('dotenv').config({ path: '../../.env' });

async function quickTest() {
    console.log('🧪 Quick test of getSalesReport implementation...');
    
    // Test 1: Direct service test
    console.log('\n1. Testing reporting service directly...');
    const { generateSalesReport } = require('./src/services/reporting.service.js');
    
    const report = await generateSalesReport({ period: 'today' });
    console.log(`✅ Service test: ${report.success ? 'PASS' : 'FAIL'}`);
    
    if (report.success) {
        console.log(`   📊 Revenue: ${report.data.totalRevenue}, Transactions: ${report.data.transactionCount}`);
    }
    
    // Test 2: LLM service integration test
    console.log('\n2. Testing LLM service integration...');
    const { sendMessage } = require('./src/services/llm.service.js');
    
    console.log('   Sending query: "покажи отчет о продажах за сегодня"');
    
    // Set timeout for LLM test
    const timeout = setTimeout(() => {
        console.log('   ⏱️  LLM test timed out (30s) - this may be normal for first run');
        process.exit(0);
    }, 30000);
    
    try {
        const response = await sendMessage("покажи отчет о продажах за сегодня", []);
        clearTimeout(timeout);
        
        const responseText = response.text.toLowerCase();
        const hasRealData = responseText.includes('revenue') || 
                           responseText.includes('доход') || 
                           responseText.includes('отчет') ||
                           responseText.includes('204') ||  // Known revenue from direct test
                           responseText.includes('24');     // Known transaction count
        
        console.log(`   ✅ LLM integration test: ${hasRealData ? 'PASS' : 'FAIL'}`);
        console.log(`   📝 Response: ${response.text.substring(0, 100)}...`);
        
    } catch (error) {
        clearTimeout(timeout);
        console.log(`   ❌ LLM test failed: ${error.message}`);
    }
    
    console.log('\n🎉 Testing complete!');
}

quickTest().catch(console.error);

--- File: /packages/backend/src/app.js ---

// C:\Users\xelth\eckasse\src\backend\app.js
const express = require('express');
const cors = require('cors');
const path = require('path');
const logger = require('./config/logger'); // Путь к вашему логгеру
// const mainRoutes = require('./routes/index'); // THIS SHOULD BE COMMENTED OR REMOVED
const llmRoutes = require('./routes/llm.routes.js'); // For Gemini Ping-Pong


const app = express();

// Middleware
app.use(cors()); // Включить CORS для всех маршрутов (настройте более строго для продакшена)
app.use(express.json()); // Для парсинга application/json
app.use(express.urlencoded({ extended: true })); // Для парсинга application/x-www-form-urlencoded


// Временное хранилище для operationId HTTP - должно быть синхронизировано или объединено с WebSocket
// Для простоты сейчас оставим отдельным, но в реальном приложении это должен быть общий механизм
const processedHttpOperationIds = new Set();
const HTTP_OPERATION_ID_TTL = 60000;

// Логирование запросов
app.use((req, res, next) => {
  // Добавим operationId в лог, если он есть в query или body
  const operationId = req.query.operationId || (req.body && req.body.operationId);
  logger.info({
    type: 'http_request',
    direction: 'in',
    operationId,
    method: req.method,
    url: req.originalUrl,
    body: req.body, // Be careful logging full bodies in production
    query: req.query,
    ip: req.ip
  });
  next();
});

// Раздача статических файлов для фронтенда
const staticPath = path.join(__dirname, '../../client-desktop/src/renderer/dist');
app.use(express.static(staticPath));
logger.info(`Serving static files from: ${staticPath}`);

// Подключение маршрутов API
// app.use('/api', mainRoutes); // Когда у вас будут роуты
app.use('/api/llm', llmRoutes); // Mount the LLM routes

// HTTP fallback endpoint for WebSocket commands
app.post('/api/websocket-fallback', async (req, res) => {
  const { operationId, command, payload } = req.body;

  if (!operationId) {
    logger.warn({ msg: 'HTTP fallback request without operationId' });
    return res.status(400).json({ error: 'operationId is required' });
  }

  if (processedHttpOperationIds.has(operationId)) {
    logger.info({ msg: 'Duplicate HTTP fallback operationId received', operationId });
    return res.json({
      operationId,
      status: 'already_processed',
      message: `Operation ${operationId} was already processed via HTTP.`,
      channel: 'http'
    });
  }

  processedHttpOperationIds.add(operationId);
  setTimeout(() => {
    processedHttpOperationIds.delete(operationId);
  }, HTTP_OPERATION_ID_TTL);

  // Reuse the same command handling logic from WebSocket server
  let responsePayload;
  let status = 'success';
  let responseCommand = command + 'Response';

  try {
    if (command === 'getParkedTransactions') {
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.getParkedTransactions();
    } else if (command === 'activateTransaction') {
      const { transactionId, userId, updateTimestamp } = payload;
      if (!transactionId || !userId) {
        throw new Error('TransactionId and userId are required');
      }
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.activateTransaction(transactionId, userId, updateTimestamp);
      responseCommand = 'orderUpdated';
    } else {
      status = 'error';
      responsePayload = { message: 'Command not supported in HTTP fallback', originalCommand: command };
      logger.warn({ msg: 'Unsupported HTTP fallback command', command, operationId });
    }
  } catch (error) {
    status = 'error';
    responsePayload = { message: 'Command execution failed', error: error.message };
    logger.error({ msg: 'HTTP fallback command execution error', command, operationId, error: error.message });
  }

  const response = {
    operationId,
    command: responseCommand,
    status,
    payload: responsePayload,
    channel: 'http',
    serverTime: new Date().toISOString()
  };

  logger.info({ type: 'http_response', direction: 'out', data: response });
  res.json(response);
});


// Пример простого маршрута для теста
app.get('/api/ping', (req, res) => {
  const operationId = req.query.operationId; // Ожидаем operationId в query параметрах для GET

  if (!operationId) {
    logger.warn({ msg: 'HTTP /api/ping request without operationId' });
    return res.status(400).json({ error: 'operationId is required in query parameters' });
  }

  if (processedHttpOperationIds.has(operationId)) {
    logger.info({ msg: 'Duplicate HTTP /api/ping operationId received', operationId });
    return res.json({
      operationId,
      status: 'already_processed',
      message: `Operation ${operationId} was already processed or is in progress via HTTP.`,
      channel: 'http'
    });
  }

  processedHttpOperationIds.add(operationId);
  setTimeout(() => {
    processedHttpOperationIds.delete(operationId);
  }, HTTP_OPERATION_ID_TTL);

  const responsePayload = { message: 'pong from ecKasse backend!', timestamp: new Date().toISOString() };
  const response = { 
    operationId, 
    status: 'success', 
    payload: responsePayload, 
    channel: 'http',
    serverTime: new Date().toISOString()
  };

  logger.info({ type: 'http_response', direction: 'out', operationId, data: response });
  res.json(response);
});

// Catch-all route для SPA - возвращаем index.html для всех не-API роутов
app.get('*', (req, res, next) => {
  // Если запрос начинается с /api, то это API роут - переходим к 404
  if (req.originalUrl.startsWith('/api')) {
    const error = new Error('API Route Not Found');
    error.status = 404;
    logger.warn({ msg: 'API route not found', url: req.originalUrl });
    return next(error);
  }
  
  // Для всех остальных роутов отдаем index.html (для фронтенда)
  res.sendFile(path.join(staticPath, 'index.html'));
});

// Глобальный обработчик ошибок
app.use((error, req, res, next) => {
  logger.error({
    msg: 'Global error handler caught an error',
    err: { message: error.message, stack: error.stack, status: error.status || 500 },
    url: req.originalUrl
  });
  res.status(error.status || 500);
  res.json({
    error: {
      message: error.message || 'Internal Server Error',
    },
  });
});

module.exports = app;

--- File: /packages/backend/src/config/logger.js ---

// File: /packages/backend/src/config/logger.js

const pino = require('pino');

// Теперь логи всегда будут в формате JSON, идеальном для машин и LLM.
// Для "красивого" вывода в процессе разработки можно использовать утилиту pino-pretty в терминале:
// node src/server.js | pino-pretty
const logger = pino({
  level: process.env.LOG_LEVEL || 'debug',
});

module.exports = logger;

--- File: /packages/backend/src/controllers/llm.controller.js ---

// File: /packages/backend/src/controllers/llm.controller.js
const llmService = require('../services/llm.service');
const logger = require('../config/logger');

// In a real app, chat history would be stored per user/session
let globalChatHistory = []; 

async function handleGeminiPing(req, res, next) {
  const { message, history } = req.body; // Expect history to be passed if continuing a conversation

  if (!message) {
    logger.warn({type: 'http_request', direction: 'in', msg: 'Gemini ping request without message body'});
    return res.status(400).json({ error: 'Message is required in the request body.' });
  }

  // Use provided history or the global one (for simple demo)
  const currentHistory = history || globalChatHistory;

  try {
    const geminiServiceResponse = await llmService.sendMessage(message, currentHistory);
    
    // Update global history (for next turn in this simple demo)
    // In a real app, manage this per session.
    if (geminiServiceResponse.history) {
        globalChatHistory = geminiServiceResponse.history;
    } else { // If only text was returned (error or simple response without history update from service)
        globalChatHistory.push({ role: "user", parts: [{ text: message }] });
        globalChatHistory.push({ role: "model", parts: [{ text: geminiServiceResponse.text }] });
    }
    // Cap history length to avoid overly long contexts for this demo
    if (globalChatHistory.length > 10) {
        globalChatHistory = globalChatHistory.slice(-10);
    }

    const responsePayload = {
      status: 'success',
      original_message: message,
      gemini_response_text: geminiServiceResponse.text, // just the text for client
      // Добавляем информацию о лимитах для UI
      isTemporary: geminiServiceResponse.isTemporary,
      errorType: geminiServiceResponse.errorType,
      // full_gemini_service_response: geminiServiceResponse, // Optional: for debugging
    };
    
    logger.info({type: 'http_response', direction: 'out', operation: 'geminiPing', data: responsePayload});
    res.json(responsePayload);
  } catch (error) {
    logger.error({ msg: 'Error in handleGeminiPing controller', err: error.message, originalMessage: message });
    // Clear history on error for this simple demo to avoid corrupted state
    globalChatHistory = []; 
    res.status(500).json({ error: error.message || 'Failed to get response from Gemini.' });
  }
}

module.exports = {
  handleGeminiPing,
};

--- File: /packages/backend/src/db/knex.js ---

// File: /packages/backend/src/db/knex.js

const knex = require('knex');
const config = require('./knexfile.js');
const sqliteVec = require('sqlite-vec');

const environment = process.env.NODE_ENV || 'development';
const knexConfig = config[environment];

const db = knex(knexConfig);

// Hook into connection pool to load sqlite-vec extension
const originalAcquireConnection = db.client.acquireConnection;
db.client.acquireConnection = function() {
  return originalAcquireConnection.call(this).then(connection => {
    if (connection && !connection._vecLoaded) {
      try {
        sqliteVec.load(connection);
        connection._vecLoaded = true;
        console.log('sqlite-vec extension loaded on connection');
      } catch (error) {
        console.error('Failed to load sqlite-vec extension on connection:', error);
      }
    }
    return connection;
  });
};

module.exports = db;

--- File: /packages/backend/src/db/knexfile.js ---

// C:\Users\xelth\eckasse\src\backend\db\knexfile.js
const path = require('path');
const sqliteVec = require('sqlite-vec');
require('dotenv').config({ path: path.resolve(__dirname, '../../../../.env') }); // Загрузка .env из корня проекта

module.exports = {
  development: {
    client: 'sqlite3',
    connection: {
      filename: process.env.DB_FILENAME ? path.resolve(__dirname, '../../../../', process.env.DB_FILENAME) : path.resolve(__dirname, 'eckasse_dev.sqlite3')
    },
    useNullAsDefault: true,
    migrations: {
      directory: path.resolve(__dirname, 'migrations')
    },
    seeds: {
      directory: path.resolve(__dirname, 'seeds')
    },
    pool: {
      afterCreate: function(connection, done) {
        try {
          sqliteVec.load(connection);
          console.log('sqlite-vec extension loaded for migration');
          done();
        } catch (error) {
          console.error('Failed to load sqlite-vec extension:', error);
          done(error);
        }
      }
    }
  },
  // production: {
  //   client: 'sqlite3',
  //   connection: {
  //     filename: process.env.DB_FILENAME || './eckasse_prod.sqlite3' // Путь для продакшена может отличаться
  //   },
  //   useNullAsDefault: true,
  //   migrations: {
  //     directory: './migrations'
  //   }
  // }
};

--- File: /packages/backend/src/db/migrations/20250706120000_create_oop_pos_mdf_tables.js ---

// File: /packages/backend/src/db/migrations/20250706120000_create_oop_pos_mdf_tables.js
exports.up = function (knex) {
  return knex.schema
    .createTable('companies', (table) => {
      table.increments('id').primary();
      table.string('company_full_name').notNullable();
      table.jsonb('meta_information').notNullable();
      table.jsonb('global_configurations').notNullable();
      table.timestamps(true, true);
    })
    .createTable('branches', (table) => {
      table.increments('id').primary();
      table.integer('company_id').unsigned().references('id').inTable('companies').onDelete('CASCADE');
      table.string('branch_name').notNullable();
      table.string('branch_address');
      table.timestamps(true, true);
    })
    .createTable('pos_devices', (table) => {
      table.increments('id').primary();
      table.integer('branch_id').unsigned().references('id').inTable('branches').onDelete('CASCADE');
      table.string('pos_device_name').notNullable();
      table.string('pos_device_type').notNullable();
      table.integer('pos_device_external_number').notNullable();
      table.jsonb('pos_device_settings');
      table.timestamps(true, true);
    })
    .createTable('categories', (table) => {
      table.increments('id').primary();
      table.integer('pos_device_id').unsigned().references('id').inTable('pos_devices').onDelete('CASCADE');
      table.string('source_unique_identifier').notNullable().unique().index();
      table.jsonb('category_names').notNullable();
      table.string('category_type').notNullable();
      table.integer('parent_category_id').unsigned().references('id').inTable('categories').onDelete('SET NULL');
      table.integer('default_linked_main_group_unique_identifier');
      table.jsonb('audit_trail');
      table.timestamps(true, true);
    })
    .createTable('items', (table) => {
      table.increments('id').primary();
      table.integer('pos_device_id').unsigned().references('id').inTable('pos_devices').onDelete('CASCADE');
      table.string('source_unique_identifier').notNullable().unique().index();
      table.integer('associated_category_unique_identifier').unsigned().references('id').inTable('categories').onDelete('CASCADE');
      table.jsonb('display_names').notNullable();
      table.decimal('item_price_value', 10, 2).notNullable();
      table.jsonb('pricing_schedules');
      table.jsonb('availability_schedule');
      table.jsonb('additional_item_attributes');
      table.jsonb('item_flags').notNullable();
      table.jsonb('audit_trail').notNullable();
      table.timestamps(true, true);
    });
};

exports.down = function (knex) {
  return knex.schema
    .dropTableIfExists('items')
    .dropTableIfExists('categories')
    .dropTableIfExists('pos_devices')
    .dropTableIfExists('branches')
    .dropTableIfExists('companies');
};

--- File: /packages/backend/src/db/migrations/20250706150000_create_fts_table.js ---

// File: /packages/backend/src/db/migrations/20250706150000_create_fts_table.js

exports.up = function(knex) {
  return knex.schema.raw(`
    -- Создаем виртуальную FTS5 таблицу для индексации названий товаров
    CREATE VIRTUAL TABLE items_fts USING fts5(
      display_names,
      content='items',
      content_rowid='id'
    );

    -- Создаем триггеры для автоматической синхронизации FTS-таблицы с основной таблицей 'items'
    
    -- После вставки нового товара в 'items', добавляем его в индекс
    CREATE TRIGGER items_after_insert AFTER INSERT ON items BEGIN
      INSERT INTO items_fts(rowid, display_names) VALUES (new.id, new.display_names);
    END;

    -- Перед удалением товара из 'items', удаляем его из индекса
    CREATE TRIGGER items_after_delete AFTER DELETE ON items BEGIN
      INSERT INTO items_fts(items_fts, rowid, display_names) VALUES ('delete', old.id, old.display_names);
    END;

    -- При обновлении товара в 'items', обновляем и индекс
    CREATE TRIGGER items_after_update AFTER UPDATE ON items BEGIN
      INSERT INTO items_fts(items_fts, rowid, display_names) VALUES ('delete', old.id, old.display_names);
      INSERT INTO items_fts(rowid, display_names) VALUES (new.id, new.display_names);
    END;
  `);
};

exports.down = function(knex) {
  return knex.schema.dropTableIfExists('items_fts');
};

--- File: /packages/backend/src/db/migrations/20250706160000_create_vec_items_table.js ---

// File: /packages/backend/src/db/migrations/20250706160000_create_vec_items_table.js

exports.up = function(knex) {
  return knex.schema.raw(`
    -- Create virtual table for vector search using sqlite-vec
    -- Each row stores a vector embedding for item names
    CREATE VIRTUAL TABLE IF NOT EXISTS vec_items USING vec0(
      item_embedding FLOAT[768]
    );
  `);
};

exports.down = function(knex) {
  return knex.schema.dropTableIfExists('vec_items');
};

--- File: /packages/backend/src/db/migrations/20250709100000_add_menu_item_number_to_items.js ---

// packages/backend/src/db/migrations/20250709100000_add_menu_item_number_to_items.js
exports.up = function(knex) {
  return knex.schema.table('items', function(table) {
    table.string('menu_item_number').nullable().index();
  });
};

exports.down = function(knex) {
  return knex.schema.table('items', function(table) {
    table.dropColumn('menu_item_number');
  });
};

--- File: /packages/backend/src/db/migrations/20250713120000_create_search_cache_table.js ---

exports.up = function(knex) {
  return knex.schema.createTable('search_cache', (table) => {
    table.increments('id').primary();
    table.text('query_text').notNullable().index();
    table.specificType('query_embedding', 'BLOB');
    table.string('model_used').notNullable();
    table.jsonb('result_item_ids').notNullable();
    table.text('full_response_text').notNullable();
    table.timestamps(true, true);
  });
};

exports.down = function(knex) {
  return knex.schema.dropTableIfExists('search_cache');
};

--- File: /packages/backend/src/db/migrations/20250713210000_create_menu_layouts_table.js ---

exports.up = function(knex) {
  return knex.schema.createTable('menu_layouts', (table) => {
    table.increments('id').primary();
    table.string('name').notNullable();
    table.text('description');
    table.jsonb('layout_data').notNullable(); // Stores the category tree for this layout
    table.boolean('is_active').defaultTo(false).index();
    table.string('source_type').notNullable().defaultTo('USER_CREATED'); // e.g., 'AI_OPTIMIZED', 'ORIGINAL_MENU', 'USER_CREATED'
    table.timestamps(true, true);
  });
};

exports.down = function(knex) {
  return knex.schema.dropTableIfExists('menu_layouts');
};

--- File: /packages/backend/src/db/migrations/20250722000500_create_user_management_tables.js ---

// File: /packages/backend/src/db/migrations/20250722000500_create_user_management_tables.js
exports.up = function (knex) {
  return knex.schema
    .createTable('roles', (table) => {
      table.increments('id').primary();
      table.string('role_name').notNullable().unique();
      table.jsonb('role_display_names').notNullable(); // multilingual names
      table.text('description');
      table.jsonb('permissions').notNullable(); // array of permission strings
      table.decimal('default_storno_daily_limit', 10, 2).defaultTo(50.00);
      table.decimal('default_storno_emergency_limit', 10, 2).defaultTo(25.00);
      table.boolean('can_approve_changes').defaultTo(false);
      table.boolean('can_manage_users').defaultTo(false);
      table.boolean('is_system_role').defaultTo(false);
      table.jsonb('audit_trail').notNullable();
      table.timestamps(true, true);
    })
    .createTable('users', (table) => {
      table.increments('id').primary();
      table.string('username').notNullable().unique();
      table.string('email').notNullable().unique();
      table.string('password_hash').notNullable();
      table.string('full_name').notNullable();
      table.integer('role_id').unsigned().references('id').inTable('roles').onDelete('RESTRICT');
      table.integer('pos_device_id').unsigned().references('id').inTable('pos_devices').onDelete('SET NULL');
      table.decimal('storno_daily_limit', 10, 2).notNullable();
      table.decimal('storno_emergency_limit', 10, 2).notNullable();
      table.decimal('storno_used_today', 10, 2).defaultTo(0.00);
      table.integer('trust_score').defaultTo(50).checkBetween([0, 100]);
      table.boolean('is_active').defaultTo(true);
      table.boolean('force_password_change').defaultTo(false);
      table.timestamp('last_login_at');
      table.string('last_login_ip');
      table.integer('failed_login_attempts').defaultTo(0);
      table.timestamp('locked_until');
      table.jsonb('user_preferences'); // UI preferences, language, etc.
      table.jsonb('audit_trail').notNullable();
      table.timestamps(true, true);
      
      // Indexes for performance
      table.index(['username']);
      table.index(['email']);
      table.index(['role_id']);
      table.index(['is_active']);
    })
    .createTable('pending_changes', (table) => {
      table.increments('id').primary();
      table.string('change_id').notNullable().unique();
      table.integer('requested_by_user_id').unsigned().references('id').inTable('users').onDelete('CASCADE');
      table.string('change_type').notNullable(); // 'product_update', 'price_change', 'category_create', etc.
      table.string('target_entity_type').notNullable(); // 'product', 'category', 'user', etc.
      table.integer('target_entity_id').unsigned(); // ID of the entity being changed
      table.jsonb('original_data'); // current state before change
      table.jsonb('proposed_data').notNullable(); // proposed new state
      table.text('reason'); // reason for change
      table.string('priority').defaultTo('normal'); // 'low', 'normal', 'high', 'urgent'
      table.string('status').defaultTo('pending'); // 'pending', 'approved', 'rejected', 'auto_applied'
      table.integer('reviewed_by_user_id').unsigned().references('id').inTable('users').onDelete('SET NULL');
      table.timestamp('reviewed_at');
      table.text('review_notes');
      table.timestamp('auto_apply_at'); // for scheduled automatic application
      table.boolean('requires_admin_approval').defaultTo(true);
      table.jsonb('audit_trail').notNullable();
      table.timestamps(true, true);
      
      // Indexes for performance
      table.index(['status']);
      table.index(['requested_by_user_id']);
      table.index(['change_type']);
      table.index(['priority']);
      table.index(['auto_apply_at']);
    })
    .createTable('storno_log', (table) => {
      table.increments('id').primary();
      table.string('storno_id').notNullable().unique();
      table.integer('user_id').unsigned().references('id').inTable('users').onDelete('CASCADE');
      table.string('transaction_id').notNullable(); // reference to original transaction
      table.decimal('storno_amount', 10, 2).notNullable();
      table.string('storno_type').notNullable(); // 'automatic', 'admin_approved', 'emergency'
      table.text('reason').notNullable();
      table.integer('approved_by_user_id').unsigned().references('id').inTable('users').onDelete('SET NULL');
      table.boolean('within_credit_limit').defaultTo(true);
      table.decimal('credit_used', 10, 2).notNullable();
      table.decimal('remaining_credit_after', 10, 2).notNullable();
      table.string('approval_status').defaultTo('automatic'); // 'automatic', 'pending', 'approved', 'rejected'
      table.timestamp('approved_at');
      table.jsonb('additional_data'); // any extra context data
      table.jsonb('audit_trail').notNullable();
      table.timestamps(true, true);
      
      // Indexes for performance
      table.index(['user_id']);
      table.index(['transaction_id']);
      table.index(['storno_type']);
      table.index(['approval_status']);
      table.index(['created_at']);
    })
    .createTable('user_sessions', (table) => {
      table.increments('id').primary();
      table.string('session_id').notNullable().unique();
      table.integer('user_id').unsigned().references('id').inTable('users').onDelete('CASCADE');
      table.timestamp('expires_at').notNullable();
      table.string('ip_address');
      table.string('user_agent');
      table.boolean('is_active').defaultTo(true);
      table.timestamps(true, true);
      
      // Indexes for performance
      table.index(['session_id']);
      table.index(['user_id']);
      table.index(['expires_at']);
    });
};

exports.down = function (knex) {
  return knex.schema
    .dropTableIfExists('user_sessions')
    .dropTableIfExists('storno_log')
    .dropTableIfExists('pending_changes')
    .dropTableIfExists('users')
    .dropTableIfExists('roles');
};

--- File: /packages/backend/src/db/migrations/20250726203101_create_fiscal_log_table.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.createTable('fiscal_log', (table) => {
    table.increments('id').primary();
    table.uuid('log_id').unique().notNullable().index();
    table.timestamp('timestamp_utc', { useTz: true }).notNullable().index();
    table.string('event_type').notNullable().index();
    table.bigInteger('transaction_number_tse').unsigned().notNullable().index();
    table.integer('user_id').unsigned().references('id').inTable('users').onDelete('SET NULL');
    table.jsonb('payload_for_tse').notNullable();
    table.jsonb('tse_response').notNullable();
    table.string('previous_log_hash').notNullable().index();
    table.string('current_log_hash').notNullable().unique().index();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.dropTableIfExists('fiscal_log');
};


--- File: /packages/backend/src/db/migrations/20250726203102_create_operational_log_table.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.createTable('operational_log', (table) => {
    table.increments('id').primary();
    table.uuid('log_id').unique().notNullable();
    table.timestamp('timestamp_utc', { useTz: true }).notNullable().index();
    table.string('event_type').notNullable().index();
    table.integer('user_id').unsigned().references('id').inTable('users').onDelete('SET NULL');
    table.jsonb('details');
    table.string('previous_log_hash').notNullable().index();
    table.string('current_log_hash').notNullable().unique().index();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.dropTableIfExists('operational_log');
};


--- File: /packages/backend/src/db/migrations/20250726203103_create_system_log_table.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.createTable('system_log', (table) => {
    table.increments('id').primary();
    table.timestamp('timestamp', { useTz: true }).defaultTo(knex.fn.now()).index();
    table.string('level').notNullable().index();
    table.text('message').notNullable();
    table.jsonb('context');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.dropTableIfExists('system_log');
};


--- File: /packages/backend/src/db/migrations/20250726205444_create_pending_fiscal_operations_table.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.createTable('pending_fiscal_operations', (table) => {
    table.increments('id').primary();
    table.uuid('operation_id').unique().notNullable().index();
    table.string('status').notNullable().index(); // PENDING, TSE_SUCCESS, TSE_FAILED, COMMITTED
    table.jsonb('payload_for_tse').notNullable();
    table.jsonb('tse_response').nullable();
    table.text('last_error').nullable();
    table.integer('retry_count').defaultTo(0);
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.dropTableIfExists('pending_fiscal_operations');
};


--- File: /packages/backend/src/db/migrations/20250726215719_add_current_log_hash_to_operational_log.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.alterTable('operational_log', (table) => {
    table.string('current_log_hash').notNullable().unique().index();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.alterTable('operational_log', (table) => {
    table.dropColumn('current_log_hash');
  });
};


--- File: /packages/backend/src/db/migrations/20250726222000_add_hash_columns_to_fiscal_log.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.alterTable('fiscal_log', (table) => {
    table.string('previous_log_hash').notNullable().index().defaultTo('0000000000000000000000000000000000000000000000000000000000000000');
    table.string('current_log_hash').notNullable().unique().index();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.alterTable('fiscal_log', (table) => {
    table.dropColumn('previous_log_hash');
    table.dropColumn('current_log_hash');
  });
};

--- File: /packages/backend/src/db/migrations/20250727092501_create_active_transactions_table.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.createTable('active_transactions', (table) => {
    table.increments('id').primary();
    table.uuid('uuid').unique().notNullable().index();
    table.string('status').notNullable().defaultTo('active').index(); // e.g., active, finished, cancelled
    table.integer('user_id').unsigned().references('id').inTable('users').onDelete('SET NULL');
    table.decimal('total_amount', 12, 2).notNullable().defaultTo(0.00);
    table.decimal('tax_amount', 12, 2).notNullable().defaultTo(0.00);
    table.date('business_date').notNullable().index();
    table.jsonb('metadata'); // For table number, customer info, etc.
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.dropTableIfExists('active_transactions');
};


--- File: /packages/backend/src/db/migrations/20250727092502_create_active_transaction_items_table.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.createTable('active_transaction_items', (table) => {
    table.increments('id').primary();
    table.integer('active_transaction_id').unsigned().notNullable().references('id').inTable('active_transactions').onDelete('CASCADE');
    table.integer('item_id').unsigned().notNullable().references('id').inTable('items');
    table.decimal('quantity', 10, 3).notNullable();
    table.decimal('unit_price', 10, 2).notNullable();
    table.decimal('total_price', 12, 2).notNullable();
    table.decimal('tax_rate', 5, 2).notNullable();
    table.decimal('tax_amount', 12, 2).notNullable();
    table.text('notes').nullable();
    table.timestamps(true, true);

    table.index('active_transaction_id');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.dropTableIfExists('active_transaction_items');
};


--- File: /packages/backend/src/db/migrations/20250727173908_add_resolution_status_to_transactions.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.alterTable('active_transactions', (table) => {
    table.string('resolution_status').defaultTo('none').index();
    // Possible values: 'none', 'pending', 'postponed', 'resolved'
    // 'none' - normal transaction, no resolution needed
    // 'pending' - transaction needs user resolution
    // 'postponed' - user chose to deal with it later
    // 'resolved' - user has taken action on this transaction
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.alterTable('active_transactions', (table) => {
    table.dropColumn('resolution_status');
  });
};

--- File: /packages/backend/src/db/migrations/20250727174500_add_payment_fields_to_active_transactions.js ---

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function(knex) {
  return knex.schema.table('active_transactions', (table) => {
    table.string('payment_type').nullable(); // e.g., 'Bar', 'Karte', 'Zwischenrechnung'
    table.decimal('payment_amount', 12, 2).nullable(); // Amount paid
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function(knex) {
  return knex.schema.table('active_transactions', (table) => {
    table.dropColumn('payment_type');
    table.dropColumn('payment_amount');
  });
};

--- File: /packages/backend/src/db/seeds/01_initial_oop_pos_mdf_data.js ---

// File: /packages/backend/src/db/seeds/01_initial_oop_pos_mdf_data.js
exports.seed = async function (knex) {
  // Deletes ALL existing entries
  await knex('items').del();
  await knex('categories').del();
  await knex('pos_devices').del();
  await knex('branches').del();
  await knex('companies').del();

  // Inserts a seed company
  const [companyId] = await knex('companies').insert([
    {
      company_full_name: 'Betruger Sp. z o.o.',
      meta_information: JSON.stringify({ format_version: '2.0.0', default_currency_symbol: '€', default_language: 'de' }),
      global_configurations: JSON.stringify({
        tax_rates_definitions: [{ tax_rate_unique_identifier: 1, tax_rate_names: { de: "Standard (19%)" }, rate_percentage: 19.0 }],
      }),
    },
  ]).returning('id');

  // Inserts a seed branch
  const [branchId] = await knex('branches').insert([
    { company_id: companyId.id, branch_name: 'Hauptfiliale' }
  ]).returning('id');

  // Inserts a seed POS device
  const [posDeviceId] = await knex('pos_devices').insert([
    { branch_id: branchId.id, pos_device_name: 'Kasse 1', pos_device_type: 'DESKTOP', pos_device_external_number: 1 }
  ]).returning('id');

  // Inserts seed categories
  const [foodCategoryId] = await knex('categories').insert([
    { 
      pos_device_id: posDeviceId.id, 
      source_unique_identifier: 'cat_food_001',
      category_names: JSON.stringify({ de: 'Speisen' }), 
      category_type: 'food' 
    },
  ]).returning('id');
  const [drinksCategoryId] = await knex('categories').insert([
      { 
        pos_device_id: posDeviceId.id, 
        source_unique_identifier: 'cat_drink_001',
        category_names: JSON.stringify({ de: 'Getränke' }), 
        category_type: 'drink' 
      }
  ]).returning('id');

  // Inserts seed items
  await knex('items').insert([
    {
      pos_device_id: posDeviceId.id,
      source_unique_identifier: 'item_widget_001',
      associated_category_unique_identifier: foodCategoryId.id,
      display_names: JSON.stringify({ menu: { de: 'Super Widget' }, button: { de: 'Widget' }, receipt: { de: 'Super Widget' } }),
      item_price_value: 19.99,
      item_flags: JSON.stringify({ is_sellable: true, has_negative_price: false }),
      audit_trail: JSON.stringify({ created_at: new Date().toISOString(), created_by: 'seed', version: 1 }),
    },
    {
        pos_device_id: posDeviceId.id,
        source_unique_identifier: 'item_mug_001',
        associated_category_unique_identifier: drinksCategoryId.id,
        display_names: JSON.stringify({ menu: { de: 'Eco Mug' }, button: { de: 'Mug' }, receipt: { de: 'Eco Mug' } }),
        item_price_value: 12.50,
        item_flags: JSON.stringify({ is_sellable: true, has_negative_price: false }),
        audit_trail: JSON.stringify({ created_at: new Date().toISOString(), created_by: 'seed', version: 1 }),
      }
  ]);
};

--- File: /packages/backend/src/db/seeds/02_user_management_seed.js ---

// File: /packages/backend/src/db/seeds/02_user_management_seed.js
const bcrypt = require('bcrypt');

exports.seed = async function (knex) {
  // Helper function to create audit trail
  const createAuditTrail = (createdBy = 'system_seed') => ({
    created_at: new Date().toISOString(),
    created_by: createdBy,
    last_modified_at: new Date().toISOString(),
    last_modified_by: createdBy,
    version: 1,
    change_log: [{
      timestamp: new Date().toISOString(),
      user: createdBy,
      action: 'created',
      description: 'Initial seed data creation'
    }]
  });

  // Delete existing entries in correct order (respecting foreign keys)
  await knex('user_sessions').del();
  await knex('storno_log').del();
  await knex('pending_changes').del();
  await knex('users').del();
  await knex('roles').del();

  // Insert default roles
  const [managerRoleId] = await knex('roles').insert([
    {
      role_name: 'manager',
      role_display_names: JSON.stringify({
        de: 'Manager',
        en: 'Manager'
      }),
      description: 'Full system access with all management privileges',
      permissions: JSON.stringify([
        'pos.manage_all',
        'users.manage',
        'roles.manage',
        'products.create',
        'products.edit',
        'products.delete',
        'categories.create',
        'categories.edit',
        'categories.delete',
        'reports.view_all',
        'reports.export',
        'storno.approve_unlimited',
        'changes.approve',
        'settings.modify',
        'system.admin'
      ]),
      default_storno_daily_limit: 1000.00,
      default_storno_emergency_limit: 500.00,
      can_approve_changes: true,
      can_manage_users: true,
      is_system_role: true,
      audit_trail: JSON.stringify(createAuditTrail())
    }
  ]).returning('id');

  const [cashierRoleId] = await knex('roles').insert([
    {
      role_name: 'cashier',
      role_display_names: JSON.stringify({
        de: 'Kassierer',
        en: 'Cashier'
      }),
      description: 'Standard POS operator with limited privileges',
      permissions: JSON.stringify([
        'pos.operate',
        'products.view',
        'categories.view',
        'reports.view_own',
        'storno.request',
        'changes.request'
      ]),
      default_storno_daily_limit: 50.00,
      default_storno_emergency_limit: 25.00,
      can_approve_changes: false,
      can_manage_users: false,
      is_system_role: true,
      audit_trail: JSON.stringify(createAuditTrail())
    }
  ]).returning('id');

  const [supervisorRoleId] = await knex('roles').insert([
    {
      role_name: 'supervisor',
      role_display_names: JSON.stringify({
        de: 'Supervisor',
        en: 'Supervisor'
      }),
      description: 'Mid-level access with limited management privileges',
      permissions: JSON.stringify([
        'pos.operate',
        'pos.manage_shift',
        'products.view',
        'products.edit',
        'categories.view',
        'categories.edit',
        'reports.view_department',
        'storno.approve_limited',
        'changes.approve_limited',
        'users.view'
      ]),
      default_storno_daily_limit: 200.00,
      default_storno_emergency_limit: 100.00,
      can_approve_changes: true,
      can_manage_users: false,
      is_system_role: true,
      audit_trail: JSON.stringify(createAuditTrail())
    }
  ]).returning('id');

  // Generate password hashes
  const defaultPassword = 'eckasse123'; // TODO: This should be configurable in production
  const saltRounds = 12;
  const hashedPassword = await bcrypt.hash(defaultPassword, saltRounds);

  // Insert default users
  await knex('users').insert([
    {
      username: 'admin',
      email: 'admin@eckasse.local',
      password_hash: hashedPassword,
      full_name: 'System Administrator',
      role_id: managerRoleId.id,
      pos_device_id: null, // Can use any POS device
      storno_daily_limit: 1000.00,
      storno_emergency_limit: 500.00,
      storno_used_today: 0.00,
      trust_score: 100,
      is_active: true,
      force_password_change: true, // Force password change on first login
      user_preferences: JSON.stringify({
        language: 'de',
        theme: 'light',
        notifications: {
          pending_changes: true,
          storno_requests: true,
          system_alerts: true
        }
      }),
      audit_trail: JSON.stringify(createAuditTrail())
    },
    {
      username: 'cashier1',
      email: 'cashier1@eckasse.local',
      password_hash: hashedPassword,
      full_name: 'Maria Schmidt',
      role_id: cashierRoleId.id,
      pos_device_id: null, // Will be assigned to specific POS device later
      storno_daily_limit: 50.00,
      storno_emergency_limit: 25.00,
      storno_used_today: 0.00,
      trust_score: 50,
      is_active: true,
      force_password_change: true,
      user_preferences: JSON.stringify({
        language: 'de',
        theme: 'light',
        notifications: {
          pending_changes: false,
          storno_requests: false,
          system_alerts: true
        }
      }),
      audit_trail: JSON.stringify(createAuditTrail())
    },
    {
      username: 'supervisor1',
      email: 'supervisor1@eckasse.local',
      password_hash: hashedPassword,
      full_name: 'Hans Müller',
      role_id: supervisorRoleId.id,
      pos_device_id: null,
      storno_daily_limit: 200.00,
      storno_emergency_limit: 100.00,
      storno_used_today: 0.00,
      trust_score: 75,
      is_active: true,
      force_password_change: true,
      user_preferences: JSON.stringify({
        language: 'de',
        theme: 'light',
        notifications: {
          pending_changes: true,
          storno_requests: true,
          system_alerts: true
        }
      }),
      audit_trail: JSON.stringify(createAuditTrail())
    }
  ]);

  console.log('✅ User management seed data created successfully');
  console.log('📝 Default credentials:');
  console.log('   Username: admin    | Password: eckasse123 | Role: Manager');
  console.log('   Username: cashier1 | Password: eckasse123 | Role: Cashier');
  console.log('   Username: supervisor1 | Password: eckasse123 | Role: Supervisor');
  console.log('⚠️  Remember to change passwords on first login!');
};

--- File: /packages/backend/src/lib/CLI_README.md ---

# eckasse CLI Tool

Command-line interface for parsing restaurant menus using AI (Gemini 2.5/2.0) and converting them to OOP-POS-MDF format.

## Quick Start

```bash
# Parse single PDF menu
node cli.js parse-menu menu.pdf --restaurant-name "My Restaurant"

# Parse multiple files with rate limit protection
node cli.js parse-menu page1.pdf page2.pdf --restaurant-name "Restaurant" --batch-delay 10

# Append to existing configuration
node cli.js parse-menu new_page.pdf --append existing_config.json
```

## Key Features

- **Direct file processing**: Sends PDF/images directly to Gemini (no OCR)
- **Smart naming**: Auto-generates filenames with restaurant name and timestamp
- **Batch processing**: Multiple files with configurable delays
- **Append mode**: Add new menu pages to existing configurations
- **Rate limit handling**: Automatic partial saves and resume capability

## Commands

### `parse-menu <input...>`

Parse restaurant menu files into OOP-POS-MDF format.

### `import-mdf <filepath>`

Import a complete OOP-POS-MDF JSON file into the database, overwriting existing data.

**Options:**
- `--force` - Skip confirmation prompt and proceed with import
- `--dry-run` - Validate the JSON structure without actually importing
- `--validate` - Validate against schema before importing

**Examples:**
```bash
# Import configuration into database
node cli.js import-mdf menu_outputs/Park_Avenue_2025-07-06T22-58.json

# Dry run to check file structure
node cli.js import-mdf config.json --dry-run --validate

# Force import without confirmation
node cli.js import-mdf config.json --force
```

### `export-mdf [output]`

Export current database state to OOP-POS-MDF JSON file with "_exp" suffix.

**Options:**
- `--validate` - Validate exported configuration against schema
- `--pretty` - Format JSON output with indentation (default: true)
- `--force` - Overwrite existing output file without confirmation

**Examples:**
```bash
# Export current database state
node cli.js export-mdf
# → Creates: menu_outputs/Park_Avenue_2025-07-07T00-34_exp.json

# Export to specific file
node cli.js export-mdf backup/current_state.json

# Export with validation
node cli.js export-mdf --validate

# Force overwrite existing file
node cli.js export-mdf backup.json --force
```

## Database Management Workflow

The CLI tools enable a complete database management workflow:

```bash
# 1. Parse menu from files
node cli.js parse-menu menu.pdf --restaurant-name "Park Avenue"
# → Creates: menu_outputs/Park_Avenue_2025-07-06T22-58.json

# 2. Import into database for AI agent operations
node cli.js import-mdf menu_outputs/Park_Avenue_2025-07-06T22-58.json
# Database now contains: 1 company, 1 branch, 1 POS device, 5 categories, 24 items

# 3. Make changes via AI agent (through web interface or API)
# Agent can: add/modify/delete items, change prices, create categories, etc.

# 4. Export current state to see changes
node cli.js export-mdf
# → Creates: menu_outputs/Park_Avenue_2025-07-07T00-34_exp.json
# Shows current state after AI agent modifications

# 5. Compare or backup the modified state
# The _exp.json file contains the current state with all changes
```

### Parse Menu Options:
- `-o, --output <file>` - Custom output filename (auto-generated if not specified)
- `-a, --append <file>` - Append to existing configuration
- `--restaurant-name <name>` - Restaurant name (used in filename and LLM prompt)
- `--batch-delay <seconds>` - Delay between files (default: 5s)
- `--language <lang>` - Primary language (default: de)
- `--validate` - Validate generated configuration

**Examples:**
```bash
# Basic usage
node cli.js parse-menu menu.pdf --restaurant-name "Park Avenue"
# → Creates: menu_outputs/Park_Avenue_2025-07-06T22-15.json

# Multiple files with delay
node cli.js parse-menu page1.pdf page2.pdf page3.pdf --restaurant-name "Big Restaurant" --batch-delay 15
# → Creates: menu_outputs/Big_Restaurant_2025-07-06T22-15_3files.json

# Add more pages later
node cli.js parse-menu page4.pdf --append menu_outputs/Big_Restaurant_2025-07-06T22-15_3files.json
# → Updates existing file with new items
```

## Rate Limit Handling

When Gemini rate limits are hit:
1. **Partial results** are automatically saved
2. **Resume instructions** are displayed
3. Use `--append` to continue from where you left off

```bash
# If processing fails at file 3 of 5, resume with:
node cli.js parse-menu remaining_files.pdf --append menu_outputs/Restaurant_partial_2files_timestamp.json
```

## File Organization

```
menu_inputs/     # Input PDF/image files
menu_outputs/    # Generated configurations
├── Restaurant_Name_YYYY-MM-DDTHH-MM.json           # Parsed from menu files
├── Restaurant_Name_YYYY-MM-DDTHH-MM_3files.json    # Multiple files batch
├── Restaurant_Name_partial_2files_timestamp.json   # Partial results
└── Restaurant_Name_YYYY-MM-DDTHH-MM_exp.json       # Exported database state
```

**File Naming Convention:**
- **Parsed menus**: `RestaurantName_timestamp.json`
- **Batch processing**: `RestaurantName_timestamp_Nfiles.json`  
- **Partial results**: `RestaurantName_partial_Nfiles_timestamp.json`
- **Database exports**: `RestaurantName_timestamp_exp.json`

## Supported File Types

- **PDF**: `application/pdf`
- **Images**: PNG, JPEG, WebP, HEIC, HEIF
- **Video**: MP4, MOV, AVI (experimental)
- **Audio**: WAV, MP3, FLAC (experimental)

## AI Models

- **Primary**: Gemini 2.5-flash (higher quality, may hit limits)
- **Fallback**: Gemini 2.0-flash (more stable for large batches)

## Troubleshooting

**Rate Limits**: Increase `--batch-delay` or use `--append` to resume

**Large Menus**: Process in smaller batches, then combine with `--append`

**Poor Recognition**: Ensure good image quality, use `--validate` flag

**Import Issues**: 
- Use `--dry-run` to test file structure first
- Check database path in `.env` file 
- Ensure Gemini API key is configured for embedding generation

**Export Issues**:
- Make sure database contains data (run import first)
- Check file permissions in `menu_outputs/` directory
- Use `--force` to overwrite existing files

## Integration with AI Agent

The CLI tools work seamlessly with the AI agent system:

1. **Parse & Import**: Use CLI to get menu data into the database
2. **AI Operations**: Agent can modify items, prices, categories via natural language
3. **Export & Review**: Use CLI to export and review changes made by the agent
4. **Backup & Restore**: Export files serve as backups and can be re-imported

**Example Agent Operations:**
- "Add new item 'Tiramisu' for 6.50€ in Desserts category"
- "Increase all coffee prices by 10%"
- "Create new category 'Seasonal Specials'"
- "Remove item 'Old Menu Item'"

After any agent operations, run `export-mdf` to see the updated state.

--- File: /packages/backend/src/lib/cli.js ---

#!/usr/bin/env node

/**
 * eckasse CLI Tool
 * Command-line utility for managing eckasse POS configurations
 *
 * Features:
 * - Validate configurations against JSON Schema (v2.0.0)
 * - Generate sample configurations (v2.0.0)
 * - Convert between formats (including Vectron from v2.0.0)
 * - Parse menus using LLM (image, PDF, text) into v2.0.0 format
 *
 * @author eckasse Development Team
 * @version 2.0.0
 */

const fs = require('fs').promises;
const path = require('path');
const { program } = require('commander');

// Load environment variables from .env file
require('dotenv').config({ path: path.resolve(__dirname, '../../../../.env') });
const Ajv = require('ajv');
const addFormats = require('ajv-formats');
const chalk = require('chalk');

// Lazy-loaded modules (loaded only when needed)
let ora = null;
let MenuParserLLM = null;
let VectronConverter = null;
let importFromOopMdf = null;
let exportToOopMdfWithFileName = null;

// Helper functions for lazy loading
function loadOra() {
  if (!ora) ora = require('ora');
  return ora;
}

function loadMenuParser() {
  if (!MenuParserLLM) MenuParserLLM = require('../lib/menu_parser_llm.js');
  return MenuParserLLM;
}

function loadVectronConverter() {
  if (!VectronConverter) VectronConverter = require('../lib/converters/vectron.js');
  return VectronConverter;
}

function loadImportService() {
  if (!importFromOopMdf) {
    const service = require('../services/import.service.js');
    importFromOopMdf = service.importFromOopMdf;
  }
  return importFromOopMdf;
}

function loadExportService() {
  if (!exportToOopMdfWithFileName) {
    const service = require('../services/export.service.js');
    exportToOopMdfWithFileName = service.exportToOopMdfWithFileName;
  }
  return exportToOopMdfWithFileName;
}

// Database cleanup function  
async function cleanupResources() {
  try {
    // Close database connections if they were opened
    if (importFromOopMdf || exportToOopMdfWithFileName) {
      const db = require('../db/knex');
      await db.destroy();
      console.log(chalk.gray('Database connections closed.'));
    }
  } catch (error) {
    console.error(chalk.yellow(`Warning: Error during cleanup: ${error.message}`));
  }
}

// Graceful exit function
async function gracefulExit(code = 0) {
  await cleanupResources();
  process.exit(code);
}

class EckasseCLI {
  constructor() {
    this.ajv = new Ajv({ allErrors: true, strict: false });
    addFormats(this.ajv);
    this.schemas = new Map();
    // this.migrations = new Map(); // УДАЛЕНО

    // this.migrations.set('1.0.0->2.0.0', Migration_1_0_0_to_2_0_0); // УДАЛЕНО

    this.initCLI();
  }

  initCLI() {
    program
      .name('eckasse')
      .description('CLI tool for managing eckasse POS configurations')
      .version('2.0.0');

    // Validate command
    program
      .command('validate <file>')
      .description('Validate a configuration file against JSON Schema (v2.0.0)')
      .option('-s, --schema <version>', 'Schema version to validate against (only 2.0.0 supported)', '2.0.0')
      .option('-v, --verbose', 'Show detailed validation results')
      .action(async (file, options) => {
        // Принудительно устанавливаем schemaVersion в 2.0.0
        if (options.schema !== '2.0.0') {
          console.warn(chalk.yellow('⚠️  Only schema v2.0.0 is supported. Validating against v2.0.0.'));
          options.schema = '2.0.0';
        }
        await this.validateConfig(file, options);
      });

    // Migrate command (УДАЛЕНО)
    /*
    program
      .command('migrate <file>')
      .description('Migrate configuration between versions')
      .option('-t, --target <version>', 'Target version', '2.0.0')
      .option('-o, --output <file>', 'Output file path')
      .option('-b, --backup', 'Create backup of original file')
      .option('--dry-run', 'Show migration preview without saving')
      .action((file, options) => {
        this.migrateConfig(file, options);
      });
    */

    // Generate command
    program
      .command('generate')
      .description('Generate a sample configuration file (v2.0.0)')
      .option('-t, --type <type>', 'Configuration type', 'restaurant')
      .option('-v, --version <version>', 'Schema version (always 2.0.0)', '2.0.0')
      .option('-o, --output <file>', 'Output file path', 'sample-config.json')
      .action(async (options) => {
        // Принудительно устанавливаем version в 2.0.0
        if (options.version !== '2.0.0') {
          console.warn(chalk.yellow('⚠️  Only schema v2.0.0 is supported for generation. Generating v2.0.0.'));
          options.version = '2.0.0';
        }
        await this.generateConfig(options);
      });

    // Convert command
    program
      .command('convert <file>')
      .description('Convert configuration (v2.0.0) to different formats')
      .option('-f, --format <format>', 'Output format (vectron, csv, xml)', 'vectron')
      .option('-o, --output <file>', 'Output file path')
      .option('-k, --kassennummer <number>', 'Cash register number', parseInt)
      .option('-m, --import-mode <mode>', 'Import mode (A=Add, O=Overwrite, R=Replace)', 'A')
      .option('-c, --config <file>', 'Configuration file path')
      .option('--preset <preset>', 'Configuration preset (minimal, standard, advanced, production)')
      .option('--business-type <type>', 'Business type (restaurant, bar, cafe, retail)')
      .option('--language <lang>', 'Primary language code')
      .option('--languages <langs>', 'Supported languages (comma-separated)')
      .option('--include-auswahlfenster', 'Include display layout conversion (Phase 2)')
      .option('--include-complex-fields', 'Include complex field mappings (Phase 2)')
      .option('--include-multilingual', 'Include multilingual text fields (Phase 2)')
      .option('--strict-mode', 'Enable strict validation mode')
      .option('--no-validation', 'Disable output validation')
      .option('--verbose', 'Show detailed conversion information')
      .action(async (file, options) => {
        await this.convertConfig(file, options);
      });

    // Info command
    program
      .command('info <file>')
      .description('Show information about a configuration file (v2.0.0)')
      .action(async (file) => {
        await this.showConfigInfo(file);
      });

    // Interactive setup
    program
      .command('setup')
      .description('Interactive setup wizard for new configuration (v2.0.0)')
      .action(async () => {
        await this.interactiveSetup();
      });

    // Parse menu command (from menu_parser_cli.js)
    program
      .command('parse-menu <input...>')
      .description('Parse restaurant menu from image, PDF, or text files using LLM into v2.0.0 format')
      .option('-o, --output <file>', 'Output configuration file (auto-generated if not specified)')
      .option('-a, --append <file>', 'Append to existing configuration file instead of creating new')
      .option('-t, --business-type <type>', 'Business type (restaurant, cafe, bar, fastfood)', 'restaurant')
      .option('-l, --language <lang>', 'Primary language', 'de')
      .option('--languages <langs>', 'Supported languages (comma-separated)', 'de,en')
      .option('--restaurant-name <name>', 'Restaurant name override')
      .option('--batch-delay <seconds>', 'Delay between files to avoid rate limits (seconds)', '5')
      .option('--raw-json-output <filepath>', 'Save raw intermediate JSON from LLM for debugging')
      .option('--vectron', 'Generate Vectron import file after parsing')
      .option('--csv', 'Generate CSV export after parsing')
      .option('--validate', 'Validate generated configuration')
      .option('--interactive', 'Interactive mode for corrections if confidence is low')
      .option('--confidence-threshold <threshold>', 'Minimum confidence threshold (0.0-1.0)', '0.7')
      .option('--llm-provider <provider>', 'LLM provider (gemini)', 'gemini')
      .action(async (inputs, options) => {
        await this.parseMenuCommand(inputs, options);
      });

    // Interactive menu wizard (from menu_parser_cli.js)
    program
      .command('menu-wizard')
      .description('Interactive wizard for menu parsing and configuration into v2.0.0 format')
      .action(async () => {
        await this.menuWizard();
      });

    // Import OOP-POS-MDF command
    program
      .command('import-mdf <filepath>')
      .description('Import a complete oop-pos-mdf JSON file into the database, overwriting existing data')
      .option('--force', 'Skip confirmation prompt and proceed with import')
      .option('--dry-run', 'Validate the JSON structure without actually importing')
      .option('--validate', 'Validate against schema before importing')
      .action(async (filepath, options) => {
        await this.importMdfCommand(filepath, options);
      });

    // Export OOP-POS-MDF command
    program
      .command('export-mdf [output]')
      .description('Export current database state to oop-pos-mdf JSON file with "_exp" suffix')
      .option('--validate', 'Validate exported configuration against schema')
      .option('--pretty', 'Format JSON output with indentation (default: true)')
      .option('--force', 'Overwrite existing output file without confirmation')
      .option('--no-embeddings', 'Exclude vector embeddings from export (reduces file size)')
      .action(async (output, options) => {
        await this.exportMdfCommand(output, options);
      });

    // Enrich MDF command
    program
      .command('enrich-mdf <inputFile>')
      .description('Enrich a parsed oop-pos-mdf file with additional AI-generated data.')
      .option('-o, --output <outputFile>', 'Output file path for the enriched data')
      .option('--validate', 'Validate input file against schema before enriching')
      .option('--skip-web-search', 'Skip web search enrichment (faster but less detailed)')
      .option('--skip-main-groups', 'Skip main groups generation (Warengruppen)')
      .option('--dry-run', 'Show what would be enriched without making changes')
      .action(async (inputFile, options) => {
        await this.enrichMdfCommand(inputFile, options);
      });

    program.parse();
  }

  /**
   * Load and cache JSON schema
   * (Simplified to always load v2.0.0)
   */
  async loadSchema(version = '2.0.0') { // Принудительно устанавливаем версию
    if (version !== '2.0.0') {
      throw new Error(`Only schema v2.0.0 is supported. Attempted to load v${version}.`);
    }

    if (this.schemas.has(version)) {
      return this.schemas.get(version);
    }

    const schemaPath = path.join(__dirname, '..', 'schemas', `v${version}`, 'schema.json');
    try {
      const schemaContent = await fs.readFile(schemaPath, 'utf8');
      const schema = JSON.parse(schemaContent);
      this.schemas.set(version, schema);
      return schema;
    } catch (error) {
      console.error(chalk.red(`❌ Failed to load schema v${version}: ${error.message}`));
      process.exit(1);
    }
  }

  /**
   * Validate configuration file
   * (Always validates against v2.0.0)
   */
  async validateConfig(filePath, options) {
    // options.schema уже принудительно установлен в 2.0.0 в cli.js
    console.log(chalk.blue(`🔍 Validating ${filePath} against schema v${options.schema}...`));
    try {
      const configContent = await fs.readFile(filePath, 'utf8');
      const config = JSON.parse(configContent);

      const schema = await this.loadSchema(options.schema); // Будет загружена только v2.0.0
      const validate = this.ajv.compile(schema);

      const valid = validate(config);
      if (valid) {
        console.log(chalk.green('✅ Configuration is valid!'));
        if (options.verbose) {
          this.showConfigStats(config);
        }
      } else {
        console.log(chalk.red('❌ Configuration validation failed:'));
        validate.errors.forEach((error, index) => {
          console.log(chalk.red(`  ${index + 1}. ${error.instancePath || 'root'}: ${error.message}`));
          if (error.allowedValues) {
            console.log(chalk.gray(`     Allowed values: ${error.allowedValues.join(', ')}`));
          }
        });
        process.exit(1);
      }
    } catch (error) {
      console.error(chalk.red(`❌ Error: ${error.message}`));
      process.exit(1);
    }
  }

  /**
   * Validate configuration object directly (not from file)
   */
  async validateConfiguration(config, version = '2.0.0') {
    console.log(chalk.blue(`🔍 Validating configuration object against schema v${version}...`));
    try {
      const schema = await this.loadSchema(version);
      const validate = this.ajv.compile(schema);

      const valid = validate(config);
      if (valid) {
        console.log(chalk.green('✅ Configuration is valid!'));
        this.showConfigStats(config);
      } else {
        console.log(chalk.red('❌ Configuration validation failed:'));
        validate.errors.forEach((error, index) => {
          console.log(chalk.red(`  ${index + 1}. ${error.instancePath || 'root'}: ${error.message}`));
          if (error.allowedValues) {
            console.log(chalk.gray(`     Allowed values: ${error.allowedValues.join(', ')}`));
          }
        });
        throw new Error('Configuration validation failed');
      }
    } catch (error) {
      console.error(chalk.red(`❌ Validation error: ${error.message}`));
      throw error;
    }
  }

  /**
   * Show configuration statistics
   */
  showConfigStats(config) {
    console.log(chalk.cyan('\n📊 Configuration Statistics:'));

    try {
      const companyName = config.company_details?.company_full_name || 'N/A';
      const branchCount = config.company_details?.branches?.length || 0;
      let totalPosDevices = 0;
      let totalItems = 0;
      let totalCategories = 0;

      if (config.company_details?.branches) {
        for (const branch of config.company_details.branches) {
          if (branch.point_of_sale_devices) {
            totalPosDevices += branch.point_of_sale_devices.length;
            for (const pos of branch.point_of_sale_devices) {
              totalItems += pos.items_for_this_pos?.length || 0;
              totalCategories += pos.categories_for_this_pos?.length || 0;
            }
          }
        }
      }

      console.log(`   Company: ${chalk.bold(companyName)}`);
      console.log(`   Branches: ${chalk.bold(branchCount)}`);
      console.log(`   POS Devices: ${chalk.bold(totalPosDevices)}`);
      console.log(`   Categories: ${chalk.bold(totalCategories)}`);
      console.log(`   Items: ${chalk.bold(totalItems)}`);

      const formatVersion = config.company_details?.meta_information?.format_version || 'N/A';
      console.log(`   Format Version: ${chalk.bold(formatVersion)}`);

    } catch (error) {
      console.log(chalk.yellow(`   Unable to parse configuration statistics: ${error.message}`));
    }
  }

  /**
   * Migrate configuration (УДАЛЕНО из класса)
   */

  /**
   * Generate sample configuration
   * (Always generates v2.0.0)
   */
  async generateConfig(options) {
    console.log(chalk.blue(`✨ Generating sample ${options.type} configuration (v${options.version})...`));
    try {
      const sampleConfig = this.createSampleConfig(options.type, options.version);
      await fs.writeFile(options.output, JSON.stringify(sampleConfig, null, 2));
      console.log(chalk.green(`✅ Sample configuration saved to: ${options.output}`));
    } catch (error) {
      console.error(chalk.red(`❌ Error generating sample configuration: ${error.message}`));
      process.exit(1);
    }
  }

  createSampleConfig(type, version = '2.0.0') { // Принудительно устанавливаем версию
    const timestamp = new Date().toISOString();
    return {
      "$schema": `https://schemas.eckasse.com/oop-pos-mdf/v${version}/schema.json`,
      company_details: {
        company_unique_identifier: 1,
        company_full_name: `Sample ${type} Configuration`,
        meta_information: {
          format_version: version,
          date_generated: timestamp,
          generated_by: "eckasse-cli-v2.0.0",
          default_currency_symbol: "€",
          default_language: "de",
          supported_languages: ["de", "en"],
          audit_trail: {
            created_at: timestamp,
            created_by: "cli@eckasse.com",
            last_modified_at: timestamp,
            last_modified_by: "cli@eckasse.com",
            version: 1,
            change_log: []
          }
        },
        global_configurations: {
          tax_rates_definitions: [
            {
              tax_rate_unique_identifier: 1,
              tax_rate_names: { "de": "Standard (19%)", "en": "Standard (19%)" },
              rate_percentage: 19.0,
              fiscal_mapping_type: "NORMAL"
            }
          ],
          main_groups_definitions: [
            {
              main_group_unique_identifier: 1,
              main_group_names: { "de": "Hauptgruppe 1", "en": "Main Group 1" }
            }
          ],
          payment_methods_definitions: [
            {
              payment_method_unique_identifier: 1,
              payment_method_names: { "de": "Bar", "en": "Cash" },
              payment_method_type: "CASH"
            }
          ],
          promotions_definitions: [],
          workflows: [],
          integrations: {},
          security_settings: {
            encryption: { at_rest: true, in_transit: true, algorithm: "AES-256" },
            access_control: { session_timeout: 3600, max_failed_attempts: 3, lockout_duration: 900, require_2fa: false },
            data_privacy: { gdpr_compliance: true, data_retention_days: 2555, anonymization_rules: [] }
          }
        },
        branches: [
          {
            branch_unique_identifier: 1,
            branch_names: { "de": "Hauptfiliale", "en": "Main Branch" },
            branch_address: "Sample Street 1, 12345 Sample City",
            point_of_sale_devices: [
              {
                pos_device_unique_identifier: 1,
                pos_device_names: { "de": "Kasse 1", "en": "POS 1" },
                pos_device_type: "DESKTOP",
                pos_device_external_number: 1,
                pos_device_settings: {
                  default_currency_identifier: "€",
                  default_linked_drink_tax_rate_unique_identifier: 1,
                  default_linked_food_tax_rate_unique_identifier: 1
                },
                categories_for_this_pos: [],
                items_for_this_pos: []
              }
            ]
          }
        ]
      }
    };
  }

  /**
   * Convert configuration to a different format.
   */
  async convertConfig(file, options) {
    console.log(chalk.blue(`🔄 Converting ${file} to ${options.format}...`));
    try {
      const configContent = await fs.readFile(file, 'utf8');
      const config = JSON.parse(configContent);

      let outputContent;
      let outputPath = options.output;
      let conversionResult;

      switch (options.format.toLowerCase()) {
        case 'vectron':
          const VectronClass = loadVectronConverter();
          const vectronConverter = new VectronClass();

          // Build conversion options from CLI arguments
          const conversionOptions = {};

          // Basic options
          if (options.kassennummer) conversionOptions.kassennummer = options.kassennummer;
          if (options.importMode) conversionOptions.importMode = options.importMode;
          if (options.businessType) conversionOptions.businessType = options.businessType;
          if (options.language) conversionOptions.defaultLanguage = options.language;
          if (options.languages) {
            conversionOptions.supportedLanguages = options.languages.split(',').map(l => l.trim());
          }

          // Phase 2 features
          if (options.includeAuswahlfenster) {
            conversionOptions.features = { ...conversionOptions.features, includeAuswahlfenster: true };
          }
          if (options.includeComplexFields) {
            conversionOptions.features = { ...conversionOptions.features, includeComplexFields: true };
          }
          if (options.includeMultilingual) {
            conversionOptions.language = { ...conversionOptions.language, includeMultilingualFields: true };
          }

          // Validation options
          if (options.strictMode) {
            conversionOptions.validation = { ...conversionOptions.validation, strictMode: true };
          }
          if (options.noValidation) {
            conversionOptions.validateOutput = false;
          }

          // Configuration file or preset
          if (options.config) {
            conversionOptions.configFile = options.config;
          }
          if (options.preset) {
            const { createConfigurationPreset } = require('./converters/vectron/config');
            const presetConfig = createConfigurationPreset(options.preset);
            Object.assign(conversionOptions, presetConfig);
          }

          // Use detailed conversion for Phase 2 features
          conversionResult = vectronConverter.convertWithDetails(config, conversionOptions);

          if (!conversionResult.success) {
            throw new Error(conversionResult.error);
          }

          outputContent = conversionResult.outputBuffer || conversionResult.output;

          if (!outputPath) {
            outputPath = file.replace(/\.json$/i, '-vectron.txt');
          }

          // Show detailed information if verbose
          if (options.verbose) {
            console.log(chalk.cyan('\n📊 Conversion Statistics:'));
            console.log(`  Total lines: ${chalk.bold(conversionResult.stats.totalLines)}`);
            console.log(`  Header lines: ${chalk.bold(conversionResult.stats.headerLines)}`);
            console.log(`  Warengruppen lines: ${chalk.bold(conversionResult.stats.warengruppenLines)}`);
            console.log(`  PLU lines: ${chalk.bold(conversionResult.stats.pluLines)}`);
            if (conversionResult.stats.auswahlfensterLines > 0) {
              console.log(`  Auswahlfenster lines: ${chalk.bold(conversionResult.stats.auswahlfensterLines)}`);
            }

            console.log(chalk.cyan('\n🔧 Features Used:'));
            Object.entries(conversionResult.stats.featuresUsed || {}).forEach(([feature, enabled]) => {
              if (enabled) {
                console.log(`  ${chalk.green('✓')} ${feature}`);
              }
            });

            if (conversionResult.validation && conversionResult.validation.warnings.length > 0) {
              console.log(chalk.yellow('\n⚠️  Warnings:'));
              conversionResult.validation.warnings.forEach(warning => {
                console.log(`  ${chalk.yellow('•')} ${warning}`);
              });
            }
          }

          break;
        // Add other formats like CSV or XML here if needed in the future
        default:
          console.error(chalk.red(`❌ Unsupported format: ${options.format}`));
          process.exit(1);
      }

      await fs.writeFile(outputPath, outputContent);
      console.log(chalk.green(`✅ Conversion successful! Output saved to: ${outputPath}`));

      // Show metadata if available
      if (conversionResult && conversionResult.metadata && options.verbose) {
        console.log(chalk.cyan('\n📋 Conversion Metadata:'));
        console.log(`  Converter version: ${conversionResult.metadata.converterVersion}`);
        console.log(`  Business type: ${conversionResult.metadata.configuration.businessType}`);
        console.log(`  Primary language: ${conversionResult.metadata.configuration.primaryLanguage}`);
        console.log(`  Supported languages: ${conversionResult.metadata.configuration.supportedLanguages.join(', ')}`);
      }

    } catch (error) {
      console.error(chalk.red(`❌ Error during conversion: ${error.message}`));
      if (options.verbose) {
        console.error(chalk.gray(error.stack));
      }
      process.exit(1);
    }
  }

  /**
   * Main menu parsing command
   *
   */
  async parseMenuCommand(inputs, options) {
    console.log(chalk.blue('🍽️  eckasse Menu Parser v2.0.0\n'));
    const spinner = loadOra()('Initializing menu parser...').start();

    try {
      // Handle multiple input files
      const inputFiles = Array.isArray(inputs) ? inputs : [inputs];

      // Verify all files exist
      for (const inputFile of inputFiles) {
        await fs.access(inputFile);
        console.log('✓ Input file exists:', inputFile);
      }

      // Load existing configuration if appending
      let existingConfig = null;
      if (options.append) {
        try {
          const existingData = await fs.readFile(options.append, 'utf8');
          existingConfig = JSON.parse(existingData);
          console.log(`✓ Loaded existing configuration: ${options.append}`);
          console.log(`  Existing items: ${this.countItemsInConfig(existingConfig)}`);
          console.log(`  Existing categories: ${this.countCategoriesInConfig(existingConfig)}`);
        } catch (error) {
          console.log(chalk.yellow(`⚠️  Could not load existing config: ${error.message}`));
          console.log('   Creating new configuration instead...');
        }
      }

      console.log('📝 Creating parser with options:', {
        businessType: options.businessType,
        defaultLanguage: options.language,
        supportedLanguages: options.languages.split(','),
        enableValidation: options.validate,
        llmProvider: options.llmProvider,
        fileCount: inputFiles.length,
        appendMode: !!options.append,
        batchDelay: `${options.batchDelay}s`
      });

      const MenuParserClass = loadMenuParser();
      const parser = new MenuParserClass({
        businessType: options.businessType,
        defaultLanguage: options.language,
        supportedLanguages: options.languages.split(','),
        enableValidation: options.validate,
        llmProvider: options.llmProvider
      });

      console.log('✓ Parser created successfully');

      const parseOptions = {
        businessType: options.businessType,
        language: options.language,
        restaurantName: options.restaurantName
      };

      let finalResult;

      if (inputFiles.length === 1) {
        // Single file processing
        spinner.text = 'Processing menu file...';
        finalResult = await parser.parseMenu(inputFiles[0], parseOptions);
      } else {
        // Batch processing with delays
        spinner.text = `Processing ${inputFiles.length} files with ${options.batchDelay}s delay...`;
        finalResult = await this.processBatchFiles(parser, inputFiles, parseOptions, options, spinner);
      }

      // Merge with existing config if appending
      if (existingConfig) {
        finalResult = await this.mergeConfigurations(existingConfig, finalResult, options);
      }

      spinner.succeed('Menu parsed successfully!');

      console.log(chalk.green('\n📊 Parsing Results:'));
      console.log(`   Items found: ${chalk.bold(finalResult.metadata.itemsFound)}`);
      console.log(`   Categories: ${chalk.bold(finalResult.metadata.categoriesFound)}`);
      console.log(`   Confidence: ${chalk.bold((finalResult.metadata.confidence * 100).toFixed(1))}%`);
      console.log(`   Language: ${chalk.bold(finalResult.metadata.language)}`);
      if (existingConfig) {
        console.log(chalk.blue(`   Mode: Appended to existing configuration`));
      }

      // Save raw JSON output for debugging if requested
      if (options.rawJsonOutput && finalResult.rawData) {
        try {
          await fs.writeFile(options.rawJsonOutput, JSON.stringify(finalResult.rawData.parsedData, null, 2));
          console.log(chalk.blue(`\n🔍 Raw JSON output saved: ${options.rawJsonOutput}`));
        } catch (error) {
          console.log(chalk.yellow(`\n⚠️  Warning: Could not save raw JSON output: ${error.message}`));
        }
      }

      if (finalResult.metadata.confidence < parseFloat(options.confidenceThreshold)) {
        console.log(chalk.yellow(`\n⚠️  Warning: Confidence below threshold (${options.confidenceThreshold})`));
        if (options.interactive) {
          const inquirer = (await import('inquirer')).default;
          const { proceed } = await inquirer.prompt([{
            type: 'confirm',
            name: 'proceed',
            message: 'Confidence is low. Do you want to review and correct the results?',
            default: true
          }]);
          if (proceed) {
            await this.interactiveCorrection(finalResult.configuration);
          }
        }
      }

      // Generate smart output filename if not specified
      let outputPath = options.output;
      if (!outputPath) {
        const restaurantName = options.restaurantName || 'Restaurant';
        const sanitizedName = restaurantName.replace(/[^a-zA-Z0-9]/g, '_');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
        const fileCount = inputFiles.length > 1 ? `_${inputFiles.length}files` : '';
        outputPath = `menu_outputs/${sanitizedName}_${timestamp}${fileCount}.json`;
      }

      await fs.writeFile(outputPath, JSON.stringify(finalResult.configuration, null, 2));
      console.log(chalk.green(`\n💾 Configuration saved: ${outputPath}`));

      if (options.vectron) {
        await this.generateVectronExport(finalResult.configuration, outputPath);
      }

      if (options.csv) {
        await this.generateCSVExport(finalResult.configuration, outputPath);
      }

      if (options.validate) {
        await this.validateConfiguration(finalResult.configuration);
      }

      console.log(chalk.green('\n✅ Menu parsing completed successfully!'));
      console.log(chalk.gray('Next steps:'));
      console.log(chalk.gray('  1. Review the generated configuration'));
      console.log(chalk.gray('  2. Make any necessary adjustments'));
      console.log(chalk.gray('  3. Deploy to your POS system'));

    } catch (error) {
      spinner.fail('Menu parsing failed');
      console.error(chalk.red(`\n❌ Error: ${error.message}`));

      if (error.message.includes('API key')) {
        console.log(chalk.yellow('\n💡 Tip: Make sure to set your LLM API keys:'));
        console.log(chalk.gray('   export GEMINI_API_KEY=your_api_key'));
        console.log(chalk.gray('   export OPENAI_API_KEY=your_api_key'));
        console.log(chalk.gray('   export ANTHROPIC_API_KEY=your_api_key'));
      }

      process.exit(1);
    }
  }

  /**
   * Show configuration file information
   */
  async showConfigInfo(filePath) {
    console.log(chalk.blue(`ℹ️  Configuration Information for: ${filePath}`));
    try {
      const configContent = await fs.readFile(filePath, 'utf8');
      const config = JSON.parse(configContent);

      // Show basic info
      this.showConfigStats(config);

      // Validate against schema
      try {
        await this.validateConfiguration(config);
      } catch (error) {
        console.log(chalk.yellow('\n⚠️  Note: Configuration has validation issues'));
      }

    } catch (error) {
      console.error(chalk.red(`❌ Error reading configuration: ${error.message}`));
      process.exit(1);
    }
  }

  /**
   * Interactive setup wizard (placeholder)
   */
  async interactiveSetup() {
    console.log(chalk.blue('🔧 Interactive Setup Wizard'));
    console.log(chalk.yellow('⚠️  This feature is not yet implemented'));
    console.log(chalk.gray('Use the generate command to create a sample configuration instead:'));
    console.log(chalk.gray('  eckasse generate --output config.json'));
  }

  /**
   * Interactive correction wizard (placeholder)
   */
  async interactiveCorrection(configuration) {
    console.log(chalk.blue('🔧 Interactive Correction Wizard'));
    console.log(chalk.yellow('⚠️  This feature is not yet implemented'));
    console.log(chalk.gray('Please review the configuration manually'));
  }

  /**
   * Generate Vectron export (placeholder)
   */
  async generateVectronExport(configuration, outputPath) {
    console.log(chalk.blue('📄 Generating Vectron export...'));
    try {
      const vectronPath = outputPath.replace(/\.json$/i, '-vectron.txt');
      await this.convertConfig(outputPath, { format: 'vectron', output: vectronPath });
      console.log(chalk.green(`✅ Vectron export saved: ${vectronPath}`));
    } catch (error) {
      console.log(chalk.yellow(`⚠️  Could not generate Vectron export: ${error.message}`));
    }
  }

  /**
   * Generate CSV export (placeholder)
   */
  async generateCSVExport(configuration, outputPath) {
    console.log(chalk.blue('📄 Generating CSV export...'));
    console.log(chalk.yellow('⚠️  CSV export is not yet implemented'));
    console.log(chalk.gray('Use the convert command with --format csv when available'));
  }

  /**
   * Import OOP-POS-MDF command implementation
   */
  async importMdfCommand(filepath, options) {
    console.log(chalk.blue('📥 eckasse OOP-POS-MDF Import Tool v2.0.0\n'));

    try {
      // Check if file exists
      try {
        await fs.access(filepath);
      } catch (error) {
        console.error(chalk.red(`❌ File not found: ${filepath}`));
        process.exit(1);
      }

      // Read and parse JSON file
      console.log(chalk.blue(`📖 Reading configuration file: ${filepath}`));
      const fileContent = await fs.readFile(filepath, 'utf8');

      let jsonData;
      try {
        jsonData = JSON.parse(fileContent);
      } catch (parseError) {
        console.error(chalk.red(`❌ Invalid JSON format: ${parseError.message}`));
        process.exit(1);
      }

      // Validate schema if requested
      if (options.validate) {
        console.log(chalk.blue('🔍 Validating against schema...'));
        try {
          const schema = await this.loadSchema('2.0.0');
          const validate = this.ajv.compile(schema);
          const valid = validate(jsonData);

          if (!valid) {
            console.log(chalk.red('❌ Schema validation failed:'));
            validate.errors.slice(0, 5).forEach((error, index) => {
              console.log(chalk.red(`  ${index + 1}. ${error.instancePath || 'root'}: ${error.message}`));
            });
            if (validate.errors.length > 5) {
              console.log(chalk.gray(`  ... and ${validate.errors.length - 5} more errors`));
            }
            process.exit(1);
          }
          console.log(chalk.green('✅ Schema validation passed'));
        } catch (validationError) {
          console.error(chalk.red(`❌ Validation error: ${validationError.message}`));
          process.exit(1);
        }
      }

      // Show preview information
      const companyName = jsonData.company_details?.company_full_name || 'Unknown Company';
      const branchCount = jsonData.company_details?.branches?.length || 0;
      let totalItems = 0;
      let totalCategories = 0;

      if (jsonData.company_details?.branches) {
        for (const branch of jsonData.company_details.branches) {
          if (branch.point_of_sale_devices) {
            for (const pos of branch.point_of_sale_devices) {
              totalItems += pos.items_for_this_pos?.length || 0;
              totalCategories += pos.categories_for_this_pos?.length || 0;
            }
          }
        }
      }

      console.log(chalk.cyan('\n📋 Import Preview:'));
      console.log(`   Company: ${chalk.bold(companyName)}`);
      console.log(`   Branches: ${chalk.bold(branchCount)}`);
      console.log(`   Categories: ${chalk.bold(totalCategories)}`);
      console.log(`   Items: ${chalk.bold(totalItems)}`);

      // Dry run mode
      if (options.dryRun) {
        console.log(chalk.green('\n✅ Dry run completed - JSON structure is valid'));
        console.log(chalk.gray('Use --validate flag to also check schema compliance'));
        return;
      }

      // Confirmation prompt (unless --force)
      if (!options.force) {
        console.log(chalk.yellow('\n⚠️  WARNING: This operation will:'));
        console.log(chalk.yellow('   • Delete ALL existing data in the database'));
        console.log(chalk.yellow('   • Import the new configuration'));
        console.log(chalk.yellow('   • Generate vector embeddings for all items'));
        console.log(chalk.yellow('   • This action cannot be undone!'));

        const inquirer = (await import('inquirer')).default;
        const { confirmed } = await inquirer.prompt([{
          type: 'confirm',
          name: 'confirmed',
          message: 'Are you sure you want to proceed?',
          default: false
        }]);

        if (!confirmed) {
          console.log(chalk.gray('\nImport cancelled by user'));
          return;
        }
      }

      // Perform the import
      const spinner = loadOra()('Importing data and generating embeddings...').start();

      try {
        const importFn = loadImportService();
        const result = await importFn(jsonData);

        spinner.succeed('Import completed successfully!');

        console.log(chalk.green('\n📊 Import Results:'));
        console.log(`   Companies: ${chalk.bold(result.stats.companies)}`);
        console.log(`   Branches: ${chalk.bold(result.stats.branches)}`);
        console.log(`   POS Devices: ${chalk.bold(result.stats.posDevices)}`);
        console.log(`   Categories: ${chalk.bold(result.stats.categories)}`);
        console.log(`   Items: ${chalk.bold(result.stats.items)}`);
        console.log(`   Embeddings: ${chalk.bold(result.stats.embeddings)}`);
        console.log(`   Duration: ${chalk.bold(result.duration)}ms`);

        if (result.stats.errors && result.stats.errors.length > 0) {
          console.log(chalk.yellow(`\n⚠️  Warnings (${result.stats.errors.length}):`));
          result.stats.errors.slice(0, 3).forEach((error, index) => {
            console.log(chalk.yellow(`   ${index + 1}. ${error}`));
          });
          if (result.stats.errors.length > 3) {
            console.log(chalk.gray(`   ... and ${result.stats.errors.length - 3} more warnings`));
          }
        }

        console.log(chalk.green('\n✅ Import completed successfully!'));
        console.log(chalk.gray('The database is now ready for hybrid search operations.'));
        
        // Graceful exit for successful import
        await gracefulExit(0);

      } catch (importError) {
        spinner.fail('Import failed');
        console.error(chalk.red(`\n❌ Import error: ${importError.message}`));

        if (importError.message.includes('GEMINI_API_KEY')) {
          console.log(chalk.yellow('\n💡 Tip: Make sure your Gemini API key is configured:'));
          console.log(chalk.gray('   export GEMINI_API_KEY=your_api_key'));
          console.log(chalk.gray('   Or add it to your .env file'));
        }

        await gracefulExit(1);
      }

    } catch (error) {
      console.error(chalk.red(`\n❌ Command failed: ${error.message}`));
      await gracefulExit(1);
    }
  }

  /**
   * Process multiple files in batch with delays to avoid rate limits
   */
  async processBatchFiles(parser, files, parseOptions, options, spinner) {
    const results = [];
    const batchDelay = parseInt(options.batchDelay) * 1000;

    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const fileNum = i + 1;

      try {
        spinner.text = `Processing file ${fileNum}/${files.length}: ${path.basename(file)}`;
        console.log(`\n🔄 Processing ${fileNum}/${files.length}: ${file}`);

        const result = await parser.parseMenu(file, parseOptions);
        results.push(result);

        console.log(`✅ File ${fileNum} completed: ${result.metadata.itemsFound} items, ${result.metadata.categoriesFound} categories`);

        // Add delay between files (except for last file)
        if (i < files.length - 1) {
          console.log(`⏳ Waiting ${options.batchDelay}s before next file...`);
          await new Promise(resolve => setTimeout(resolve, batchDelay));
        }

      } catch (error) {
        console.log(chalk.red(`❌ Failed to process file ${fileNum}: ${error.message}`));

        if (error.message.includes('quota') || error.message.includes('limit') || error.message.includes('429')) {
          console.log(chalk.yellow('\n⚠️  Rate limit detected! Options:'));
          console.log(chalk.yellow('   1. Wait and run again with --append to continue'));
          console.log(chalk.yellow('   2. Increase --batch-delay'));
          console.log(chalk.yellow(`   3. Use this command to continue: --append menu_outputs/[generated_file].json`));

          // Save partial results if we have any
          if (results.length > 0) {
            const partialResult = await this.combineResults(results, parseOptions);
            const partialPath = this.generatePartialPath(options, results.length);
            await fs.writeFile(partialPath, JSON.stringify(partialResult.configuration, null, 2));
            console.log(chalk.blue(`💾 Partial results saved: ${partialPath}`));
          }
        }

        throw error;
      }
    }

    // Combine all results
    return await this.combineResults(results, parseOptions);
  }

  /**
   * Combine multiple parsing results into one configuration
   */
  async combineResults(results, parseOptions) {
    if (results.length === 1) {
      return results[0];
    }

    // Merge all categories and items
    const allCategories = [];
    const allItems = [];
    let totalConfidence = 0;

    for (const result of results) {
      if (result.rawData && result.rawData.parsedData) {
        if (result.rawData.parsedData.categories) {
          allCategories.push(...result.rawData.parsedData.categories);
        }
        if (result.rawData.parsedData.items) {
          allItems.push(...result.rawData.parsedData.items);
        }
        totalConfidence += result.metadata.confidence || 0;
      }
    }

    // Create combined parsed data
    const combinedParsedData = {
      restaurant_info: results[0].rawData?.parsedData?.restaurant_info || { name: parseOptions.restaurantName },
      categories: allCategories,
      items: allItems,
      confidence: totalConfidence / results.length
    };

    // Use the parser to convert combined data to OOP-POS-MDF
    const MenuParserClass = loadMenuParser();
    const parser = new MenuParserClass({});
    const configuration = await parser.convertToOOPPOSMDF(combinedParsedData, parseOptions);

    return {
      success: true,
      requestId: results[0].requestId,
      configuration,
      metadata: {
        itemsFound: allItems.length,
        categoriesFound: allCategories.length,
        confidence: totalConfidence / results.length,
        language: parseOptions.language,
        processingTime: Date.now(),
        batchFiles: results.length
      },
      rawData: {
        inputType: 'batch',
        parsedData: combinedParsedData,
        individualResults: results.map(r => ({
          items: r.metadata.itemsFound,
          categories: r.metadata.categoriesFound,
          confidence: r.metadata.confidence
        }))
      }
    };
  }

  /**
   * Merge new results with existing configuration
   */
  async mergeConfigurations(existingConfig, newResult, options) {
    // Extract existing items and categories
    const existingItems = [];
    const existingCategories = [];

    if (existingConfig.company_details?.branches) {
      for (const branch of existingConfig.company_details.branches) {
        if (branch.pos_devices) {
          for (const device of branch.pos_devices) {
            if (device.categories) existingCategories.push(...device.categories);
            if (device.items) existingItems.push(...device.items);
          }
        }
      }
    }

    // Combine with new data
    const newCategories = [];
    const newItems = [];

    if (newResult.configuration.company_details?.branches) {
      for (const branch of newResult.configuration.company_details.branches) {
        if (branch.pos_devices) {
          for (const device of branch.pos_devices) {
            if (device.categories) newCategories.push(...device.categories);
            if (device.items) newItems.push(...device.items);
          }
        }
      }
    }

    // Merge categories (avoid duplicates by name)
    const mergedCategories = [...existingCategories];
    for (const newCat of newCategories) {
      const exists = existingCategories.find(cat =>
        cat.multilingual_object?.de?.name === newCat.multilingual_object?.de?.name
      );
      if (!exists) {
        mergedCategories.push(newCat);
      }
    }

    // Merge items (avoid duplicates by name)
    const mergedItems = [...existingItems];
    for (const newItem of newItems) {
      const exists = existingItems.find(item =>
        item.multilingual_object?.de?.name === newItem.multilingual_object?.de?.name
      );
      if (!exists) {
        mergedItems.push(newItem);
      }
    }

    // Update the configuration
    const mergedConfig = JSON.parse(JSON.stringify(newResult.configuration));
    if (mergedConfig.company_details?.branches?.[0]?.pos_devices?.[0]) {
      mergedConfig.company_details.branches[0].pos_devices[0].categories = mergedCategories;
      mergedConfig.company_details.branches[0].pos_devices[0].items = mergedItems;
    }

    // Update metadata
    const mergedResult = {
      ...newResult,
      configuration: mergedConfig,
      metadata: {
        ...newResult.metadata,
        itemsFound: mergedItems.length,
        categoriesFound: mergedCategories.length,
        merged: true,
        previousItems: existingItems.length,
        newItems: newItems.length
      }
    };

    return mergedResult;
  }

  /**
   * Count items in configuration
   */
  countItemsInConfig(config) {
    let count = 0;
    if (config.company_details?.branches) {
      for (const branch of config.company_details.branches) {
        if (branch.point_of_sale_devices) {
          for (const device of branch.point_of_sale_devices) {
            count += device.items_for_this_pos?.length || 0;
          }
        }
      }
    }
    return count;
  }

  /**
   * Count categories in configuration
   */
  countCategoriesInConfig(config) {
    let count = 0;
    if (config.company_details?.branches) {
      for (const branch of config.company_details.branches) {
        if (branch.point_of_sale_devices) {
          for (const device of branch.point_of_sale_devices) {
            count += device.categories_for_this_pos?.length || 0;
          }
        }
      }
    }
    return count;
  }

  /**
   * Count enriched items in configuration
   * An item is considered enriched if it has AI-generated enrichment data
   */
  countEnrichedItemsInConfig(config) {
    let count = 0;
    if (config.company_details?.branches) {
      for (const branch of config.company_details.branches) {
        if (branch.point_of_sale_devices) {
          for (const device of branch.point_of_sale_devices) {
            if (device.items_for_this_pos) {
              for (const item of device.items_for_this_pos) {
                // Check if item has enrichment data
                if (item.additional_item_attributes?.ai_enrichment) {
                  count++;
                }
              }
            }
          }
        }
      }
    }
    return count;
  }

  /**
   * Check if an item has enrichment data
   * An item is considered enriched if it has AI-generated data like:
   * - Extended descriptions
   * - Allergen information
   * - Nutritional data
   * - Enhanced metadata
   */
  isItemEnriched(item) {
    // Check for enrichment indicators
    if (item.enrichment_metadata) {
      return true;
    }
    
    // Check for AI-generated extended descriptions
    if (item.multilingual_object) {
      for (const lang in item.multilingual_object) {
        const langObj = item.multilingual_object[lang];
        if (langObj.extended_description || langObj.ai_generated_description) {
          return true;
        }
      }
    }
    
    // Check for allergen information (often AI-generated)
    if (item.allergen_information && item.allergen_information.length > 0) {
      return true;
    }
    
    // Check for nutritional information (often AI-generated)
    if (item.nutritional_information && 
        (item.nutritional_information.calories || 
         item.nutritional_information.protein || 
         item.nutritional_information.carbs || 
         item.nutritional_information.fat)) {
      return true;
    }
    
    // Check for enhanced metadata fields
    if (item.meta_information && 
        (item.meta_information.ai_confidence || 
         item.meta_information.enrichment_source || 
         item.meta_information.enrichment_timestamp)) {
      return true;
    }
    
    return false;
  }

  /**
   * Generate path for partial results
   */
  generatePartialPath(options, processedCount) {
    const restaurantName = options.restaurantName || 'Restaurant';
    const sanitizedName = restaurantName.replace(/[^a-zA-Z0-9]/g, '_');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
    return `menu_outputs/${sanitizedName}_partial_${processedCount}files_${timestamp}.json`;
  }

  /**
   * Export OOP-POS-MDF command implementation
   */
  async exportMdfCommand(outputPath, options) {
    console.log(chalk.blue('📤 eckasse OOP-POS-MDF Export Tool v2.0.0\n'));

    try {
      // Check if database has data to export
      console.log(chalk.blue('🔍 Checking database content...'));
      
      // Perform the export
      const spinner = loadOra()('Exporting database state to oop-pos-mdf format...').start();

      try {
        const exportFn = loadExportService();
        const result = await exportFn({ includeEmbeddings: options.embeddings !== false });

        spinner.succeed('Export completed successfully!');

        // Use provided output path or suggested filename
        const finalOutputPath = outputPath || `menu_outputs/${result.suggestedFilename}`;

        // Check if file exists and handle overwrite
        if (!options.force) {
          try {
            await fs.access(finalOutputPath);
            console.log(chalk.yellow(`\n⚠️  WARNING: File already exists: ${finalOutputPath}`));
            
            const inquirer = (await import('inquirer')).default;
            const { confirmed } = await inquirer.prompt([{
              type: 'confirm',
              name: 'confirmed',
              message: 'Do you want to overwrite the existing file?',
              default: false
            }]);

            if (!confirmed) {
              console.log(chalk.gray('\nExport cancelled by user'));
              return;
            }
          } catch (error) {
            // File doesn't exist, continue with export
          }
        }

        // Create output directory if it doesn't exist
        const outputDir = path.dirname(finalOutputPath);
        await fs.mkdir(outputDir, { recursive: true });

        // Write the exported configuration
        const jsonOutput = options.pretty !== false 
          ? JSON.stringify(result.configuration, null, 2)
          : JSON.stringify(result.configuration);

        await fs.writeFile(finalOutputPath, jsonOutput);

        console.log(chalk.green('\n📊 Export Results:'));
        console.log(`   Companies: ${chalk.bold(result.metadata.stats.companies)}`);
        console.log(`   Branches: ${chalk.bold(result.metadata.stats.branches)}`);
        console.log(`   POS Devices: ${chalk.bold(result.metadata.stats.posDevices)}`);
        console.log(`   Categories: ${chalk.bold(result.metadata.stats.categories)}`);
        console.log(`   Items: ${chalk.bold(result.metadata.stats.items)}`);
        console.log(`   Duration: ${chalk.bold(result.metadata.duration)}ms`);

        console.log(chalk.green(`\n💾 Configuration exported: ${finalOutputPath}`));

        // Validate exported configuration if requested
        if (options.validate) {
          console.log(chalk.blue('\n🔍 Validating exported configuration...'));
          try {
            await this.validateConfiguration(result.configuration);
            console.log(chalk.green('✅ Exported configuration is valid!'));
          } catch (validationError) {
            console.log(chalk.yellow('\n⚠️  Warning: Exported configuration has validation issues'));
            console.log(chalk.gray('This may indicate data inconsistencies in the database'));
          }
        }

        console.log(chalk.green('\n✅ Export completed successfully!'));
        console.log(chalk.gray('Next steps:'));
        console.log(chalk.gray('  1. Review the exported configuration'));
        console.log(chalk.gray('  2. Use for backup or transfer to another system'));
        console.log(chalk.gray('  3. Re-import with: eckasse import-mdf ' + finalOutputPath));
        
        // Graceful exit for successful export
        await gracefulExit(0);

      } catch (exportError) {
        spinner.fail('Export failed');
        console.error(chalk.red(`\n❌ Export error: ${exportError.message}`));

        if (exportError.message.includes('No companies found')) {
          console.log(chalk.yellow('\n💡 Tip: Make sure you have imported data first:'));
          console.log(chalk.gray('   eckasse import-mdf your_config.json'));
        }

        await gracefulExit(1);
      }

    } catch (error) {
      console.error(chalk.red(`\n❌ Command failed: ${error.message}`));
      await gracefulExit(1);
    }
  }

  /**
   * Enrich MDF command implementation
   */
  async enrichMdfCommand(inputFile, options) {
    console.log(chalk.blue('🔬 eckasse MDF Enrichment Tool v2.0.0\n'));

    try {
      // Check if input file exists
      try {
        await fs.access(inputFile);
      } catch (error) {
        console.error(chalk.red(`❌ Input file not found: ${inputFile}`));
        process.exit(1);
      }

      // Read and parse input file
      console.log(chalk.blue(`📖 Reading input file: ${inputFile}`));
      const fileContent = await fs.readFile(inputFile, 'utf8');

      let mdfData;
      try {
        mdfData = JSON.parse(fileContent);
      } catch (parseError) {
        console.error(chalk.red(`❌ Invalid JSON format: ${parseError.message}`));
        process.exit(1);
      }

      // Validate input file if requested
      if (options.validate) {
        console.log(chalk.blue('🔍 Validating input file against schema...'));
        try {
          await this.validateConfiguration(mdfData);
          console.log(chalk.green('✅ Input file validation passed'));
        } catch (validationError) {
          console.log(chalk.yellow('⚠️  Input file has validation issues but proceeding...'));
        }
      }

      // Show preview of what will be enriched
      const itemsCount = this.countItemsInConfig(mdfData);
      const enrichedItemsCount = this.countEnrichedItemsInConfig(mdfData);
      const categoriesCount = this.countCategoriesInConfig(mdfData);
      
      console.log(chalk.cyan('\n📋 Enrichment Preview:'));
      console.log(`   Total items: ${chalk.bold(itemsCount)}`);
      console.log(`   Already enriched: ${chalk.bold(enrichedItemsCount)}`);
      console.log(`   Items to enrich: ${chalk.bold(itemsCount - enrichedItemsCount)}`);
      console.log(`   Categories to process: ${chalk.bold(categoriesCount)}`);
      console.log(`   Web search: ${options.skipWebSearch ? chalk.gray('Disabled') : chalk.green('Enabled')}`);
      console.log(`   Main groups: ${options.skipMainGroups ? chalk.gray('Disabled') : chalk.green('Enabled')}`);

      // Dry run mode
      if (options.dryRun) {
        console.log(chalk.green('\n✅ Dry run completed - ready for enrichment'));
        console.log(chalk.gray('Remove --dry-run flag to perform actual enrichment'));
        return;
      }

      // Load enrichment service
      const { enrichMdfData } = require('../services/enrichment.service.js');

      // Perform enrichment
      const spinner = loadOra()('Starting multi-pass enrichment process...').start();

      try {
        const enrichmentOptions = {
          skipWebSearch: options.skipWebSearch,
          skipMainGroups: options.skipMainGroups
        };

        const enrichedData = await enrichMdfData(mdfData, enrichmentOptions);
        
        spinner.succeed('Enrichment completed successfully!');

        // Generate output filename if not specified
        let outputPath = options.output;
        if (!outputPath) {
          const inputBasename = path.basename(inputFile, '.json');
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
          outputPath = path.join(path.dirname(inputFile), `${inputBasename}_enriched_${timestamp}.json`);
        }

        // Write enriched data to output file
        await fs.writeFile(outputPath, JSON.stringify(enrichedData, null, 2));

        console.log(chalk.green('\n📊 Enrichment Results:'));
        console.log(`   Total items: ${chalk.bold(this.countItemsInConfig(enrichedData))}`);
        console.log(`   Enriched items: ${chalk.bold(this.countEnrichedItemsInConfig(enrichedData))}`);
        console.log(`   Categories processed: ${chalk.bold(this.countCategoriesInConfig(enrichedData))}`);
        
        // Show main groups if generated
        if (!options.skipMainGroups && enrichedData.company_details?.global_configurations?.main_groups_definitions) {
          const mainGroups = enrichedData.company_details.global_configurations.main_groups_definitions;
          console.log(`   Main groups created: ${chalk.bold(mainGroups.length)}`);
          mainGroups.forEach((group, index) => {
            console.log(`     ${index + 1}. ${chalk.gray(group.main_group_names?.de || 'Unknown')}`);
          });
        }

        console.log(chalk.green(`\n💾 Enriched data saved: ${outputPath}`));

        console.log(chalk.green('\n✅ Enrichment completed successfully!'));
        console.log(chalk.gray('Next steps:'));
        console.log(chalk.gray('  1. Review the enriched configuration'));
        console.log(chalk.gray('  2. Import with: eckasse import-mdf ' + outputPath));
        console.log(chalk.gray('  3. Convert to other formats if needed'));
        
        // Graceful exit for successful enrichment
        await gracefulExit(0);

      } catch (enrichmentError) {
        spinner.fail('Enrichment failed');
        console.error(chalk.red(`\n❌ Enrichment error: ${enrichmentError.message}`));

        if (enrichmentError.message.includes('GEMINI_API_KEY') || enrichmentError.message.includes('API key')) {
          console.log(chalk.yellow('\n💡 Tip: Make sure your LLM API key is configured:'));
          console.log(chalk.gray('   export GEMINI_API_KEY=your_api_key'));
          console.log(chalk.gray('   Or add it to your .env file'));
        }

        await gracefulExit(1);
      }

    } catch (error) {
      console.error(chalk.red(`\n❌ Command failed: ${error.message}`));
      await gracefulExit(1);
    }
  }

  // Additional methods like menuWizard, interactiveCorrection, generateVectronExport, generateCSVExport would be implemented here
}

// Signal handlers for graceful shutdown
process.on('SIGINT', async () => {
  console.log(chalk.yellow('\n⚠️  Received interrupt signal. Cleaning up...'));
  await gracefulExit(130); // 128 + 2 (SIGINT)
});

process.on('SIGTERM', async () => {
  console.log(chalk.yellow('\n⚠️  Received termination signal. Cleaning up...'));
  await gracefulExit(143); // 128 + 15 (SIGTERM)
});

// Handle uncaught exceptions
process.on('uncaughtException', async (error) => {
  console.error(chalk.red('\n💥 Uncaught Exception:'), error);
  await gracefulExit(1);
});

process.on('unhandledRejection', async (reason, promise) => {
  console.error(chalk.red('\n💥 Unhandled Promise Rejection:'), reason);
  await gracefulExit(1);
});

// Initialize CLI if this file is run directly
if (require.main === module) {
  new EckasseCLI();
}

module.exports = EckasseCLI;

--- File: /packages/backend/src/lib/converters/vectron-legacy.js ---

// lib/converters/vectron.js
const iconv = require('iconv-lite');

// --- Внутренняя "База Данных" Известных Vectron Команд и Маппингов ---
const VECTRON_COMMANDS = {
  HEADER_LINE_TYPE: 100,
  WARENGRUPPE_LINE_TYPE: 102,
  PLU_LINE_TYPE: 101,
  AUSWAHLFENSTER_LINE_TYPE: 152,

  // Общие поля
  FIELD_ID_NAME1: 101, // Name 1 (PLU, WG, Auswahlfenster)
  FIELD_ID_NAME2: 102, // Name 2 (PLU Kurzname / button_display_name)
  FIELD_ID_PRICE1: 201, // Preis 1
  FIELD_ID_WARENGRUPPE_LINK: 301, // Verknüpfвание с товарной группой
  FIELD_ID_HAUPTGRUPPE_LINK: 311, // Verknüpfвание с основной группой 1
  FIELD_ID_STEUER_LINK: 401, // Verknüpfвание с налогом
  FIELD_ID_INAKTIV_FLAG: 9001, // "Inaktiv"-Flag (0=aktiv, 1=inaktiv)
  FIELD_ID_KEIN_VERKAUF_FLAG: 1003, // "Kein Verkauf"-Flag (1=kein Verkauf)
  FIELD_ID_NEGATIV_FLAG: 901, // "Negativ"-Flag (0=не отрицательный, 1=отрицательный)

  // Header-специфичные поля
  HEADER_FIELD_ID_INTERFACE_VERSION: 1, // Версия интерфейса данных (всегда 1)
  HEADER_FIELD_ID_KASSEN_NUMMER: 10, // Номер кассы
  HEADER_FIELD_ID_IMPORT_MODUS: 24, // Режим импорта (A=Add/Update)
  HEADER_FIELD_ID_CHAR_ENCODING: 51, // Кодировка символов (1=ANSI/Windows-1252)

  // Значения по умолчанию для Vectron-полей
  DEFAULT_IMPORT_MODE: 'A', // Add/Update
  DEFAULT_CHAR_ENCODING: 1, // ANSI (Windows-1252)
  DEFAULT_PLU_ACTIVE: 0, // 0 = активен
  DEFAULT_PLU_INACTIVE: 1, // 1 = неактивен
  DEFAULT_PLU_NOT_NEGATIVE: 0, // 0 = не отрицательный
  DEFAULT_PLU_IS_NEGATIVE: 1, // 1 = отрицательный
  DEFAULT_PLU_CAN_BE_SOLD: 0, // 0 = продается
  DEFAULT_PLU_CANNOT_BE_SOLD: 1, // 1 = не продается
};

class VectronConverter {
  /**
   * Конвертирует конфигурацию OOP-POS-MDF v2.0.0 в формат импорта Vectron.
   * @param {object} oopPosMdfJson - Конфигурация в формате OOP-POS-MDF v2.0.0.
   * @returns {Buffer} Буфер с данными для импорта Vectron в кодировке Windows-1252.
   */
  convert(oopPosMdfJson) {
    const vectronLines = [];

    const companyDetails = oopPosMdfJson.company_details;
    if (!companyDetails || !companyDetails.branches || companyDetails.branches.length === 0) {
      throw new Error("Invalid OOP-POS-MDF structure: No company or branches found.");
    }
    const branch = companyDetails.branches[0];
    if (!branch.point_of_sale_devices || branch.point_of_sale_devices.length === 0) {
      throw new Error("Invalid OOP-POS-MDF structure: No POS devices found in the first branch.");
    }
    const posDevice = branch.point_of_sale_devices[0];
    const defaultLanguage = companyDetails.meta_information.default_language || 'de';

    // --- 1. Header-Zeile (LineType 100) ---
    const kassenNummer = posDevice.pos_device_external_number;
    const header = `${VECTRON_COMMANDS.HEADER_LINE_TYPE},0,` +
                   `${VECTRON_COMMANDS.HEADER_FIELD_ID_INTERFACE_VERSION},1;` +
                   `${VECTRON_COMMANDS.HEADER_FIELD_ID_KASSEN_NUMMER},${kassenNummer};` +
                   `${VECTRON_COMMANDS.HEADER_FIELD_ID_IMPORT_MODUS},${VECTRON_COMMANDS.DEFAULT_IMPORT_MODE};` +
                   `${VECTRON_COMMANDS.HEADER_FIELD_ID_CHAR_ENCODING},${VECTRON_COMMANDS.DEFAULT_CHAR_ENCODING};`;
    vectronLines.push(header);

    // --- 2. Warengruppen (LineType 102) ---
    for (const category of posDevice.categories_for_this_pos) {
      const categoryName = category.category_names?.[defaultLanguage] || category.category_names?.[Object.keys(category.category_names)[0]] || 'Unknown Category';
      const wgLine = `${VECTRON_COMMANDS.WARENGRUPPE_LINE_TYPE},${category.category_unique_identifier},` +
                     `${VECTRON_COMMANDS.FIELD_ID_NAME1},TX:"${categoryName}";`;
      vectronLines.push(wgLine);
    }

    // --- 3. Items (PLUs) (LineType 101) ---
    for (const item of posDevice.items_for_this_pos) {
      const category = posDevice.categories_for_this_pos.find(
        cat => cat.category_unique_identifier === item.associated_category_unique_identifier
      );
      if (!category) {
        console.warn(`WARN: Item ${item.item_unique_identifier} has no matching category. Skipping PLU import for this item.`);
        continue;
      }

      const menuDisplayName = item.display_names?.menu?.[defaultLanguage] || 'Unknown Menu Item';
      const buttonDisplayName = item.display_names?.button?.[defaultLanguage] || 'Unknown Button Name';

      const mainGroup = category.default_linked_main_group_unique_identifier;
      let taxRate = '';
      if (category.category_type === 'drink') {
        taxRate = posDevice.pos_device_settings.default_linked_drink_tax_rate_unique_identifier;
      } else if (category.category_type === 'food') {
        taxRate = posDevice.pos_device_settings.default_linked_food_tax_rate_unique_identifier;
      } else {
        taxRate = posDevice.pos_device_settings.default_linked_food_tax_rate_unique_identifier;
      }

      let itemLine = `${VECTRON_COMMANDS.PLU_LINE_TYPE},${item.item_unique_identifier},` +
                     `${VECTRON_COMMANDS.FIELD_ID_NAME1},TX:"${menuDisplayName}";` +
                     `${VECTRON_COMMANDS.FIELD_ID_NAME2},TX:"${buttonDisplayName}";` +
                     `${VECTRON_COMMANDS.FIELD_ID_PRICE1},VA:${item.item_price_value.toFixed(2)};` +
                     `${VECTRON_COMMANDS.FIELD_ID_WARENGRUPPE_LINK},NR:${category.category_unique_identifier};` +
                     `${VECTRON_COMMANDS.FIELD_ID_HAUPTGRUPPE_LINK},NR:${mainGroup};` +
                     `${VECTRON_COMMANDS.FIELD_ID_STEUER_LINK},NR:${taxRate};`;
      
      // Flags
      if (item.item_flags && !item.item_flags.is_sellable) {
        itemLine += `${VECTRON_COMMANDS.FIELD_ID_KEIN_VERKAUF_FLAG},NR:${VECTRON_COMMANDS.DEFAULT_PLU_CANNOT_BE_SOLD};`;
      } else {
        itemLine += `${VECTRON_COMMANDS.FIELD_ID_KEIN_VERKAUF_FLAG},NR:${VECTRON_COMMANDS.DEFAULT_PLU_CAN_BE_SOLD};`;
      }
      itemLine += `${VECTRON_COMMANDS.FIELD_ID_INAKTIV_FLAG},NR:${VECTRON_COMMANDS.DEFAULT_PLU_ACTIVE}`; 

      if (item.item_flags && item.item_flags.has_negative_price) {
          itemLine += `;${VECTRON_COMMANDS.FIELD_ID_NEGATIV_FLAG},NR:${VECTRON_COMMANDS.DEFAULT_PLU_IS_NEGATIVE}`;
      } else {
          itemLine += `;${VECTRON_COMMANDS.FIELD_ID_NEGATIV_FLAG},NR:${VECTRON_COMMANDS.DEFAULT_PLU_NOT_NEGATIVE}`;
      }
      
      vectronLines.push(itemLine);
    }

    // --- 4. Display Layouts (Auswahlfenster) (LineType 152) ---
    // Для кнопок категорий, как было в вашем первоначальном проекте.
    // Обратите внимание, что это очень упрощенная конвертация UI-элементов.
    // Полная настройка UI в Vectron Commander требует сложной логики маппинга.
    const mainLayout = posDevice.built_in_displays?.[0]?.display_activities?.[0]?.user_interface_elements?.find(
        elem => elem.element_type === 'CATEGORY_NAVIGATION_PANEL'
    );

    if (mainLayout && mainLayout.button_configurations) {
        for (const buttonConfig of mainLayout.button_configurations) {
            // Пропускаем разделители, если они есть
            if (buttonConfig.element_type === 'SEPARATOR_BUTTON') {
                const separatorText = buttonConfig.button_texts?.[defaultLanguage] || '---SEPARATOR---';
                // LineType 152 для текстовых кнопок или разделителей, если нет linked_category
                // ID может быть условным или генерироваться. Для простоты, используем ID кнопки.
                // Хотя 152 LineType обычно для выборки, а не для самих кнопок.
                // В Vectron Data Interface DE Assembled.json нет явного маппинга для separator_button.
                // Это, вероятно, потребует кастомной обработки или ручной настройки в VC.
                // Для импорта текстовых кнопок можно использовать LineType 156 (Administrative masks)
                // или LineType 151 (Infotexts), но это зависит от конкретных требований.
                // Для простоты, оставим как в оригинальном коде, зная, что это может быть не идеально.
                const separatorLine = `${VECTRON_COMMANDS.AUSWAHLFENSTER_LINE_TYPE},${buttonConfig.button_unique_identifier},` +
                                      `${VECTRON_COMMANDS.FIELD_ID_NAME1},TX:"${separatorText}";`;
                vectronLines.push(separatorLine);
                continue;
            }

            const buttonText = buttonConfig.button_texts?.[defaultLanguage] || 'Unknown Button Text';
            // Используем button_unique_identifier как RecordId для LineType 152
            // linked_category_unique_identifier можно использовать в качестве FieldData для поля, которое
            // указывает на связанную категорию, но для LineType 152 в Data Interface DE Assembled.json
            // нет такого прямого маппинга в примерах.
            // Это поле в Vectron обычно настраивается через Field path / access path, а не через логические номера.
            // Поэтому, для простоты, мы экспортируем только название кнопки и ID.
            const buttonLine = `${VECTRON_COMMANDS.AUSWAHLFENSTER_LINE_TYPE},${buttonConfig.button_unique_identifier},` +
                               `${VECTRON_COMMANDS.FIELD_ID_NAME1},TX:"${buttonText}";`;
            vectronLines.push(buttonLine);
        }
    }


    // --- Завершаем файл и кодируем ---
    const outputContent = vectronLines.join('\r\n') + '\r\n';
    return iconv.encode(outputContent, 'windows-1252');
  }
}

module.exports = VectronConverter;

--- File: /packages/backend/src/lib/converters/vectron.js ---

/**
 * Vectron Converter - Updated Implementation
 * 
 * Updated to use the new modular Vectron converter system
 * Legacy implementation backed up to vectron-legacy.js
 * 
 * @module VectronConverter
 */

const NewVectronConverter = require('./vectron/index');

class VectronConverter {
  /**
   * Convert OOP-POS-MDF v2.0.0 configuration to Vectron import format
   * @param {Object} oopPosMdfJson - OOP-POS-MDF v2.0.0 configuration
   * @param {Object} options - Conversion options
   * @returns {Buffer} Vectron import data in Windows-1252 encoding
   */
  convert(oopPosMdfJson, options = {}) {
    try {
      // Use new converter with default options
      const conversionOptions = {
        encoding: 'win1252',
        validateOutput: true,
        strictMode: false,
        ...options
      };
      
      const result = NewVectronConverter.convertToVectron(oopPosMdfJson, conversionOptions);
      
      if (!result.success) {
        throw new Error(result.error || 'Conversion failed');
      }
      
      // Return buffer for compatibility with existing CLI
      if (result.outputBuffer) {
        return result.outputBuffer;
      } else {
        // Fallback to encoding the string output
        const iconv = require('iconv-lite');
        return iconv.encode(result.output, 'win1252');
      }
      
    } catch (error) {
      console.error('Vectron conversion error:', error.message);
      throw error;
    }
  }
  
  /**
   * Convert with additional result information
   * @param {Object} oopPosMdfJson - OOP-POS-MDF v2.0.0 configuration
   * @param {Object} options - Conversion options
   * @returns {Object} Detailed conversion result
   */
  convertWithDetails(oopPosMdfJson, options = {}) {
    const conversionOptions = {
      encoding: 'win1252',
      validateOutput: true,
      strictMode: false,
      ...options
    };
    
    return NewVectronConverter.convertToVectron(oopPosMdfJson, conversionOptions);
  }
  
  /**
   * Convert and save to file
   * @param {Object} oopPosMdfJson - OOP-POS-MDF v2.0.0 configuration
   * @param {string} outputPath - Output file path
   * @param {Object} options - Conversion options
   * @returns {Object} Conversion result
   */
  convertToFile(oopPosMdfJson, outputPath, options = {}) {
    return NewVectronConverter.convertToVectronFile(oopPosMdfJson, outputPath, options);
  }
}

module.exports = VectronConverter;

--- File: /packages/backend/src/lib/converters/vectron/auswahlfenster.js ---

/**
 * Vectron Auswahlfenster Converter (LineType 152)
 * 
 * Converts OOP-POS-MDF display layouts to Vectron Auswahlfenster format
 * See VECTRON_CONVERTER_PLAN.md section 3.4 for details
 * 
 * @module VectronAuswahlfensterConverter
 */

const VectronLineFormatter = require('./utils/formatter');
const { sanitizeText } = require('./utils/encoding');
const VectronFieldMapper = require('./mapping');

/**
 * Convert OOP-POS-MDF display layouts to Vectron Auswahlfenster lines
 * @param {Array} displays - Built-in displays from OOP-POS-MDF
 * @param {Array} categories - Categories from OOP-POS-MDF
 * @param {Array} items - Items from OOP-POS-MDF
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertDisplayLayoutsToAuswahlfenster(displays, categories, items, options = {}) {
  if (!displays || !Array.isArray(displays)) {
    return [];
  }
  
  const formatter = new VectronLineFormatter();
  const mapper = new VectronFieldMapper(options);
  const defaultLanguage = options.defaultLanguage || 'de';
  const awLines = [];
  
  displays.forEach(display => {
    if (!display.display_activities) return;
    
    display.display_activities.forEach(activity => {
      if (!activity.user_interface_elements) return;
      
      activity.user_interface_elements.forEach(element => {
        try {
          const elementLines = convertUIElementToAuswahlfenster(
            element,
            activity,
            categories,
            items,
            mapper,
            formatter,
            defaultLanguage,
            options
          );
          awLines.push(...elementLines);
        } catch (error) {
          console.error(`Error converting UI element ${element.element_unique_identifier}: ${error.message}`);
          if (options.strictMode) {
            throw error;
          }
        }
      });
    });
  });
  
  return awLines;
}

/**
 * Convert single UI element to Auswahlfenster lines
 * @param {Object} element - UI element from OOP-POS-MDF
 * @param {Object} activity - Parent activity
 * @param {Array} categories - Categories array
 * @param {Array} items - Items array
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertUIElementToAuswahlfenster(element, activity, categories, items, mapper, formatter, defaultLanguage, options) {
  const lines = [];
  
  // Handle different element types
  switch (element.element_type) {
    case 'CATEGORY_NAVIGATION_PANEL':
      lines.push(...convertCategoryNavigationPanel(element, categories, mapper, formatter, defaultLanguage, options));
      break;
      
    case 'ITEM_GRID':
      lines.push(...convertItemGrid(element, items, categories, mapper, formatter, defaultLanguage, options));
      break;
      
    case 'BUTTON':
      lines.push(...convertButton(element, mapper, formatter, defaultLanguage, options));
      break;
      
    case 'RECEIPT_DISPLAY_AREA':
    case 'NUMERIC_KEYPAD':
      // These elements don't typically generate Auswahlfenster lines
      // but could be used for window layout configuration
      if (options.includeLayoutElements) {
        lines.push(...convertLayoutElement(element, mapper, formatter, defaultLanguage, options));
      }
      break;
      
    default:
      console.warn(`Unknown UI element type: ${element.element_type}`);
  }
  
  return lines;
}

/**
 * Convert category navigation panel to Auswahlfenster lines
 * @param {Object} element - Category navigation panel element
 * @param {Array} categories - Categories array
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertCategoryNavigationPanel(element, categories, mapper, formatter, defaultLanguage, options) {
  const lines = [];
  
  if (!element.button_configurations) {
    return lines;
  }
  
  // Create main window for category navigation
  const windowNumber = generateWindowNumber(element.element_unique_identifier, options);
  const windowFields = [];
  
  // Window name
  const windowName = getLocalizedText(element.element_names, defaultLanguage) || 'Category Navigation';
  windowFields.push({
    id: 101,
    type: 'TX',
    value: sanitizeText(windowName, options.textLimits?.windowName || 20)
  });
  
  // Background color if specified
  if (element.background_color) {
    const colorCode = convertColorToVectron(element.background_color);
    windowFields.push({
      id: '(20:1)',
      type: 'NR',
      value: colorCode
    });
  }
  
  lines.push(formatter.formatAuswahlfensterLine(windowNumber, windowFields));
  
  // Convert button configurations
  element.button_configurations.forEach((buttonConfig, index) => {
    const buttonLines = convertButtonConfiguration(
      buttonConfig,
      windowNumber,
      index + 1,
      categories,
      mapper,
      formatter,
      defaultLanguage,
      options
    );
    lines.push(...buttonLines);
  });
  
  return lines;
}

/**
 * Convert button configuration to Auswahlfenster line
 * @param {Object} buttonConfig - Button configuration
 * @param {number} windowNumber - Parent window number
 * @param {number} position - Button position
 * @param {Array} categories - Categories array
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertButtonConfiguration(buttonConfig, windowNumber, position, categories, mapper, formatter, defaultLanguage, options) {
  const lines = [];
  
  // Generate unique button number
  const buttonNumber = generateButtonNumber(windowNumber, position, options);
  const fields = [];
  
  // Button text
  const buttonText = getLocalizedText(buttonConfig.button_texts, defaultLanguage);
  if (buttonText) {
    fields.push({
      id: 101,
      type: 'TX',
      value: sanitizeText(buttonText, options.textLimits?.buttonName || 20)
    });
  }
  
  // Handle different button types
  if (buttonConfig.element_type === 'SEPARATOR_BUTTON') {
    // Separator buttons - usually just text display
    fields.push({
      id: 9001,
      type: 'NR',
      value: 1 // Mark as inactive/display only
    });
  } else if (buttonConfig.linked_category_unique_identifier) {
    // Category link button
    const warengruppe = mapper.generateWarengruppeNumber(
      buttonConfig.linked_category_unique_identifier,
      buttonText
    );
    
    // Link to Warengruppe using complex field format
    fields.push({
      id: `(31:${position},2:1)`,
      type: 'NR',
      value: warengruppe
    });
    
    // Button position
    if (buttonConfig.display_x_pos !== undefined && buttonConfig.display_y_pos !== undefined) {
      const positionCode = calculatePositionCode(buttonConfig.display_x_pos, buttonConfig.display_y_pos, options);
      fields.push({
        id: `(31:${position},3:1)`,
        type: 'NR',
        value: positionCode
      });
    }
    
    // Button size
    if (buttonConfig.display_width && buttonConfig.display_height) {
      const sizeCode = calculateSizeCode(buttonConfig.display_width, buttonConfig.display_height, options);
      fields.push({
        id: `(31:${position},4:1)`,
        type: 'NR',
        value: sizeCode
      });
    }
  }
  
  // Button color if specified
  if (buttonConfig.background_color) {
    const colorCode = convertColorToVectron(buttonConfig.background_color);
    fields.push({
      id: `(31:${position},1:1)`,
      type: 'INT',
      value: colorCode
    });
  }
  
  if (fields.length > 0) {
    lines.push(formatter.formatAuswahlfensterLine(buttonNumber, fields));
  }
  
  return lines;
}

/**
 * Convert item grid to Auswahlfenster lines
 * @param {Object} element - Item grid element
 * @param {Array} items - Items array
 * @param {Array} categories - Categories array
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertItemGrid(element, items, categories, mapper, formatter, defaultLanguage, options) {
  const lines = [];
  
  if (!element.display_items_from_category_unique_identifier) {
    return lines;
  }
  
  // Find items for this category
  const categoryItems = items.filter(
    item => item.associated_category_unique_identifier === element.display_items_from_category_unique_identifier
  );
  
  if (categoryItems.length === 0) {
    return lines;
  }
  
  // Create window for item grid
  const windowNumber = generateWindowNumber(element.element_unique_identifier, options);
  const windowFields = [];
  
  // Window name
  const category = categories.find(cat => cat.category_unique_identifier === element.display_items_from_category_unique_identifier);
  const windowName = category ? getLocalizedText(category.category_names, defaultLanguage) : 'Items';
  windowFields.push({
    id: 101,
    type: 'TX',
    value: sanitizeText(windowName + ' Grid', options.textLimits?.windowName || 20)
  });
  
  lines.push(formatter.formatAuswahlfensterLine(windowNumber, windowFields));
  
  // Create buttons for each item
  categoryItems.forEach((item, index) => {
    const itemPosition = index + 1;
    const buttonNumber = generateButtonNumber(windowNumber, itemPosition, options);
    const fields = [];
    
    // Item button text
    const buttonText = getLocalizedText(item.display_names?.button, defaultLanguage) ||
                      getLocalizedText(item.display_names?.menu, defaultLanguage) ||
                      'Item';
    
    fields.push({
      id: 101,
      type: 'TX',
      value: sanitizeText(buttonText, options.textLimits?.buttonName || 20)
    });
    
    // Link to PLU
    const pluNumber = mapper.generatePLUNumber(
      item.associated_category_unique_identifier,
      index
    );
    
    fields.push({
      id: `(31:${itemPosition},2:1)`,
      type: 'NR',
      value: pluNumber
    });
    
    // Grid position
    if (element.grid_columns) {
      const gridX = (index % element.grid_columns) * (element.button_width || 120);
      const gridY = Math.floor(index / element.grid_columns) * (element.button_height || 80);
      const positionCode = calculatePositionCode(gridX, gridY, options);
      
      fields.push({
        id: `(31:${itemPosition},3:1)`,
        type: 'NR',
        value: positionCode
      });
    }
    
    // Show price if enabled
    if (element.item_button_template?.show_price) {
      fields.push({
        id: `(31:${itemPosition},5:1)`,
        type: 'VA',
        value: item.item_price_value
      });
    }
    
    lines.push(formatter.formatAuswahlfensterLine(buttonNumber, fields));
  });
  
  return lines;
}

/**
 * Convert generic button to Auswahlfenster line
 * @param {Object} element - Button element
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertButton(element, mapper, formatter, defaultLanguage, options) {
  const lines = [];
  
  const buttonNumber = generateWindowNumber(element.element_unique_identifier, options);
  const fields = [];
  
  // Button text
  const buttonText = getLocalizedText(element.button_texts, defaultLanguage);
  if (buttonText) {
    fields.push({
      id: 101,
      type: 'TX',
      value: sanitizeText(buttonText, options.textLimits?.buttonName || 20)
    });
  }
  
  // Handle linked action
  if (element.linked_action) {
    switch (element.linked_action.action_type) {
      case 'NAVIGATE_TO_ACTIVITY':
        // Navigation button - could link to another window
        fields.push({
          id: 501,
          type: 'NR',
          value: generateWindowNumber(element.linked_action.target_activity_unique_identifier, options)
        });
        break;
        
      case 'ADD_ITEM':
        // Direct item add button
        if (element.linked_action.item_id) {
          fields.push({
            id: 301,
            type: 'NR',
            value: element.linked_action.item_id
          });
        }
        break;
    }
  }
  
  // Position
  if (element.position_x_pixels !== undefined && element.position_y_pixels !== undefined) {
    const positionCode = calculatePositionCode(element.position_x_pixels, element.position_y_pixels, options);
    fields.push({
      id: 201,
      type: 'NR',
      value: positionCode
    });
  }
  
  if (fields.length > 0) {
    lines.push(formatter.formatAuswahlfensterLine(buttonNumber, fields));
  }
  
  return lines;
}

/**
 * Convert layout element (for advanced layout features)
 * @param {Object} element - Layout element
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Auswahlfenster lines
 */
function convertLayoutElement(element, mapper, formatter, defaultLanguage, options) {
  const lines = [];
  
  // This is for advanced layout features that might be supported in future
  // For now, we just create a placeholder entry
  const elementNumber = generateWindowNumber(element.element_unique_identifier, options);
  const fields = [];
  
  // Element name/description
  const elementName = element.element_type.replace(/_/g, ' ');
  fields.push({
    id: 101,
    type: 'TX',
    value: sanitizeText(elementName, options.textLimits?.windowName || 20)
  });
  
  // Mark as layout element
  fields.push({
    id: 9002,
    type: 'NR',
    value: 1
  });
  
  lines.push(formatter.formatAuswahlfensterLine(elementNumber, fields));
  
  return lines;
}

/**
 * Generate window number from element identifier
 * @param {string} elementId - Element identifier
 * @param {Object} options - Options
 * @returns {number} Window number
 */
function generateWindowNumber(elementId, options = {}) {
  const baseNumber = options.auswahlfensterStartNumber || 1000;
  
  // Simple hash function to generate consistent numbers
  let hash = 0;
  if (elementId) {
    for (let i = 0; i < elementId.length; i++) {
      const char = elementId.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
  }
  
  return baseNumber + Math.abs(hash) % 9000; // Keep within reasonable range
}

/**
 * Generate button number from window and position
 * @param {number} windowNumber - Window number
 * @param {number} position - Button position
 * @param {Object} options - Options
 * @returns {number} Button number
 */
function generateButtonNumber(windowNumber, position, options = {}) {
  return windowNumber + position;
}

/**
 * Convert color string to Vectron color code
 * @param {string} color - Color string (hex, rgb, etc.)
 * @returns {number} Vectron color code
 */
function convertColorToVectron(color) {
  if (!color) return 0;
  
  // Remove # if present
  color = color.replace('#', '');
  
  // Convert hex to RGB and then to Vectron color code
  if (color.length === 6) {
    const r = parseInt(color.substr(0, 2), 16);
    const g = parseInt(color.substr(2, 2), 16);
    const b = parseInt(color.substr(4, 2), 16);
    
    // Simple RGB to Vectron color mapping
    return (r << 16) | (g << 8) | b;
  }
  
  // Default color codes for common colors
  const colorMap = {
    'white': 0xFFFFFF,
    'black': 0x000000,
    'red': 0xFF0000,
    'green': 0x00FF00,
    'blue': 0x0000FF,
    'yellow': 0xFFFF00,
    'gray': 0x808080,
    'lightgray': 0xC0C0C0
  };
  
  return colorMap[color.toLowerCase()] || 0xC0C0C0; // Default to light gray
}

/**
 * Calculate position code from pixel coordinates
 * @param {number} x - X coordinate in pixels
 * @param {number} y - Y coordinate in pixels
 * @param {Object} options - Options
 * @returns {number} Position code
 */
function calculatePositionCode(x, y, options = {}) {
  // Convert pixel coordinates to grid positions
  const gridSizeX = options.gridSizeX || 120;
  const gridSizeY = options.gridSizeY || 80;
  
  const gridX = Math.floor(x / gridSizeX);
  const gridY = Math.floor(y / gridSizeY);
  
  // Encode as single number (assuming max 256x256 grid)
  return (gridY << 8) | gridX;
}

/**
 * Calculate size code from dimensions
 * @param {number} width - Width in pixels
 * @param {number} height - Height in pixels
 * @param {Object} options - Options
 * @returns {number} Size code
 */
function calculateSizeCode(width, height, options = {}) {
  const gridSizeX = options.gridSizeX || 120;
  const gridSizeY = options.gridSizeY || 80;
  
  const gridWidth = Math.ceil(width / gridSizeX);
  const gridHeight = Math.ceil(height / gridSizeY);
  
  // Encode as single number
  return (gridHeight << 8) | gridWidth;
}

/**
 * Get localized text from multilingual object
 * @param {Object} textObj - Multilingual text object
 * @param {string} defaultLanguage - Default language
 * @returns {string} Localized text
 */
function getLocalizedText(textObj, defaultLanguage) {
  if (!textObj || typeof textObj !== 'object') {
    return '';
  }
  
  return textObj[defaultLanguage] || 
         textObj[Object.keys(textObj)[0]] || 
         '';
}

/**
 * Validate display layouts for Auswahlfenster conversion
 * @param {Array} displays - Display layouts to validate
 * @returns {Array} Array of validation errors
 */
function validateDisplayLayouts(displays) {
  const errors = [];
  
  if (!displays || !Array.isArray(displays)) {
    return errors; // Empty displays is valid
  }
  
  displays.forEach((display, displayIndex) => {
    if (!display.display_unique_identifier) {
      errors.push(`Display ${displayIndex}: Missing display_unique_identifier`);
    }
    
    if (display.display_activities && Array.isArray(display.display_activities)) {
      display.display_activities.forEach((activity, activityIndex) => {
        if (!activity.activity_unique_identifier) {
          errors.push(`Display ${displayIndex}, Activity ${activityIndex}: Missing activity_unique_identifier`);
        }
        
        if (activity.user_interface_elements && Array.isArray(activity.user_interface_elements)) {
          activity.user_interface_elements.forEach((element, elementIndex) => {
            if (!element.element_unique_identifier) {
              errors.push(`Display ${displayIndex}, Activity ${activityIndex}, Element ${elementIndex}: Missing element_unique_identifier`);
            }
            
            if (!element.element_type) {
              errors.push(`Display ${displayIndex}, Activity ${activityIndex}, Element ${elementIndex}: Missing element_type`);
            }
          });
        }
      });
    }
  });
  
  return errors;
}

module.exports = {
  convertDisplayLayoutsToAuswahlfenster,
  validateDisplayLayouts,
  // Export utility functions for testing
  convertColorToVectron,
  calculatePositionCode,
  calculateSizeCode,
  generateWindowNumber
};

--- File: /packages/backend/src/lib/converters/vectron/config.js ---

/**
 * Vectron Converter Configuration System
 * 
 * Advanced configuration management for Phase 2 features
 * See VECTRON_CONVERTER_PLAN.md section 4 for configuration details
 * 
 * @module VectronConfiguration
 */

const fs = require('fs');
const path = require('path');
const { detectAvailableLanguages } = require('./utils/multilingual');

/**
 * Configuration manager for Vectron converter
 */
class VectronConfigManager {
  constructor() {
    this.defaultConfig = this.getDefaultConfiguration();
    this.userConfig = {};
    this.mergedConfig = { ...this.defaultConfig };
  }
  
  /**
   * Get default configuration
   * @returns {Object} Default configuration object
   */
  getDefaultConfiguration() {
    return {
      // Basic settings
      kassennummer: 1,
      importMode: 'A',
      encoding: 'win1252',
      includeTimestamp: true,
      programName: 'eckasse-converter',
      
      // Validation settings
      validation: {
        strictMode: false,
        validateOutput: true,
        warningsAsErrors: false,
        maxLineLength: 250
      },
      
      // Language settings
      language: {
        defaultLanguage: 'de',
        supportedLanguages: ['de', 'en'],
        fallbackLanguage: 'en',
        autoDetectLanguages: true,
        includeMultilingualFields: true
      },
      
      // Numbering systems
      numbering: {
        plu: {
          startNumber: 1000,
          blockSize: 100,
          reserveBlocks: 10,
          autoGenerate: true
        },
        warengruppen: {
          startNumber: 900,
          useDefaults: true,
          autoGenerate: true,
          defaultMappings: {
            'SPEISEN': 941,
            'GETRÄNKE': 951,
            'GETRÄNKE_REDUZIERT': 953,
            'FOOD': 941,
            'DRINKS': 951,
            'BEVERAGES': 951
          }
        },
        auswahlfenster: {
          startNumber: 1000,
          autoGenerate: true,
          maxButtons: 256
        }
      },
      
      // Text processing
      text: {
        limits: {
          itemName: 40,
          categoryName: 30,
          buttonName: 20,
          windowName: 20,
          description: 60
        },
        sanitization: {
          removeInvalidChars: true,
          normalizeWhitespace: true,
          trimLength: true
        }
      },
      
      // Feature flags
      features: {
        includeAuswahlfenster: true,
        includeComplexFields: false,
        includePricingSchedules: false,
        includeLayoutElements: false,
        includeExtendedValidation: true,
        includeAllergenInfo: false,
        includeNutritionInfo: false
      },
      
      // Business type specific settings
      businessType: {
        type: 'restaurant', // restaurant, bar, cafe, retail
        customMainGroups: null,
        industrySpecificFields: true
      },
      
      // Display and UI settings
      display: {
        gridSize: {
          x: 120,
          y: 80
        },
        colors: {
          defaultBackground: '#F5F5F5',
          defaultText: '#000000',
          categoryButtons: '#ADD8E6',
          itemButtons: '#E6E6FA'
        },
        buttonSizes: {
          small: { width: 80, height: 60 },
          medium: { width: 120, height: 80 },
          large: { width: 160, height: 100 }
        }
      },
      
      // Advanced mapping settings
      mapping: {
        customFieldMappings: {},
        printerMappings: {
          'RECEIPT': 1,
          'KITCHEN': 2,
          'BAR': 3
        },
        paymentMethodMappings: {
          'CASH': 1,
          'CARD': 2,
          'CREDIT_CARD': 3
        },
        taxRateMappings: {
          7: 2,   // 7% → Tax rate 2
          19: 1,  // 19% → Tax rate 1
          0: 3    // 0% → Tax rate 3
        }
      },
      
      // Output formatting
      output: {
        lineEndings: '\r\n',
        fieldSeparator: ';',
        escapeQuotes: true,
        includeComments: false,
        prettyFormat: false
      },
      
      // Performance settings
      performance: {
        batchSize: 1000,
        enableCaching: true,
        parallelProcessing: false,
        memoryLimit: '256MB'
      }
    };
  }
  
  /**
   * Load configuration from file
   * @param {string} configPath - Path to configuration file
   * @returns {Object} Loaded configuration
   */
  loadConfigFromFile(configPath) {
    try {
      if (!fs.existsSync(configPath)) {
        console.warn(`Configuration file not found: ${configPath}`);
        return {};
      }
      
      const content = fs.readFileSync(configPath, 'utf8');
      
      if (configPath.endsWith('.json')) {
        return JSON.parse(content);
      } else if (configPath.endsWith('.js')) {
        // For .js config files, use require
        delete require.cache[require.resolve(path.resolve(configPath))];
        return require(path.resolve(configPath));
      }
      
      throw new Error(`Unsupported configuration file format: ${configPath}`);
    } catch (error) {
      console.error(`Error loading configuration: ${error.message}`);
      return {};
    }
  }
  
  /**
   * Save configuration to file
   * @param {string} configPath - Path to save configuration
   * @param {Object} config - Configuration to save
   */
  saveConfigToFile(configPath, config = null) {
    const configToSave = config || this.mergedConfig;
    
    try {
      const content = JSON.stringify(configToSave, null, 2);
      fs.writeFileSync(configPath, content, 'utf8');
      console.log(`Configuration saved to: ${configPath}`);
    } catch (error) {
      console.error(`Error saving configuration: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Apply configuration from various sources
   * @param {Object} options - Configuration options
   * @returns {Object} Applied configuration
   */
  applyConfiguration(options = {}) {
    // Start with default config
    let config = { ...this.defaultConfig };
    
    // Apply user config if exists
    if (Object.keys(this.userConfig).length > 0) {
      config = this.deepMerge(config, this.userConfig);
    }
    
    // Apply runtime options
    if (options.configFile) {
      const fileConfig = this.loadConfigFromFile(options.configFile);
      config = this.deepMerge(config, fileConfig);
    }
    
    // Apply command line options
    if (options.kassennummer) config.kassennummer = options.kassennummer;
    if (options.importMode) config.importMode = options.importMode;
    if (options.defaultLanguage) config.language.defaultLanguage = options.defaultLanguage;
    if (options.strictMode !== undefined) config.validation.strictMode = options.strictMode;
    if (options.includeAuswahlfenster !== undefined) config.features.includeAuswahlfenster = options.includeAuswahlfenster;
    
    // Auto-detect settings from input data
    if (options.inputData && config.language.autoDetectLanguages) {
      const detectedLanguages = detectAvailableLanguages(options.inputData);
      if (detectedLanguages.length > 0) {
        config.language.supportedLanguages = detectedLanguages;
        if (!detectedLanguages.includes(config.language.defaultLanguage)) {
          config.language.defaultLanguage = detectedLanguages[0];
        }
      }
    }
    
    // Business type specific configuration
    if (options.businessType) {
      config.businessType.type = options.businessType;
      this.applyBusinessTypeDefaults(config);
    }
    
    this.mergedConfig = config;
    return config;
  }
  
  /**
   * Apply business type specific defaults
   * @param {Object} config - Configuration object to modify
   */
  applyBusinessTypeDefaults(config) {
    const businessDefaults = {
      restaurant: {
        features: {
          includeAllergenInfo: true,
          includeNutritionInfo: true,
          includePricingSchedules: true
        },
        numbering: {
          warengruppen: {
            defaultMappings: {
              'VORSPEISEN': 940,
              'HAUPTSPEISEN': 941,
              'NACHSPEISEN': 942,
              'GETRÄNKE': 951,
              'ALKOHOLISCHE_GETRÄNKE': 952
            }
          }
        }
      },
      bar: {
        features: {
          includeAllergenInfo: false,
          includeNutritionInfo: false,
          includePricingSchedules: true
        },
        numbering: {
          warengruppen: {
            defaultMappings: {
              'BIER': 950,
              'WEIN': 951,
              'SPIRITS': 952,
              'COCKTAILS': 953,
              'ALKOHOLFREI': 954
            }
          }
        }
      },
      cafe: {
        features: {
          includeAllergenInfo: true,
          includeNutritionInfo: false,
          includePricingSchedules: false
        },
        numbering: {
          warengruppen: {
            defaultMappings: {
              'KAFFEE': 950,
              'TEE': 951,
              'KALTGETRÄNKE': 952,
              'GEBÄCK': 941,
              'SNACKS': 942
            }
          }
        }
      },
      retail: {
        features: {
          includeAllergenInfo: false,
          includeNutritionInfo: false,
          includePricingSchedules: false
        },
        numbering: {
          plu: {
            startNumber: 2000,
            blockSize: 1000
          }
        }
      }
    };
    
    const businessConfig = businessDefaults[config.businessType.type];
    if (businessConfig) {
      config = this.deepMerge(config, businessConfig);
    }
  }
  
  /**
   * Validate configuration
   * @param {Object} config - Configuration to validate
   * @returns {Array} Array of validation errors
   */
  validateConfiguration(config) {
    const errors = [];
    
    // Basic validation
    if (!config.kassennummer || config.kassennummer < 1) {
      errors.push('kassennummer must be a positive number');
    }
    
    if (!['A', 'O', 'R'].includes(config.importMode)) {
      errors.push('importMode must be A, O, or R');
    }
    
    // Language validation
    if (!config.language.defaultLanguage) {
      errors.push('defaultLanguage is required');
    }
    
    if (!Array.isArray(config.language.supportedLanguages) || config.language.supportedLanguages.length === 0) {
      errors.push('supportedLanguages must be a non-empty array');
    }
    
    // Numbering validation
    if (config.numbering.plu.startNumber < 1) {
      errors.push('PLU startNumber must be positive');
    }
    
    if (config.numbering.plu.blockSize < 1) {
      errors.push('PLU blockSize must be positive');
    }
    
    // Text limits validation
    Object.entries(config.text.limits).forEach(([key, value]) => {
      if (typeof value !== 'number' || value < 1) {
        errors.push(`text.limits.${key} must be a positive number`);
      }
    });
    
    return errors;
  }
  
  /**
   * Deep merge configuration objects
   * @param {Object} target - Target object
   * @param {Object} source - Source object
   * @returns {Object} Merged object
   */
  deepMerge(target, source) {
    const result = { ...target };
    
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    
    return result;
  }
  
  /**
   * Get configuration template for specific business type
   * @param {string} businessType - Business type
   * @returns {Object} Configuration template
   */
  getBusinessTypeTemplate(businessType) {
    const template = { ...this.defaultConfig };
    template.businessType.type = businessType;
    this.applyBusinessTypeDefaults(template);
    return template;
  }
  
  /**
   * Export current configuration
   * @returns {Object} Current configuration
   */
  exportConfiguration() {
    return { ...this.mergedConfig };
  }
  
  /**
   * Reset to default configuration
   */
  resetToDefaults() {
    this.userConfig = {};
    this.mergedConfig = { ...this.defaultConfig };
  }
  
  /**
   * Update user configuration
   * @param {Object} newConfig - New configuration to merge
   */
  updateUserConfig(newConfig) {
    this.userConfig = this.deepMerge(this.userConfig, newConfig);
    this.mergedConfig = this.deepMerge(this.defaultConfig, this.userConfig);
  }
}

/**
 * Create configuration preset for common scenarios
 * @param {string} preset - Preset name
 * @returns {Object} Preset configuration
 */
function createConfigurationPreset(preset) {
  const manager = new VectronConfigManager();
  
  const presets = {
    'minimal': {
      features: {
        includeAuswahlfenster: false,
        includeComplexFields: false,
        includePricingSchedules: false,
        includeExtendedValidation: false
      },
      validation: {
        strictMode: false,
        warningsAsErrors: false
      }
    },
    
    'standard': {
      features: {
        includeAuswahlfenster: true,
        includeComplexFields: false,
        includePricingSchedules: false,
        includeExtendedValidation: true
      }
    },
    
    'advanced': {
      features: {
        includeAuswahlfenster: true,
        includeComplexFields: true,
        includePricingSchedules: true,
        includeExtendedValidation: true,
        includeAllergenInfo: true,
        includeNutritionInfo: true
      },
      validation: {
        strictMode: true,
        warningsAsErrors: false
      }
    },
    
    'production': {
      features: {
        includeAuswahlfenster: true,
        includeComplexFields: true,
        includePricingSchedules: true,
        includeExtendedValidation: true
      },
      validation: {
        strictMode: true,
        warningsAsErrors: true
      },
      performance: {
        batchSize: 500,
        enableCaching: true,
        parallelProcessing: true
      }
    }
  };
  
  const presetConfig = presets[preset];
  if (presetConfig) {
    return manager.deepMerge(manager.getDefaultConfiguration(), presetConfig);
  }
  
  throw new Error(`Unknown preset: ${preset}`);
}

module.exports = {
  VectronConfigManager,
  createConfigurationPreset
};

--- File: /packages/backend/src/lib/converters/vectron/header.js ---

/**
 * Vectron Header Line Generator (LineType 100)
 * 
 * Generates header lines for Vectron Commander import files
 * See VECTRON_CONVERTER_PLAN.md section 3.1 for details
 * 
 * @module VectronHeaderGenerator
 */

const VectronLineFormatter = require('./utils/formatter');
const { sanitizeText } = require('./utils/encoding');

/**
 * Generate header line for Vectron import
 * @param {Object} company - Company details from OOP-POS-MDF
 * @param {Object} branch - Branch details from OOP-POS-MDF
 * @param {Object} options - Additional options
 * @returns {string} Formatted header line
 */
function generateHeader(company, branch, options = {}) {
  const formatter = new VectronLineFormatter();
  
  // Extract cash register number from first POS device
  const posDevice = branch.point_of_sale_devices?.[0];
  if (!posDevice) {
    throw new Error('No POS devices found in branch');
  }
  
  const kassennummer = options.kassennummer || posDevice.pos_device_external_number || 1;
  const importMode = options.importMode || 'A';
  
  // Prepare optional header fields
  const headerOptions = {};
  
  if (options.includeTimestamp !== false) {
    const now = new Date();
    headerOptions.date = now.toISOString().split('T')[0].replace(/-/g, '');
    headerOptions.time = now.toTimeString().split(' ')[0].replace(/:/g, '');
  }
  
  if (options.programName) {
    headerOptions.programName = sanitizeText(options.programName, 20);
  } else {
    headerOptions.programName = 'eckasse-converter';
  }
  
  if (posDevice.pos_device_names) {
    const defaultLanguage = company.meta_information?.default_language || 'de';
    const kasseName = posDevice.pos_device_names[defaultLanguage] || 
                     posDevice.pos_device_names[Object.keys(posDevice.pos_device_names)[0]];
    if (kasseName) {
      headerOptions.kasseName = sanitizeText(kasseName, 30);
    }
  }
  
  return formatter.formatHeaderLine(kassennummer, importMode, headerOptions);
}

/**
 * Validate header generation parameters
 * @param {Object} company - Company details
 * @param {Object} branch - Branch details
 * @returns {Array} Array of validation errors
 */
function validateHeaderParams(company, branch) {
  const errors = [];
  
  if (!company) {
    errors.push('Company details are required');
  }
  
  if (!branch) {
    errors.push('Branch details are required');
  }
  
  if (branch && (!branch.point_of_sale_devices || branch.point_of_sale_devices.length === 0)) {
    errors.push('At least one POS device is required in branch');
  }
  
  return errors;
}

module.exports = {
  generateHeader,
  validateHeaderParams
};

--- File: /packages/backend/src/lib/converters/vectron/index.js ---

/**
 * Main Vectron Converter Module
 * 
 * Converts OOP-POS-MDF v2.0.0 format to Vectron Commander import format
 * See VECTRON_CONVERTER_PLAN.md for detailed implementation plan
 * 
 * @module VectronConverter
 */

const { generateHeader } = require('./header');
const { convertItemsToPLUs } = require('./plu');
const { convertCategoriesToWarengruppen, getUsedCategories } = require('./warengruppen');
const { convertDisplayLayoutsToAuswahlfenster } = require('./auswahlfenster');
const { validateOOPInput, validateVectronOutput } = require('./validation');
const { encodeToWindows1252 } = require('./utils/encoding');
const { createMultilingualManager } = require('./utils/multilingual');
const { VectronConfigManager } = require('./config');

/**
 * Convert OOP-POS-MDF v2.0.0 to Vectron Commander import format
 * @param {Object} oopPosMdfData - OOP-POS-MDF v2.0.0 data
 * @param {Object} options - Conversion options
 * @returns {Object} Conversion result
 */
function convertToVectron(oopPosMdfData, options = {}) {
  // Initialize configuration manager
  const configManager = new VectronConfigManager();
  const conversionOptions = configManager.applyConfiguration({
    inputData: oopPosMdfData,
    ...options
  });
  
  // Validate configuration
  const configErrors = configManager.validateConfiguration(conversionOptions);
  if (configErrors.length > 0 && conversionOptions.validation.strictMode) {
    throw new Error(`Configuration validation failed: ${configErrors.join(', ')}`);
  }
  
  // Initialize multilingual manager
  const textManager = createMultilingualManager({
    defaultLanguage: conversionOptions.language.defaultLanguage,
    supportedLanguages: conversionOptions.language.supportedLanguages,
    fallbackLanguage: conversionOptions.language.fallbackLanguage,
    textLimits: conversionOptions.text.limits
  });
  
  // Validate input
  const inputValidation = validateOOPInput(oopPosMdfData);
  if (!inputValidation.isValid) {
    throw new Error(`Input validation failed: ${inputValidation.errors.join(', ')}`);
  }
  
  try {
    // Extract data structures
    const company = oopPosMdfData.company_details;
    const branch = company.branches[0];
    const posDevice = branch.point_of_sale_devices[0];
    const globalConfig = {
      ...company.global_configurations,
      default_linked_drink_tax_rate_unique_identifier: posDevice.pos_device_settings?.default_linked_drink_tax_rate_unique_identifier,
      default_linked_food_tax_rate_unique_identifier: posDevice.pos_device_settings?.default_linked_food_tax_rate_unique_identifier
    };
    
    const allCategories = posDevice.categories_for_this_pos || [];
    const allItems = posDevice.items_for_this_pos || [];
    const displays = posDevice.built_in_displays || [];
    
    // Only convert categories that are actually used by items
    const usedCategories = getUsedCategories(allCategories, allItems);
    
    // Generate Vectron lines
    const lines = [];
    const stats = {
      headerLines: 0,
      warengruppenLines: 0,
      pluLines: 0,
      auswahlfensterLines: 0
    };
    
    // 1. Header line (LineType 100)
    const headerLine = generateHeader(company, branch, conversionOptions);
    lines.push(headerLine);
    stats.headerLines++;
    
    // 2. Warengruppen lines (LineType 102)
    if (usedCategories.length > 0) {
      const wgLines = convertCategoriesToWarengruppen(
        usedCategories, 
        globalConfig, 
        conversionOptions
      );
      lines.push(...wgLines);
      stats.warengruppenLines = wgLines.length;
    }
    
    // 3. PLU lines (LineType 101)
    if (allItems.length > 0) {
      const pluLines = convertItemsToPLUs(
        allItems, 
        allCategories, 
        globalConfig, 
        conversionOptions
      );
      lines.push(...pluLines);
      stats.pluLines = pluLines.length;
    }
    
    // 4. Auswahlfenster lines (LineType 152) - Phase 2 feature
    if (conversionOptions.features.includeAuswahlfenster && displays.length > 0) {
      const awLines = convertDisplayLayoutsToAuswahlfenster(
        displays,
        allCategories,
        allItems,
        conversionOptions
      );
      lines.push(...awLines);
      stats.auswahlfensterLines = awLines.length;
    }
    
    // Join all lines
    const vectronContent = lines.join('');
    
    // Validate output if requested
    let validation = null;
    if (conversionOptions.validateOutput) {
      validation = validateVectronOutput(vectronContent, conversionOptions);
      if (!validation.isValid && conversionOptions.strictMode) {
        throw new Error(`Output validation failed: ${validation.errors.join(', ')}`);
      }
    }
    
    // Encode to Windows-1252 if requested
    let output = vectronContent;
    let outputBuffer = null;
    if (conversionOptions.encoding === 'win1252') {
      outputBuffer = encodeToWindows1252(vectronContent);
    }
    
    return {
      success: true,
      output: output,
      outputBuffer: outputBuffer,
      validation: validation,
      stats: {
        totalLines: lines.length,
        headerLines: stats.headerLines,
        warengruppenLines: stats.warengruppenLines,
        pluLines: stats.pluLines,
        auswahlfensterLines: stats.auswahlfensterLines,
        categoriesProcessed: usedCategories.length,
        itemsProcessed: allItems.length,
        displaysProcessed: displays.length,
        featuresUsed: {
          auswahlfenster: conversionOptions.features.includeAuswahlfenster,
          complexFields: conversionOptions.features.includeComplexFields,
          multiLanguage: conversionOptions.language.includeMultilingualFields,
          extendedValidation: conversionOptions.features.includeExtendedValidation
        }
      },
      metadata: {
        kassennummer: conversionOptions.kassennummer || posDevice.pos_device_external_number || 1,
        importMode: conversionOptions.importMode,
        generatedAt: new Date().toISOString(),
        sourceFormat: 'OOP-POS-MDF-v2.0.0',
        targetFormat: 'Vectron-Commander-Import',
        converterVersion: '2.0.0-phase2',
        configuration: {
          businessType: conversionOptions.businessType.type,
          primaryLanguage: conversionOptions.language.defaultLanguage,
          supportedLanguages: conversionOptions.language.supportedLanguages,
          featuresEnabled: Object.entries(conversionOptions.features)
            .filter(([key, value]) => value)
            .map(([key]) => key)
        }
      }
    };
    
  } catch (error) {
    return {
      success: false,
      error: error.message,
      output: null,
      validation: null,
      stats: null
    };
  }
}

/**
 * Convert and save to file
 * @param {Object} oopPosMdfData - OOP-POS-MDF v2.0.0 data
 * @param {string} outputPath - Output file path
 * @param {Object} options - Conversion options
 * @returns {Object} Conversion result
 */
function convertToVectronFile(oopPosMdfData, outputPath, options = {}) {
  const fs = require('fs');
  
  const result = convertToVectron(oopPosMdfData, options);
  
  if (result.success) {
    try {
      if (result.outputBuffer) {
        // Write binary (Windows-1252 encoded)
        fs.writeFileSync(outputPath, result.outputBuffer, 'binary');
      } else {
        // Write as UTF-8 text
        fs.writeFileSync(outputPath, result.output, 'utf8');
      }
      
      result.outputPath = outputPath;
    } catch (writeError) {
      result.success = false;
      result.error = `Failed to write file: ${writeError.message}`;
    }
  }
  
  return result;
}

/**
 * Get default configuration for converter
 * @returns {Object} Default configuration
 */
function getDefaultConfig() {
  return {
    kassennummer: 1,
    importMode: 'A',
    includeTimestamp: true,
    programName: 'eckasse-converter',
    strictMode: false,
    validateOutput: true,
    encoding: 'win1252',
    defaultLanguage: 'de',
    pluNumbering: {
      startNumber: 1000,
      blockSize: 100,
      reserveBlocks: 10
    },
    warengruppenNumbering: {
      startNumber: 900,
      useDefaults: true,
      defaultMappings: {
        'SPEISEN': 941,
        'GETRÄNKE': 951,
        'GETRÄNKE_REDUZIERT': 953,
        'FOOD': 941,
        'DRINKS': 951,
        'BEVERAGES': 951
      }
    },
    textLimits: {
      itemName: 40,
      categoryName: 30,
      windowName: 20
    },
    validation: {
      maxLineLength: 250,
      warningsAsErrors: false
    }
  };
}

module.exports = {
  convertToVectron,
  convertToVectronFile,
  getDefaultConfig,
  
  // Phase 2 exports
  VectronConfigManager: require('./config').VectronConfigManager,
  createConfigurationPreset: require('./config').createConfigurationPreset,
  createMultilingualManager: require('./utils/multilingual').createMultilingualManager,
  // Export individual components for advanced usage
  components: {
    generateHeader,
    convertItemsToPLUs,
    convertCategoriesToWarengruppen,
    validateOOPInput,
    validateVectronOutput
  }
};

--- File: /packages/backend/src/lib/converters/vectron/mapping.js ---

/**
 * Vectron Field Mapping System
 * 
 * Maps OOP-POS-MDF fields to Vectron field format
 * See VECTRON_CONVERTER_PLAN.md section 3.5 for details
 * 
 * @module VectronFieldMapper
 */

const { PLUNumberGenerator, WarengruppenNumberGenerator } = require('./utils/numbering');

class VectronFieldMapper {
  constructor(options = {}) {
    // Tax rate mapping: OOP-POS-MDF percentage → Vectron tax rate number
    this.taxRateMapping = new Map([
      [7, 2],    // 7% → Tax rate 2
      [19, 1],   // 19% → Tax rate 1
      [0, 3]     // 0% → Tax rate 3
    ]);
    
    // Initialize numbering generators
    this.pluGenerator = new PLUNumberGenerator(options.pluNumbering);
    this.wgGenerator = new WarengruppenNumberGenerator(options.warengruppenNumbering);
    
    // Category type to main group mapping
    this.categoryTypeMapping = new Map([
      ['drink', 1],   // Beverages → Main group 1
      ['food', 2],    // Food → Main group 2
      ['service', 3], // Services → Main group 3
      ['other', 4]    // Other → Main group 4
    ]);
  }
  
  /**
   * Map OOP-POS-MDF tax rate to Vectron tax rate number
   * @param {number} oopTaxRate - Tax rate percentage from OOP-POS-MDF
   * @returns {number} Vectron tax rate number
   */
  mapTaxRate(oopTaxRate) {
    return this.taxRateMapping.get(oopTaxRate) || 1; // Default to tax rate 1 (19%)
  }
  
  /**
   * Generate PLU number for item
   * @param {number} categoryId - Category identifier
   * @param {number} itemIndex - Item index within category
   * @returns {number} PLU number
   */
  generatePLUNumber(categoryId, itemIndex) {
    return this.pluGenerator.calculatePLUNumber(categoryId, itemIndex);
  }
  
  /**
   * Generate Warengruppe number for category
   * @param {number} categoryId - Category identifier
   * @param {string} categoryName - Category name for default mapping
   * @returns {number} Warengruppe number
   */
  generateWarengruppeNumber(categoryId, categoryName = '') {
    return this.wgGenerator.generateWarengruppeNumber(categoryId, categoryName);
  }
  
  /**
   * Map category type to main group
   * @param {string} categoryType - Category type from OOP-POS-MDF
   * @returns {number} Main group number
   */
  mapCategoryTypeToMainGroup(categoryType) {
    return this.categoryTypeMapping.get(categoryType) || 1;
  }
  
  /**
   * Extract tax rate from global definitions
   * @param {number} taxRateId - Tax rate unique identifier
   * @param {Array} globalTaxRates - Global tax rate definitions
   * @returns {number} Tax rate percentage
   */
  extractTaxRatePercentage(taxRateId, globalTaxRates) {
    const taxRate = globalTaxRates?.find(rate => rate.tax_rate_unique_identifier === taxRateId);
    return taxRate ? taxRate.rate_percentage : 19; // Default to 19%
  }
  
  /**
   * Get category by ID from categories array
   * @param {number} categoryId - Category identifier
   * @param {Array} categories - Categories array
   * @returns {Object|null} Category object or null
   */
  getCategoryById(categoryId, categories) {
    return categories?.find(cat => cat.category_unique_identifier === categoryId) || null;
  }
  
  /**
   * Reset all numbering generators
   */
  reset() {
    this.pluGenerator.reset();
    this.wgGenerator.reset();
  }
  
  /**
   * Map printer type to Vectron printer number
   * @param {string} printerType - Printer type from OOP-POS-MDF
   * @returns {number} Vectron printer number
   */
  mapPrinterType(printerType) {
    const printerMapping = new Map([
      ['RECEIPT', 1],     // Receipt printer
      ['KITCHEN', 2],     // Kitchen printer
      ['BAR', 3],         // Bar printer
      ['LABEL', 4],       // Label printer
      ['CUSTOMER_DISPLAY', 5] // Customer display
    ]);
    
    return printerMapping.get(printerType?.toUpperCase()) || 1;
  }
  
  /**
   * Map payment method type to Vectron payment type
   * @param {string} paymentType - Payment method type from OOP-POS-MDF
   * @returns {number} Vectron payment type
   */
  mapPaymentMethodType(paymentType) {
    const paymentMapping = new Map([
      ['CASH', 1],
      ['CARD', 2],
      ['CREDIT_CARD', 3],
      ['DEBIT_CARD', 4],
      ['MOBILE_PAYMENT', 5],
      ['VOUCHER', 6],
      ['LOYALTY_POINTS', 7]
    ]);
    
    return paymentMapping.get(paymentType?.toUpperCase()) || 1;
  }
  
  /**
   * Generate complex field mapping for advanced features
   * @param {string} fieldPath - Dot notation field path
   * @param {*} value - Field value
   * @param {Object} context - Additional context
   * @returns {Object} Field mapping result
   */
  mapComplexField(fieldPath, value, context = {}) {
    const fieldMappings = {
      // Item specific mappings
      'item.allergens': {
        vectronField: 801,
        transform: (allergens) => this.encodeAllergens(allergens)
      },
      'item.nutrition.calories': {
        vectronField: 802,
        transform: (calories) => parseInt(calories) || 0
      },
      'item.volume_ml': {
        vectronField: 803,
        transform: (volume) => parseFloat(volume) || 0
      }
    };
    
    const mapping = fieldMappings[fieldPath];
    if (mapping) {
      return {
        fieldId: mapping.vectronField,
        value: mapping.transform(value),
        type: this.inferFieldType(mapping.vectronField, value)
      };
    }
    
    return null;
  }
  
  /**
   * Encode allergens as bit field
   * @param {Array} allergens - Array of allergen strings
   * @returns {number} Encoded allergen bit field
   */
  encodeAllergens(allergens) {
    if (!Array.isArray(allergens)) return 0;
    
    const allergenMap = {
      'gluten': 1,
      'dairy': 2,
      'eggs': 4,
      'nuts': 8,
      'soy': 16,
      'fish': 32,
      'shellfish': 64,
      'sesame': 128
    };
    
    let encoded = 0;
    allergens.forEach(allergen => {
      const bit = allergenMap[allergen.toLowerCase()];
      if (bit) encoded |= bit;
    });
    
    return encoded;
  }
  
  /**
   * Infer Vectron field type from field ID and value
   * @param {number} fieldId - Vectron field ID
   * @param {*} value - Field value
   * @returns {string} Field type (TX, NR, VA, INT)
   */
  inferFieldType(fieldId, value) {
    // Text fields (100-199)
    if (fieldId >= 100 && fieldId <= 199) {
      return 'TX';
    }
    
    // Price/value fields (200-299)
    if (fieldId >= 200 && fieldId <= 299) {
      return typeof value === 'number' && value % 1 !== 0 ? 'VA' : 'NR';
    }
    
    // Default to number
    return 'NR';
  }
  
  /**
   * Get statistics about generated numbers
   * @returns {Object} Statistics object
   */
  getStats() {
    return {
      pluCount: this.pluGenerator.usedNumbers.size,
      categoryCount: this.wgGenerator.categoryNumberMap.size,
      usedPLUNumbers: Array.from(this.pluGenerator.usedNumbers).sort((a, b) => a - b),
      usedWGNumbers: Array.from(this.wgGenerator.usedNumbers).sort((a, b) => a - b),
      mappingCapabilities: {
        taxRates: this.taxRateMapping.size,
        categoryTypes: this.categoryTypeMapping.size,
        supportedBusinessTypes: ['restaurant', 'bar', 'cafe', 'retail'],
        complexFields: 3, // Number of complex field mappings supported
        extendedFeatures: ['allergens', 'nutrition', 'volume']
      }
    };
  }
}

module.exports = VectronFieldMapper;

--- File: /packages/backend/src/lib/converters/vectron/plu.js ---

/**
 * Vectron PLU Converter (LineType 101)
 * 
 * Converts OOP-POS-MDF items to Vectron PLU format
 * See VECTRON_CONVERTER_PLAN.md section 3.2 for details
 * 
 * @module VectronPLUConverter
 */

const VectronLineFormatter = require('./utils/formatter');
const { sanitizeText } = require('./utils/encoding');
const VectronFieldMapper = require('./mapping');

/**
 * Convert OOP-POS-MDF items to Vectron PLU lines
 * @param {Array} items - Items from OOP-POS-MDF
 * @param {Array} categories - Categories from OOP-POS-MDF
 * @param {Object} globalConfig - Global configuration (tax rates, etc.)
 * @param {Object} options - Conversion options
 * @returns {Array} Array of PLU lines
 */
function convertItemsToPLUs(items, categories, globalConfig, options = {}) {
  if (!items || !Array.isArray(items)) {
    return [];
  }
  
  const formatter = new VectronLineFormatter();
  const mapper = new VectronFieldMapper(options);
  const defaultLanguage = options.defaultLanguage || 'de';
  const pluLines = [];
  
  // Group items by category for proper numbering
  const itemsByCategory = new Map();
  items.forEach(item => {
    const categoryId = item.associated_category_unique_identifier;
    if (!itemsByCategory.has(categoryId)) {
      itemsByCategory.set(categoryId, []);
    }
    itemsByCategory.get(categoryId).push(item);
  });
  
  // Convert each item to PLU
  for (const [categoryId, categoryItems] of itemsByCategory) {
    const category = mapper.getCategoryById(categoryId, categories);
    if (!category) {
      console.warn(`Warning: Category ${categoryId} not found, skipping items`);
      continue;
    }
    
    categoryItems.forEach((item, itemIndex) => {
      try {
        const pluLine = convertSingleItemToPLU(
          item, 
          category, 
          itemIndex, 
          globalConfig, 
          mapper, 
          formatter, 
          defaultLanguage
        );
        if (pluLine) {
          pluLines.push(pluLine);
        }
      } catch (error) {
        console.error(`Error converting item ${item.item_unique_identifier}: ${error.message}`);
        if (options.strictMode) {
          throw error;
        }
      }
    });
  }
  
  return pluLines;
}

/**
 * Convert single item to PLU line
 * @param {Object} item - Item from OOP-POS-MDF
 * @param {Object} category - Category from OOP-POS-MDF
 * @param {number} itemIndex - Item index within category
 * @param {Object} globalConfig - Global configuration
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @returns {string} PLU line
 */
function convertSingleItemToPLU(item, category, itemIndex, globalConfig, mapper, formatter, defaultLanguage) {
  // Generate PLU number
  const pluNumber = mapper.generatePLUNumber(
    category.category_unique_identifier, 
    itemIndex
  );
  
  // Prepare field array
  const fields = [];
  
  // Names (101-199)
  const menuName = getLocalizedText(item.display_names?.menu, defaultLanguage);
  const buttonName = getLocalizedText(item.display_names?.button, defaultLanguage);
  
  if (menuName) {
    fields.push({
      id: 101,
      type: 'TX',
      value: sanitizeText(menuName, 40)
    });
  }
  
  if (buttonName && buttonName !== menuName) {
    fields.push({
      id: 102,
      type: 'TX',
      value: sanitizeText(buttonName, 20)
    });
  }
  
  // Price (201-299)
  if (item.item_price_value !== undefined) {
    fields.push({
      id: 201,
      type: 'VA',
      value: item.item_price_value
    });
  }
  
  // Category link (301)
  const warengruppe = mapper.generateWarengruppeNumber(
    category.category_unique_identifier,
    getLocalizedText(category.category_names, defaultLanguage)
  );
  fields.push({
    id: 301,
    type: 'NR',
    value: warengruppe
  });
  
  // Main group (311)
  const mainGroup = category.default_linked_main_group_unique_identifier || 
                   mapper.mapCategoryTypeToMainGroup(category.category_type);
  fields.push({
    id: 311,
    type: 'NR',
    value: mainGroup
  });
  
  // Tax rate (401)
  const taxRateId = getTaxRateForCategory(category, globalConfig);
  const taxRatePercentage = mapper.extractTaxRatePercentage(taxRateId, globalConfig.tax_rates_definitions);
  const vectronTaxRate = mapper.mapTaxRate(taxRatePercentage);
  fields.push({
    id: 401,
    type: 'NR',
    value: vectronTaxRate
  });
  
  // Flags
  // No sale flag (1003)
  const canSell = item.item_flags?.is_sellable !== false;
  fields.push({
    id: 1003,
    type: 'NR',
    value: canSell ? 0 : 1
  });
  
  // Active flag (9001)
  fields.push({
    id: 9001,
    type: 'NR',
    value: 0  // Always active
  });
  
  // Negative flag (901)
  const isNegative = item.item_flags?.has_negative_price === true;
  fields.push({
    id: 901,
    type: 'NR',
    value: isNegative ? 1 : 0
  });
  
  return formatter.formatPLULine(pluNumber, fields);
}

/**
 * Get localized text from multilingual object
 * @param {Object} textObj - Multilingual text object
 * @param {string} defaultLanguage - Default language
 * @returns {string} Localized text
 */
function getLocalizedText(textObj, defaultLanguage) {
  if (!textObj || typeof textObj !== 'object') {
    return '';
  }
  
  return textObj[defaultLanguage] || 
         textObj[Object.keys(textObj)[0]] || 
         '';
}

/**
 * Get tax rate for category
 * @param {Object} category - Category object
 * @param {Object} globalConfig - Global configuration
 * @returns {number} Tax rate identifier
 */
function getTaxRateForCategory(category, globalConfig) {
  // For drinks, use drink tax rate; for food, use food tax rate
  if (category.category_type === 'drink') {
    return globalConfig.default_linked_drink_tax_rate_unique_identifier || 1;
  } else if (category.category_type === 'food') {
    return globalConfig.default_linked_food_tax_rate_unique_identifier || 2;
  }
  
  // Default to first available tax rate
  return globalConfig.tax_rates_definitions?.[0]?.tax_rate_unique_identifier || 1;
}

/**
 * Validate items for PLU conversion
 * @param {Array} items - Items to validate
 * @param {Array} categories - Categories to validate against
 * @returns {Array} Array of validation errors
 */
function validateItemsForPLU(items, categories) {
  const errors = [];
  
  if (!items || !Array.isArray(items)) {
    errors.push('Items must be an array');
    return errors;
  }
  
  if (!categories || !Array.isArray(categories)) {
    errors.push('Categories must be an array');
    return errors;
  }
  
  items.forEach((item, index) => {
    if (!item.item_unique_identifier) {
      errors.push(`Item ${index}: Missing item_unique_identifier`);
    }
    
    if (!item.associated_category_unique_identifier) {
      errors.push(`Item ${index}: Missing associated_category_unique_identifier`);
    }
    
    if (item.item_price_value === undefined || item.item_price_value < 0) {
      errors.push(`Item ${index}: Invalid item_price_value`);
    }
    
    // Check if category exists
    const categoryExists = categories.find(
      cat => cat.category_unique_identifier === item.associated_category_unique_identifier
    );
    if (!categoryExists) {
      errors.push(`Item ${index}: Referenced category ${item.associated_category_unique_identifier} not found`);
    }
  });
  
  return errors;
}

module.exports = {
  convertItemsToPLUs,
  validateItemsForPLU
};

--- File: /packages/backend/src/lib/converters/vectron/utils/encoding.js ---

/**
 * Vectron Encoding Utilities
 * 
 * Windows-1252 encoding and text sanitization for Vectron format
 * See VECTRON_CONVERTER_PLAN.md section 3.6 for details
 * 
 * @module VectronEncodingUtils
 */

const iconv = require('iconv-lite');

/**
 * Convert UTF-8 text to Windows-1252 encoding
 * @param {string} text - Text to encode
 * @returns {Buffer} Windows-1252 encoded buffer
 */
function encodeToWindows1252(text) {
  return iconv.encode(text, 'win1252');
}

/**
 * Clean and truncate text for Vectron compatibility
 * @param {string} text - Text to sanitize
 * @param {number} maxLength - Maximum length (default: 40)
 * @returns {string} Sanitized text
 */
function sanitizeText(text, maxLength = 40) {
  if (!text || typeof text !== 'string') {
    return '';
  }
  
  return text
    .replace(/[^\x20-\xFF]/g, '') // Remove invalid characters for Windows-1252
    .replace(/[\r\n\t]/g, ' ')    // Replace line breaks with spaces
    .replace(/\s+/g, ' ')        // Normalize whitespace
    .substring(0, maxLength)
    .trim();
}

/**
 * Escape quotes for TX field values in Vectron format
 * @param {string} text - Text to escape
 * @returns {string} Escaped text
 */
function escapeVectronText(text) {
  if (!text || typeof text !== 'string') {
    return '';
  }
  
  // Escape double quotes by doubling them
  return text.replace(/"/g, '""');
}

/**
 * Validate text for Vectron compatibility
 * @param {string} text - Text to validate
 * @returns {boolean} True if valid
 */
function isValidVectronText(text) {
  if (!text || typeof text !== 'string') {
    return true; // Empty text is valid
  }
  
  try {
    // Check if text can be encoded to Windows-1252
    iconv.encode(text, 'win1252');
    return true;
  } catch (error) {
    return false;
  }
}

module.exports = {
  encodeToWindows1252,
  sanitizeText,
  escapeVectronText,
  isValidVectronText
};

--- File: /packages/backend/src/lib/converters/vectron/utils/formatter.js ---

/**
 * Vectron Line Formatting Utilities
 * 
 * Formats data into Vectron import line format
 * See VECTRON_CONVERTER_PLAN.md section 3.7 for details
 * 
 * @module VectronLineFormatter
 */

const { escapeVectronText } = require('./encoding');

class VectronLineFormatter {
  /**
   * Format header line (LineType 100)
   * @param {number} kassennummer - Cash register number
   * @param {string} mode - Import mode (A=Add, O=Overwrite, R=Replace)
   * @param {Object} options - Additional options
   * @returns {string} Formatted header line
   */
  formatHeaderLine(kassennummer, mode = 'A', options = {}) {
    const fields = [
      '1,1',                    // Interface version
      `10,${kassennummer}`,     // Cash register number
      `24,${mode}`,             // Import mode
      '51,1'                    // Character encoding (ANSI)
    ];
    
    // Add optional fields if provided
    if (options.date) {
      fields.push(`2,${options.date}`);
    }
    if (options.time) {
      fields.push(`3,${options.time}`);
    }
    if (options.programName) {
      fields.push(`5,TX:"${escapeVectronText(options.programName)}"`);
    }
    if (options.kasseName) {
      fields.push(`11,TX:"${escapeVectronText(options.kasseName)}"`);
    }
    
    return `100,0,${fields.join(';')};\r\n`;
  }
  
  /**
   * Format PLU line (LineType 101)
   * @param {number} pluNumber - PLU number
   * @param {Array} fields - Field definitions
   * @returns {string} Formatted PLU line
   */
  formatPLULine(pluNumber, fields) {
    const fieldStrings = fields.map(field => {
      if (field.type === 'TX') {
        return `${field.id},TX:"${escapeVectronText(field.value)}"`;
      } else if (field.type === 'VA') {
        return `${field.id},VA:${parseFloat(field.value).toFixed(2)}`;
      } else if (field.type === 'NR') {
        return `${field.id},NR:${field.value}`;
      } else if (field.type === 'INT') {
        return `${field.id},INT:${field.value}`;
      } else {
        return `${field.id},${field.type}:${field.value}`;
      }
    }).join(';');
    
    return `101,${pluNumber},${fieldStrings};\r\n`;
  }
  
  /**
   * Format Warengruppen line (LineType 102)
   * @param {number} wgNumber - Warengruppe number
   * @param {Array} fields - Field definitions
   * @returns {string} Formatted Warengruppen line
   */
  formatWarengruppenLine(wgNumber, fields) {
    const fieldStrings = fields.map(field => {
      if (field.type === 'TX') {
        return `${field.id},TX:"${escapeVectronText(field.value)}"`;
      } else if (field.type === 'NR') {
        return `${field.id},NR:${field.value}`;
      } else {
        return `${field.id},${field.type}:${field.value}`;
      }
    }).join(';');
    
    return `102,${wgNumber},${fieldStrings};\r\n`;
  }
  
  /**
   * Format Auswahlfenster line (LineType 152)
   * @param {number} windowNumber - Window number
   * @param {Array} fields - Field definitions
   * @returns {string} Formatted Auswahlfenster line
   */
  formatAuswahlfensterLine(windowNumber, fields) {
    const fieldStrings = fields.map(field => {
      if (field.type === 'TX') {
        return `${field.id},TX:"${escapeVectronText(field.value)}"`;
      } else if (field.type === 'NR') {
        return `${field.id},NR:${field.value}`;
      } else if (field.type === 'INT') {
        return `${field.id},INT:${field.value}`;
      } else {
        return `${field.id},${field.type}:${field.value}`;
      }
    }).join(';');
    
    return `152,${windowNumber},${fieldStrings};\r\n`;
  }
  
  /**
   * Validate line length
   * @param {string} line - Line to validate
   * @param {number} maxLength - Maximum allowed length
   * @returns {boolean} True if valid
   */
  validateLineLength(line, maxLength = 250) {
    return line.length <= maxLength;
  }
}

module.exports = VectronLineFormatter;

--- File: /packages/backend/src/lib/converters/vectron/utils/multilingual.js ---

/**
 * Multilingual Support Utilities for Vectron Converter
 * 
 * Handles multiple language support and text localization
 * See VECTRON_CONVERTER_PLAN.md for multilingual details
 * 
 * @module VectronMultilingualUtils
 */

const { sanitizeText } = require('./encoding');

/**
 * Multilingual text manager for Vectron conversion
 */
class MultilingualTextManager {
  constructor(options = {}) {
    this.defaultLanguage = options.defaultLanguage || 'de';
    this.supportedLanguages = options.supportedLanguages || ['de', 'en'];
    this.fallbackLanguage = options.fallbackLanguage || 'en';
    this.textLimits = options.textLimits || {
      itemName: 40,
      categoryName: 30,
      buttonName: 20,
      description: 60
    };
  }
  
  /**
   * Extract localized text with fallback logic
   * @param {Object} textObj - Multilingual text object
   * @param {string} fieldType - Type of field (for length limits)
   * @param {string} language - Preferred language (optional)
   * @returns {string} Localized text
   */
  getLocalizedText(textObj, fieldType = 'default', language = null) {
    if (!textObj || typeof textObj !== 'object') {
      return '';
    }
    
    const targetLanguage = language || this.defaultLanguage;
    const maxLength = this.textLimits[fieldType] || 40;
    
    // Try target language first
    let text = textObj[targetLanguage];
    
    // Fallback to default language
    if (!text) {
      text = textObj[this.defaultLanguage];
    }
    
    // Fallback to fallback language
    if (!text) {
      text = textObj[this.fallbackLanguage];
    }
    
    // Fallback to first available language
    if (!text) {
      const availableKeys = Object.keys(textObj);
      if (availableKeys.length > 0) {
        text = textObj[availableKeys[0]];
      }
    }
    
    if (!text) {
      return '';
    }
    
    return sanitizeText(text, maxLength);
  }
  
  /**
   * Get all available language variants for Vectron multi-language fields
   * @param {Object} textObj - Multilingual text object
   * @param {string} fieldType - Type of field (for length limits)
   * @returns {Array} Array of language variants
   */
  getAllLanguageVariants(textObj, fieldType = 'default') {
    if (!textObj || typeof textObj !== 'object') {
      return [];
    }
    
    const maxLength = this.textLimits[fieldType] || 40;
    const variants = [];
    
    // Process supported languages in order
    this.supportedLanguages.forEach(lang => {
      if (textObj[lang]) {
        variants.push({
          language: lang,
          text: sanitizeText(textObj[lang], maxLength),
          isPrimary: lang === this.defaultLanguage
        });
      }
    });
    
    // Add any additional languages not in supported list
    Object.keys(textObj).forEach(lang => {
      if (!this.supportedLanguages.includes(lang) && textObj[lang]) {
        variants.push({
          language: lang,
          text: sanitizeText(textObj[lang], maxLength),
          isPrimary: false
        });
      }
    });
    
    return variants;
  }
  
  /**
   * Generate Vectron multilingual field mappings
   * @param {Object} textObj - Multilingual text object
   * @param {string} fieldType - Type of field
   * @param {number} baseFieldId - Base field ID (e.g., 101 for Name 1)
   * @returns {Array} Array of field mappings
   */
  generateMultilingualFields(textObj, fieldType, baseFieldId) {
    const variants = this.getAllLanguageVariants(textObj, fieldType);
    const fields = [];
    
    variants.forEach((variant, index) => {
      if (index < 4) { // Vectron typically supports up to 4 language variants
        fields.push({
          id: baseFieldId + index,
          type: 'TX',
          value: variant.text,
          language: variant.language,
          isPrimary: variant.isPrimary
        });
      }
    });
    
    return fields;
  }
  
  /**
   * Detect primary language from multilingual object
   * @param {Object} textObj - Multilingual text object
   * @returns {string} Detected primary language
   */
  detectPrimaryLanguage(textObj) {
    if (!textObj || typeof textObj !== 'object') {
      return this.defaultLanguage;
    }
    
    // Check if default language is available
    if (textObj[this.defaultLanguage]) {
      return this.defaultLanguage;
    }
    
    // Check supported languages in order
    for (const lang of this.supportedLanguages) {
      if (textObj[lang]) {
        return lang;
      }
    }
    
    // Return first available language
    const availableKeys = Object.keys(textObj);
    return availableKeys.length > 0 ? availableKeys[0] : this.defaultLanguage;
  }
  
  /**
   * Validate multilingual text object
   * @param {Object} textObj - Multilingual text object
   * @param {string} fieldName - Field name for error reporting
   * @returns {Array} Array of validation errors
   */
  validateMultilingualText(textObj, fieldName) {
    const errors = [];
    
    if (!textObj) {
      errors.push(`${fieldName}: Multilingual text object is required`);
      return errors;
    }
    
    if (typeof textObj !== 'object') {
      errors.push(`${fieldName}: Must be an object with language keys`);
      return errors;
    }
    
    const availableKeys = Object.keys(textObj);
    if (availableKeys.length === 0) {
      errors.push(`${fieldName}: At least one language variant is required`);
      return errors;
    }
    
    // Check if at least one supported language is present
    const hasSupported = this.supportedLanguages.some(lang => textObj[lang]);
    if (!hasSupported) {
      errors.push(`${fieldName}: Should contain at least one supported language (${this.supportedLanguages.join(', ')})`);
    }
    
    // Validate individual language entries
    availableKeys.forEach(lang => {
      const text = textObj[lang];
      if (typeof text !== 'string') {
        errors.push(`${fieldName}.${lang}: Must be a string`);
      } else if (text.trim().length === 0) {
        errors.push(`${fieldName}.${lang}: Cannot be empty`);
      }
    });
    
    return errors;
  }
  
  /**
   * Create multilingual text object from single text
   * @param {string} text - Single language text
   * @param {string} language - Language code
   * @returns {Object} Multilingual text object
   */
  createMultilingualText(text, language = null) {
    const lang = language || this.defaultLanguage;
    const multilingualObj = {};
    multilingualObj[lang] = text;
    return multilingualObj;
  }
  
  /**
   * Merge multiple multilingual text objects
   * @param {...Object} textObjects - Multilingual text objects to merge
   * @returns {Object} Merged multilingual text object
   */
  mergeMultilingualTexts(...textObjects) {
    const merged = {};
    
    textObjects.forEach(textObj => {
      if (textObj && typeof textObj === 'object') {
        Object.assign(merged, textObj);
      }
    });
    
    return merged;
  }
  
  /**
   * Convert old-style single language text to multilingual
   * @param {string|Object} text - Text to convert
   * @param {string} defaultLang - Default language if text is string
   * @returns {Object} Multilingual text object
   */
  normalizeToMultilingual(text, defaultLang = null) {
    const lang = defaultLang || this.defaultLanguage;
    
    if (typeof text === 'string') {
      return this.createMultilingualText(text, lang);
    }
    
    if (typeof text === 'object' && text !== null) {
      return text;
    }
    
    return {};
  }
  
  /**
   * Get language-specific field mapping for Vectron
   * @param {string} language - Language code
   * @returns {Object} Language field mapping
   */
  getLanguageFieldMapping(language) {
    // Vectron language field mappings
    const languageMappings = {
      'de': { code: 1, name: 'Deutsch' },
      'en': { code: 2, name: 'English' },
      'fr': { code: 3, name: 'Français' },
      'es': { code: 4, name: 'Español' },
      'it': { code: 5, name: 'Italiano' },
      'nl': { code: 6, name: 'Nederlands' },
      'pt': { code: 7, name: 'Português' },
      'ru': { code: 8, name: 'Русский' }
    };
    
    return languageMappings[language.toLowerCase()] || { code: 1, name: language };
  }
  
  /**
   * Generate language configuration for Vectron header
   * @returns {Array} Language configuration fields
   */
  generateLanguageConfig() {
    const fields = [];
    
    // Primary language
    const primaryMapping = this.getLanguageFieldMapping(this.defaultLanguage);
    fields.push({
      id: 15, // Primary language field
      type: 'NR',
      value: primaryMapping.code
    });
    
    // Secondary languages
    this.supportedLanguages.slice(1, 4).forEach((lang, index) => {
      const mapping = this.getLanguageFieldMapping(lang);
      fields.push({
        id: 16 + index, // Secondary language fields (16, 17, 18)
        type: 'NR',
        value: mapping.code
      });
    });
    
    return fields;
  }
}

/**
 * Create language-aware field generator
 * @param {Object} options - Configuration options
 * @returns {MultilingualTextManager} Text manager instance
 */
function createMultilingualManager(options = {}) {
  return new MultilingualTextManager(options);
}

/**
 * Helper function to extract text with fallback
 * @param {Object} textObj - Multilingual text object
 * @param {string} defaultLanguage - Default language
 * @param {string} fallbackLanguage - Fallback language
 * @returns {string} Extracted text
 */
function extractTextWithFallback(textObj, defaultLanguage = 'de', fallbackLanguage = 'en') {
  if (!textObj || typeof textObj !== 'object') {
    return '';
  }
  
  return textObj[defaultLanguage] || 
         textObj[fallbackLanguage] || 
         textObj[Object.keys(textObj)[0]] || 
         '';
}

/**
 * Helper function to detect available languages in data
 * @param {Object} data - OOP-POS-MDF data
 * @returns {Array} Array of detected languages
 */
function detectAvailableLanguages(data) {
  const languages = new Set();
  
  // Check company meta information
  if (data.company_details?.meta_information) {
    const meta = data.company_details.meta_information;
    if (meta.default_language) {
      languages.add(meta.default_language);
    }
    if (meta.supported_languages) {
      meta.supported_languages.forEach(lang => languages.add(lang));
    }
  }
  
  // Check category names
  const categories = data.company_details?.branches?.[0]?.point_of_sale_devices?.[0]?.categories_for_this_pos || [];
  categories.forEach(category => {
    if (category.category_names) {
      Object.keys(category.category_names).forEach(lang => languages.add(lang));
    }
  });
  
  // Check item names
  const items = data.company_details?.branches?.[0]?.point_of_sale_devices?.[0]?.items_for_this_pos || [];
  items.forEach(item => {
    if (item.display_names) {
      Object.values(item.display_names).forEach(nameObj => {
        if (nameObj && typeof nameObj === 'object') {
          Object.keys(nameObj).forEach(lang => languages.add(lang));
        }
      });
    }
  });
  
  return Array.from(languages).sort();
}

module.exports = {
  MultilingualTextManager,
  createMultilingualManager,
  extractTextWithFallback,
  detectAvailableLanguages
};

--- File: /packages/backend/src/lib/converters/vectron/utils/numbering.js ---

/**
 * Vectron Numbering System Utilities
 * 
 * PLU and Warengruppen numbering system for Vectron format
 * See VECTRON_CONVERTER_PLAN.md for numbering details
 * 
 * @module VectronNumberingUtils
 */

class PLUNumberGenerator {
  constructor(options = {}) {
    this.startNumber = options.startNumber || 1000;
    this.blockSize = options.blockSize || 100;
    this.reserveBlocks = options.reserveBlocks || 10;
    this.categoryIndexMap = new Map();
    this.usedNumbers = new Set();
  }
  
  /**
   * Calculate PLU number for item
   * @param {number} categoryId - Category identifier
   * @param {number} itemIndex - Item index within category
   * @returns {number} PLU number
   */
  calculatePLUNumber(categoryId, itemIndex) {
    let categoryIndex;
    
    if (this.categoryIndexMap.has(categoryId)) {
      categoryIndex = this.categoryIndexMap.get(categoryId);
    } else {
      categoryIndex = this.categoryIndexMap.size;
      this.categoryIndexMap.set(categoryId, categoryIndex);
    }
    
    const pluNumber = this.startNumber + (categoryIndex * this.blockSize) + itemIndex + 1;
    this.usedNumbers.add(pluNumber);
    
    return pluNumber;
  }
  
  /**
   * Get next available PLU number
   * @returns {number} Next available PLU number
   */
  getNextAvailablePLU() {
    let candidate = this.startNumber;
    while (this.usedNumbers.has(candidate)) {
      candidate++;
    }
    this.usedNumbers.add(candidate);
    return candidate;
  }
  
  /**
   * Reset numbering system
   */
  reset() {
    this.categoryIndexMap.clear();
    this.usedNumbers.clear();
  }
}

class WarengruppenNumberGenerator {
  constructor(options = {}) {
    this.startNumber = options.startNumber || 900;
    this.useDefaults = options.useDefaults !== false;
    this.defaultMappings = options.defaultMappings || {
      'SPEISEN': 941,
      'GETRÄNKE': 951,
      'GETRÄNKE_REDUZIERT': 953,
      'FOOD': 941,
      'DRINKS': 951,
      'BEVERAGES': 951
    };
    this.categoryNumberMap = new Map();
    this.usedNumbers = new Set();
    
    // Reserve default numbers
    if (this.useDefaults) {
      Object.values(this.defaultMappings).forEach(num => {
        this.usedNumbers.add(num);
      });
    }
  }
  
  /**
   * Generate Warengruppe number for category
   * @param {number} categoryId - Category identifier
   * @param {string} categoryName - Category name for default mapping
   * @returns {number} Warengruppe number
   */
  generateWarengruppeNumber(categoryId, categoryName = '') {
    if (this.categoryNumberMap.has(categoryId)) {
      return this.categoryNumberMap.get(categoryId);
    }
    
    let wgNumber;
    
    // Try default mapping based on name
    if (this.useDefaults && categoryName) {
      const normalizedName = categoryName.toUpperCase();
      for (const [key, value] of Object.entries(this.defaultMappings)) {
        if (normalizedName.includes(key)) {
          wgNumber = value;
          break;
        }
      }
    }
    
    // If no default mapping found, use next available number
    if (!wgNumber) {
      wgNumber = this.getNextAvailableNumber();
    }
    
    this.categoryNumberMap.set(categoryId, wgNumber);
    this.usedNumbers.add(wgNumber);
    
    return wgNumber;
  }
  
  /**
   * Get next available Warengruppe number
   * @returns {number} Next available number
   */
  getNextAvailableNumber() {
    let candidate = this.startNumber;
    while (this.usedNumbers.has(candidate)) {
      candidate++;
    }
    return candidate;
  }
  
  /**
   * Reset numbering system
   */
  reset() {
    this.categoryNumberMap.clear();
    this.usedNumbers.clear();
    
    // Re-reserve default numbers
    if (this.useDefaults) {
      Object.values(this.defaultMappings).forEach(num => {
        this.usedNumbers.add(num);
      });
    }
  }
}

// Standard Warengruppen numbers from Vectron defaults
const STANDARD_WARENGRUPPEN = {
  941: "SPEISEN 19% FESTPREIS",
  951: "GETRÄNKE 19% FESTPREIS", 
  953: "GETRÄNKE 7% FESTPREIS",
  940: "SPEISEN OFFEN",
  950: "GETRÄNKE OFFEN"
};

module.exports = {
  PLUNumberGenerator,
  WarengruppenNumberGenerator,
  STANDARD_WARENGRUPPEN
};

--- File: /packages/backend/src/lib/converters/vectron/validation.js ---

/**
 * Vectron Output Validation
 * 
 * Validates Vectron import format compliance
 * See VECTRON_CONVERTER_PLAN.md section 5 for details
 * 
 * @module VectronValidation
 */

const { isValidVectronText, encodeToWindows1252 } = require('./utils/encoding');

/**
 * Validate complete Vectron output
 * @param {string} vectronOutput - Complete Vectron import content
 * @param {Object} options - Validation options
 * @returns {Object} Validation result
 */
function validateVectronOutput(vectronOutput, options = {}) {
  const errors = [];
  const warnings = [];
  const lines = vectronOutput.split('\r\n').filter(line => line.length > 0);
  
  if (lines.length === 0) {
    errors.push('Output is empty');
    return { isValid: false, errors, warnings };
  }
  
  // Validate header line
  const headerValidation = validateHeaderLine(lines[0]);
  errors.push(...headerValidation.errors);
  warnings.push(...headerValidation.warnings);
  
  // Validate all lines
  lines.forEach((line, index) => {
    const lineValidation = validateSingleLine(line, index + 1, options);
    errors.push(...lineValidation.errors);
    warnings.push(...lineValidation.warnings);
  });
  
  // Check for structural issues
  const structuralValidation = validateStructure(lines);
  errors.push(...structuralValidation.errors);
  warnings.push(...structuralValidation.warnings);
  
  const isValid = errors.length === 0 && (options.warningsAsErrors ? warnings.length === 0 : true);
  
  return {
    isValid,
    errors,
    warnings,
    lineCount: lines.length,
    stats: generateStats(lines)
  };
}

/**
 * Validate header line (LineType 100)
 * @param {string} headerLine - Header line
 * @returns {Object} Validation result
 */
function validateHeaderLine(headerLine) {
  const errors = [];
  const warnings = [];
  
  if (!headerLine.startsWith('100,0,')) {
    errors.push('Header line must start with "100,0,"');
    return { errors, warnings };
  }
  
  // Parse header fields
  const parts = headerLine.split(',');
  if (parts.length < 3) {
    errors.push('Header line has insufficient parts');
    return { errors, warnings };
  }
  
  // Check for required fields
  const fieldString = headerLine.substring(6); // Remove "100,0,"
  const fields = fieldString.split(';').filter(f => f.length > 0);
  
  const requiredFields = ['1', '10', '24', '51'];
  const foundFields = new Set();
  
  fields.forEach(field => {
    const [fieldId] = field.split(',');
    foundFields.add(fieldId);
  });
  
  requiredFields.forEach(reqField => {
    if (!foundFields.has(reqField)) {
      errors.push(`Header missing required field ${reqField}`);
    }
  });
  
  return { errors, warnings };
}

/**
 * Validate single line
 * @param {string} line - Line to validate
 * @param {number} lineNumber - Line number
 * @param {Object} options - Validation options
 * @returns {Object} Validation result
 */
function validateSingleLine(line, lineNumber, options = {}) {
  const errors = [];
  const warnings = [];
  const maxLength = options.maxLineLength || 250;
  
  // Check line length
  if (line.length > maxLength) {
    errors.push(`Line ${lineNumber}: Exceeds maximum length of ${maxLength} characters (${line.length})`);
  }
  
  // Check line ending
  if (!line.endsWith('\\r\\n') && lineNumber > 1) {
    warnings.push(`Line ${lineNumber}: Should end with \\r\\n`);
  }
  
  // Check basic format
  if (!line.match(/^\d+,/)) {
    errors.push(`Line ${lineNumber}: Must start with LineType number followed by comma`);
  }
  
  // Check encoding compatibility
  try {
    encodeToWindows1252(line);
  } catch (error) {
    errors.push(`Line ${lineNumber}: Contains characters not compatible with Windows-1252`);
  }
  
  // Validate specific line types
  const lineType = line.split(',')[0];
  switch (lineType) {
    case '100':
      // Header validation already done
      break;
    case '101':
      const pluValidation = validatePLULine(line, lineNumber);
      errors.push(...pluValidation.errors);
      warnings.push(...pluValidation.warnings);
      break;
    case '102':
      const wgValidation = validateWarengruppenLine(line, lineNumber);
      errors.push(...wgValidation.errors);
      warnings.push(...wgValidation.warnings);
      break;
    case '152':
      const awValidation = validateAuswahlfensterLine(line, lineNumber);
      errors.push(...awValidation.errors);
      warnings.push(...awValidation.warnings);
      break;
    default:
      warnings.push(`Line ${lineNumber}: Unknown LineType ${lineType}`);
  }
  
  return { errors, warnings };
}

/**
 * Validate PLU line (LineType 101)
 * @param {string} line - PLU line
 * @param {number} lineNumber - Line number
 * @returns {Object} Validation result
 */
function validatePLULine(line, lineNumber) {
  const errors = [];
  const warnings = [];
  
  const parts = line.split(',');
  if (parts.length < 3) {
    errors.push(`Line ${lineNumber}: PLU line must have at least LineType, RecordId, and fields`);
    return { errors, warnings };
  }
  
  const pluNumber = parseInt(parts[1]);
  if (isNaN(pluNumber) || pluNumber < 1) {
    errors.push(`Line ${lineNumber}: Invalid PLU number '${parts[1]}'`);
  }
  
  // Check for required PLU fields
  const fieldString = parts.slice(2).join(',');
  const hasName = fieldString.includes('101,TX:');
  const hasPrice = fieldString.includes('201,VA:');
  
  if (!hasName) {
    warnings.push(`Line ${lineNumber}: PLU missing name field (101,TX:)`);
  }
  
  if (!hasPrice) {
    warnings.push(`Line ${lineNumber}: PLU missing price field (201,VA:)`);
  }
  
  return { errors, warnings };
}

/**
 * Validate Warengruppen line (LineType 102)
 * @param {string} line - Warengruppen line
 * @param {number} lineNumber - Line number
 * @returns {Object} Validation result
 */
function validateWarengruppenLine(line, lineNumber) {
  const errors = [];
  const warnings = [];
  
  const parts = line.split(',');
  if (parts.length < 3) {
    errors.push(`Line ${lineNumber}: Warengruppen line must have at least LineType, RecordId, and fields`);
    return { errors, warnings };
  }
  
  const wgNumber = parseInt(parts[1]);
  if (isNaN(wgNumber) || wgNumber < 1) {
    errors.push(`Line ${lineNumber}: Invalid Warengruppe number '${parts[1]}'`);
  }
  
  // Check for required WG fields
  const fieldString = parts.slice(2).join(',');
  const hasName = fieldString.includes('101,TX:');
  
  if (!hasName) {
    warnings.push(`Line ${lineNumber}: Warengruppe missing name field (101,TX:)`);
  }
  
  return { errors, warnings };
}

/**
 * Validate Auswahlfenster line (LineType 152)
 * @param {string} line - Auswahlfenster line
 * @param {number} lineNumber - Line number
 * @returns {Object} Validation result
 */
function validateAuswahlfensterLine(line, lineNumber) {
  const errors = [];
  const warnings = [];
  
  const parts = line.split(',');
  if (parts.length < 3) {
    errors.push(`Line ${lineNumber}: Auswahlfenster line must have at least LineType, RecordId, and fields`);
    return { errors, warnings };
  }
  
  const awNumber = parseInt(parts[1]);
  if (isNaN(awNumber) || awNumber < 1) {
    errors.push(`Line ${lineNumber}: Invalid Auswahlfenster number '${parts[1]}'`);
  }
  
  return { errors, warnings };
}

/**
 * Validate overall structure
 * @param {Array} lines - All lines
 * @returns {Object} Validation result
 */
function validateStructure(lines) {
  const errors = [];
  const warnings = [];
  
  // Must start with header
  if (!lines[0]?.startsWith('100,')) {
    errors.push('File must start with header line (LineType 100)');
  }
  
  // Check for duplicate PLU numbers
  const pluNumbers = new Set();
  const wgNumbers = new Set();
  
  lines.forEach((line, index) => {
    const parts = line.split(',');
    const lineType = parts[0];
    const recordId = parts[1];
    
    if (lineType === '101') {
      if (pluNumbers.has(recordId)) {
        errors.push(`Duplicate PLU number ${recordId} found`);
      }
      pluNumbers.add(recordId);
    } else if (lineType === '102') {
      if (wgNumbers.has(recordId)) {
        errors.push(`Duplicate Warengruppe number ${recordId} found`);
      }
      wgNumbers.add(recordId);
    }
  });
  
  return { errors, warnings };
}

/**
 * Generate statistics about the output
 * @param {Array} lines - All lines
 * @returns {Object} Statistics
 */
function generateStats(lines) {
  const stats = {
    totalLines: lines.length,
    headerLines: 0,
    pluLines: 0,
    warengruppenLines: 0,
    auswahlfensterLines: 0,
    otherLines: 0,
    maxLineLength: 0,
    avgLineLength: 0
  };
  
  let totalLength = 0;
  
  lines.forEach(line => {
    const lineType = line.split(',')[0];
    const length = line.length;
    
    totalLength += length;
    stats.maxLineLength = Math.max(stats.maxLineLength, length);
    
    switch (lineType) {
      case '100':
        stats.headerLines++;
        break;
      case '101':
        stats.pluLines++;
        break;
      case '102':
        stats.warengruppenLines++;
        break;
      case '152':
        stats.auswahlfensterLines++;
        break;
      default:
        stats.otherLines++;
    }
  });
  
  stats.avgLineLength = Math.round(totalLength / lines.length);
  
  return stats;
}

/**
 * Validate OOP-POS-MDF input before conversion
 * @param {Object} oopData - OOP-POS-MDF data
 * @returns {Object} Validation result
 */
function validateOOPInput(oopData) {
  const errors = [];
  const warnings = [];
  
  if (!oopData) {
    errors.push('Input data is required');
    return { isValid: false, errors, warnings };
  }
  
  if (!oopData.company_details) {
    errors.push('Missing company_details');
  }
  
  if (!oopData.company_details?.branches?.length) {
    errors.push('No branches defined');
  }
  
  const branch = oopData.company_details?.branches?.[0];
  if (branch && !branch.point_of_sale_devices?.length) {
    errors.push('No POS devices defined in first branch');
  }
  
  const posDevice = branch?.point_of_sale_devices?.[0];
  if (posDevice) {
    if (!posDevice.categories_for_this_pos?.length) {
      warnings.push('No categories defined for POS device');
    }
    
    if (!posDevice.items_for_this_pos?.length) {
      warnings.push('No items defined for POS device');
    }
  }
  
  const isValid = errors.length === 0;
  
  return { isValid, errors, warnings };
}

module.exports = {
  validateVectronOutput,
  validateOOPInput,
  validateSingleLine,
  generateStats
};

--- File: /packages/backend/src/lib/converters/vectron/warengruppen.js ---

/**
 * Vectron Warengruppen Converter (LineType 102)
 * 
 * Converts OOP-POS-MDF categories to Vectron Warengruppen format
 * See VECTRON_CONVERTER_PLAN.md section 3.3 for details
 * 
 * @module VectronWarengruppenConverter
 */

const VectronLineFormatter = require('./utils/formatter');
const { sanitizeText } = require('./utils/encoding');
const VectronFieldMapper = require('./mapping');

/**
 * Convert OOP-POS-MDF categories to Vectron Warengruppen lines
 * @param {Array} categories - Categories from OOP-POS-MDF
 * @param {Object} globalConfig - Global configuration
 * @param {Object} options - Conversion options
 * @returns {Array} Array of Warengruppen lines
 */
function convertCategoriesToWarengruppen(categories, globalConfig, options = {}) {
  if (!categories || !Array.isArray(categories)) {
    return [];
  }
  
  const formatter = new VectronLineFormatter();
  const mapper = new VectronFieldMapper(options);
  const defaultLanguage = options.defaultLanguage || 'de';
  const wgLines = [];
  
  categories.forEach(category => {
    try {
      const wgLine = convertSingleCategoryToWarengruppe(
        category,
        globalConfig,
        mapper,
        formatter,
        defaultLanguage
      );
      if (wgLine) {
        wgLines.push(wgLine);
      }
    } catch (error) {
      console.error(`Error converting category ${category.category_unique_identifier}: ${error.message}`);
      if (options.strictMode) {
        throw error;
      }
    }
  });
  
  return wgLines;
}

/**
 * Convert single category to Warengruppe line
 * @param {Object} category - Category from OOP-POS-MDF
 * @param {Object} globalConfig - Global configuration
 * @param {VectronFieldMapper} mapper - Field mapper
 * @param {VectronLineFormatter} formatter - Line formatter
 * @param {string} defaultLanguage - Default language
 * @returns {string} Warengruppe line
 */
function convertSingleCategoryToWarengruppe(category, globalConfig, mapper, formatter, defaultLanguage) {
  // Generate Warengruppe number
  const categoryName = getLocalizedText(category.category_names, defaultLanguage);
  const wgNumber = mapper.generateWarengruppeNumber(
    category.category_unique_identifier,
    categoryName
  );
  
  // Prepare field array
  const fields = [];
  
  // Names (101-199)
  if (categoryName) {
    fields.push({
      id: 101,
      type: 'TX',
      value: sanitizeText(categoryName, 30)
    });
  }
  
  // Alternative name if available
  const alternativeLanguages = Object.keys(category.category_names || {});
  const altLanguage = alternativeLanguages.find(lang => lang !== defaultLanguage);
  if (altLanguage) {
    const altName = category.category_names[altLanguage];
    if (altName && altName !== categoryName) {
      fields.push({
        id: 102,
        type: 'TX',
        value: sanitizeText(altName, 30)
      });
    }
  }
  
  // Main group (201)
  const mainGroup = category.default_linked_main_group_unique_identifier || 
                   mapper.mapCategoryTypeToMainGroup(category.category_type);
  fields.push({
    id: 201,
    type: 'NR',
    value: mainGroup
  });
  
  // Default tax rate (401)
  const taxRateId = getDefaultTaxRateForCategory(category, globalConfig);
  const taxRatePercentage = mapper.extractTaxRatePercentage(taxRateId, globalConfig.tax_rates_definitions);
  const vectronTaxRate = mapper.mapTaxRate(taxRatePercentage);
  fields.push({
    id: 401,
    type: 'NR',
    value: vectronTaxRate
  });
  
  // Printer assignment (501) - optional
  if (category.default_printer_id) {
    fields.push({
      id: 501,
      type: 'NR',
      value: category.default_printer_id
    });
  }
  
  // Active flag (9001)
  const isActive = category.is_active !== false;
  fields.push({
    id: 9001,
    type: 'NR',
    value: isActive ? 0 : 1
  });
  
  return formatter.formatWarengruppenLine(wgNumber, fields);
}

/**
 * Get localized text from multilingual object
 * @param {Object} textObj - Multilingual text object
 * @param {string} defaultLanguage - Default language
 * @returns {string} Localized text
 */
function getLocalizedText(textObj, defaultLanguage) {
  if (!textObj || typeof textObj !== 'object') {
    return '';
  }
  
  return textObj[defaultLanguage] || 
         textObj[Object.keys(textObj)[0]] || 
         '';
}

/**
 * Get default tax rate for category
 * @param {Object} category - Category object
 * @param {Object} globalConfig - Global configuration
 * @returns {number} Tax rate identifier
 */
function getDefaultTaxRateForCategory(category, globalConfig) {
  // For drinks, use drink tax rate; for food, use food tax rate
  if (category.category_type === 'drink') {
    return globalConfig.default_linked_drink_tax_rate_unique_identifier || 1;
  } else if (category.category_type === 'food') {
    return globalConfig.default_linked_food_tax_rate_unique_identifier || 2;
  }
  
  // Default to first available tax rate
  return globalConfig.tax_rates_definitions?.[0]?.tax_rate_unique_identifier || 1;
}

/**
 * Validate categories for Warengruppen conversion
 * @param {Array} categories - Categories to validate
 * @returns {Array} Array of validation errors
 */
function validateCategoriesForWarengruppen(categories) {
  const errors = [];
  
  if (!categories || !Array.isArray(categories)) {
    errors.push('Categories must be an array');
    return errors;
  }
  
  categories.forEach((category, index) => {
    if (!category.category_unique_identifier) {
      errors.push(`Category ${index}: Missing category_unique_identifier`);
    }
    
    if (!category.category_names || typeof category.category_names !== 'object') {
      errors.push(`Category ${index}: Missing or invalid category_names`);
    } else {
      const hasValidName = Object.values(category.category_names).some(
        name => name && typeof name === 'string' && name.trim().length > 0
      );
      if (!hasValidName) {
        errors.push(`Category ${index}: No valid category names found`);
      }
    }
    
    if (category.category_type && !['drink', 'food', 'service', 'other'].includes(category.category_type)) {
      errors.push(`Category ${index}: Invalid category_type '${category.category_type}'`);
    }
  });
  
  return errors;
}

/**
 * Get categories that are actually used by items
 * @param {Array} categories - All categories
 * @param {Array} items - All items
 * @returns {Array} Used categories
 */
function getUsedCategories(categories, items) {
  if (!items || !Array.isArray(items)) {
    return categories || [];
  }
  
  const usedCategoryIds = new Set(
    items.map(item => item.associated_category_unique_identifier)
  );
  
  return (categories || []).filter(
    category => usedCategoryIds.has(category.category_unique_identifier)
  );
}

module.exports = {
  convertCategoriesToWarengruppen,
  validateCategoriesForWarengruppen,
  getUsedCategories
};

--- File: /packages/backend/src/lib/menu_parser_llm.js ---

/**
 * eckasse Menu Parser with LLM Integration
 * 
 * Автоматически конвертирует отсканированные меню в OOP-POS-MDF формат
 * Поддерживает Google Gemini, OpenAI GPT, и Claude
 * 
 * Features:
 * - LLM для извлечения структурированных данных из изображений меню
 * - Автоматическое определение категорий и цен
 * - Многоязычная поддержка
 * - Валидация и коррекция данных
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

const fs = require('fs').promises;
const path = require('path');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const { getGeminiModel } = require('../services/llm.provider');

class MenuParserLLM {
  constructor(options = {}) {
    this.logger = winston.createLogger({
      level: options.logLevel || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'logs/menu-parser.log' })
      ]
    });

    // Initialize LLM clients
    this.initializeLLMClients(options);
    
    this.defaultBusinessType = options.businessType || 'restaurant';
    this.defaultLanguage = options.defaultLanguage || 'de';
    this.supportedLanguages = options.supportedLanguages || ['de', 'en'];
    this.enableValidation = options.enableValidation !== false;
    
    // Menu parsing configuration
    this.parsingConfig = {
      maxRetries: 3,
      confidenceThreshold: 0.8,
      directImageProcessing: true,
      useMultipleModels: true,
      fallbackToManualReview: true
    };
  }

  initializeLLMClients(options) {
    // Google Gemini - use centralized provider
    this.gemini25Model = getGeminiModel({ modelName: 'gemini-2.5-flash' });
    this.gemini20Model = getGeminiModel({ modelName: 'gemini-2.0-flash' });
    
    console.log('Using Gemini through centralized provider');
  }

  /**
   * Главная функция парсинга меню - поддерживает файлы напрямую
   */
  async parseMenu(input, options = {}) {
    const requestId = uuidv4();
    this.logger.info('Starting menu parsing', { requestId, inputType: typeof input });

    try {
      let files = [];

      // Step 1: Prepare files for Gemini
      if (typeof input === 'string') {
        // Check if it's a file path
        try {
          await fs.access(input);
          files = [await this.prepareFileForGemini(input)];
          this.logger.info('File prepared for Gemini', { 
            requestId, 
            filePath: input,
            fileSize: files[0].size,
            mimeType: files[0].mimeType
          });
        } catch {
          // Not a file path, treat as direct text input
          this.logger.info('Input treated as direct text', { 
            requestId,
            textLength: input.length,
            textPreview: input.substring(0, 100)
          });
        }
      } else if (Array.isArray(input)) {
        // Multiple files - preserve order
        for (const [index, filePath] of input.entries()) {
          const file = await this.prepareFileForGemini(filePath);
          file.order = index;
          files.push(file);
        }
        this.logger.info('Multiple files prepared', { 
          requestId, 
          fileCount: files.length,
          files: files.map(f => ({ path: f.path, size: f.size, mimeType: f.mimeType, order: f.order }))
        });
      }

      // Step 2: Parse with LLM (direct file or text)
      const result = await this.parseWithLLM(files.length > 0 ? files : input, options, requestId);

      // Step 3: Convert to OOP-POS-MDF format
      const configuration = await this.convertToOOPPOSMDF(result, options);

      this.logger.info('Menu parsing completed successfully', {
        requestId,
        itemsFound: result.items?.length || 0,
        categoriesFound: result.categories?.length || 0,
        inputType: files.length > 0 ? 'files' : 'text'
      });

      return {
        success: true,
        requestId,
        configuration,
        metadata: {
          itemsFound: result.items?.length || 0,
          categoriesFound: result.categories?.length || 0,
          confidence: result.confidence || 0,
          language: options.language || this.defaultLanguage,
          processingTime: Date.now(),
          inputFiles: files.length > 0 ? files.map(f => ({ 
            path: f.path, 
            mimeType: f.mimeType, 
            size: f.size, 
            order: f.order 
          })) : null
        },
        rawData: {
          inputType: files.length > 0 ? 'files' : 'text',
          parsedData: result
        }
      };

    } catch (error) {
      this.logger.error('Menu parsing failed', { requestId, error: error.message });
      throw error;
    }
  }

  /**
   * Подготовка файла для отправки в Gemini
   */
  async prepareFileForGemini(filePath) {
    const path = require('path');

    // Read file as buffer
    const fileBuffer = await fs.readFile(filePath);
    const fileSize = fileBuffer.length;
    const fileExtension = path.extname(filePath).toLowerCase();

    // Determine MIME type based on extension
    const mimeTypes = {
      '.pdf': 'application/pdf',
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.webp': 'image/webp',
      '.heic': 'image/heic',
      '.heif': 'image/heif',
      '.mp4': 'video/mp4',
      '.mov': 'video/quicktime',
      '.avi': 'video/x-msvideo',
      '.flv': 'video/x-flv',
      '.mpg': 'video/mpeg',
      '.mpeg': 'video/mpeg',
      '.wmv': 'video/x-ms-wmv',
      '.3gpp': 'video/3gpp',
      '.wav': 'audio/wav',
      '.mp3': 'audio/mpeg',
      '.aiff': 'audio/aiff',
      '.aac': 'audio/aac',
      '.ogg': 'audio/ogg',
      '.flac': 'audio/flac'
    };

    const mimeType = mimeTypes[fileExtension] || 'application/octet-stream';

    // Check if file type is supported by Gemini
    const supportedTypes = Object.values(mimeTypes);
    if (!supportedTypes.includes(mimeType)) {
      throw new Error(`Unsupported file type: ${fileExtension}. Supported types: ${Object.keys(mimeTypes).join(', ')}`);
    }

    this.logger.info('File prepared for Gemini', {
      filePath,
      fileSize,
      mimeType,
      fileExtension
    });

    return {
      path: filePath,
      data: fileBuffer.toString('base64'),
      mimeType,
      size: fileSize,
      extension: fileExtension
    };
  }


  /**
   * Предварительная обработка текста меню
   */
  async preprocessMenuText(text) {
    // Log original text quality before preprocessing
    const originalLines = text.split('\n').filter(line => line.trim().length > 0);
    const originalCharCount = text.length;
    const originalWordCount = text.split(/\s+/).length;
    
    this.logger.info('Text preprocessing started', {
      originalTextLength: originalCharCount,
      originalLineCount: originalLines.length,
      originalWordCount: originalWordCount,
      textPreview: text.substring(0, 500) + (text.length > 500 ? '\n... (truncated)' : ''),
      sampleLines: originalLines.slice(0, 5)
    });

    // Clean up text artifacts
    let cleaned = text
      .replace(/[^\w\s\d\.,€$£¥\-()\/\[\]]/g, ' ') // Remove strange characters
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim();

    // Remove common text parsing errors
    cleaned = cleaned
      .replace(/(\d)\s+[,.](\d)/g, '$1.$2') // Fix decimal separators
      .replace(/€\s+(\d)/g, '€$1') // Fix currency spacing
      .replace(/(\d)\s+€/g, '$1€')
      .replace(/\b(\d+)[oO](\d+)\b/g, '$1.0$2'); // Fix 'o' -> '0' in prices

    // Log cleaned text quality after preprocessing
    const cleanedLines = cleaned.split('\n').filter(line => line.trim().length > 0);
    const cleanedCharCount = cleaned.length;
    const cleanedWordCount = cleaned.split(/\s+/).length;
    
    // Calculate improvement metrics
    const charactersRemoved = originalCharCount - cleanedCharCount;
    const compressionRatio = cleanedCharCount / originalCharCount;
    
    this.logger.info('Text preprocessing completed', {
      cleanedTextLength: cleanedCharCount,
      cleanedLineCount: cleanedLines.length,
      cleanedWordCount: cleanedWordCount,
      improvementMetrics: {
        charactersRemoved: charactersRemoved,
        compressionRatio: compressionRatio,
        lineCountChange: cleanedLines.length - originalLines.length,
        wordCountChange: cleanedWordCount - originalWordCount
      },
      cleanedTextPreview: cleaned.substring(0, 500) + (cleaned.length > 500 ? '\n... (truncated)' : ''),
      sampleCleanedLines: cleanedLines.slice(0, 5)
    });

    return cleaned;
  }

  /**
   * Парсинг меню с помощью LLM - поддерживает файлы и текст
   */
  async parseWithLLM(input, options, requestId) {
    const businessType = options.businessType || this.defaultBusinessType;
    const language = options.language || this.defaultLanguage;

    const systemPrompt = this.createSystemPrompt(businessType, language, options.restaurantName);
    const isFileInput = Array.isArray(input) && input.length > 0 && input[0].mimeType;
    
    let bestResult = null;
    let attempts = 0;

    // Try different models for best results using unified provider
    const models = [
      getGeminiModel({ modelName: 'gemini-2.5-flash' }),
      getGeminiModel({ modelName: 'gemini-2.0-flash' })
    ].map((client, index) => ({
      name: index === 0 ? 'gemini-2.5-flash' : 'gemini-2.0-flash',
      client: client,
      type: 'gemini'
    }));
    

    for (const model of models) {
      if (attempts >= this.parsingConfig.maxRetries) break;

      try {
        attempts++;
        this.logger.info('Attempting LLM parsing', { 
          requestId, 
          model: model.name, 
          attempt: attempts,
          inputType: isFileInput ? 'files' : 'text',
          fileCount: isFileInput ? input.length : 0
        });

        let result;
        if (isFileInput && model.type === 'gemini') {
          // Gemini supports files directly
          result = await this.callLLMWithFiles(model, systemPrompt, input, options);
        } else {
          // Text input for any model
          const userPrompt = this.createUserPrompt(input, options);
          result = await this.callLLM(model, systemPrompt, userPrompt);
        }

        const parsed = this.parseLLMResponse(result);

        if (this.validateParsedData(parsed)) {
          bestResult = { ...parsed, model: model.name, confidence: this.calculateConfidence(parsed) };
          
          if (bestResult.confidence > this.parsingConfig.confidenceThreshold) {
            break; // Good enough result
          }
        }

      } catch (error) {
        this.logger.warn('LLM parsing attempt failed', { 
          requestId, 
          model: model.name, 
          attempt: attempts, 
          error: error.message,
          errorStack: error.stack
        });
      }
    }

    if (!bestResult) {
      // Enhanced logging before throwing the error
      this.logger.error('All LLM parsing attempts failed', {
        requestId,
        totalAttempts: attempts,
        maxRetries: this.parsingConfig.maxRetries,
        availableModels: models.map(m => m.name),
        confidenceThreshold: this.parsingConfig.confidenceThreshold,
        inputType: isFileInput ? 'files' : 'text',
        inputSize: isFileInput ? input.length : (typeof input === 'string' ? input.length : 0),
        businessType,
        language
      });
      
      throw new Error('Failed to parse menu with any available LLM model');
    }

    this.logger.info('LLM parsing successful', { 
      requestId, 
      model: bestResult.model, 
      confidence: bestResult.confidence 
    });

    return bestResult;
  }

  /**
   * Создание system prompt для LLM
   */
  createSystemPrompt(businessType, language, restaurantName = null) {
    return `Du bist ein Experte für die Analyse von Restaurant-Menüs und POS-Systemen. 
Deine Aufgabe ist es, gescannten Menütext in strukturierte JSON-Daten zu konvertieren.

BUSINESS TYPE: ${businessType}
OUTPUT LANGUAGE: ${language}${restaurantName ? `\nRESTAURANT NAME: ${restaurantName}` : ''}

WICHTIGE ANWEISUNGEN:
1. Extrahiere alle Artikel mit Namen, Preisen und VOLLSTÄNDIGEN BESCHREIBUNGEN
2. Organisiere Artikel in logische Kategorien (Vorspeisen, Hauptspeisen, Getränke, etc.)
3. Erkenne Allergene und besondere Eigenschaften (vegan, glutenfrei, etc.)
4. Normalisiere Preise im Format "X.XX" (Dezimaltrennzeichen: Punkt)
5. Identifiziere Währung automatisch
6. Berücksichtige verschiedene Portionsgrößen und Varianten

PARSING-PROZESS:
1. Identifiziere ALLE Kategorien auf dem Menü
2. Für jeden Artikel extrahiere:
   - Vollständigen Namen
   - KOMPLETTE Beschreibung (sehr wichtig für Suchfunktionen)
   - Hauptpreis und alle Varianten
   - Genaue Kategorie-Zuordnung

ANTWORT-FORMAT (JSON):
{
  "restaurant_info": {
    "name": "Restaurantname (falls erkennbar)",
    "currency": "€/$£/etc"
  },
  "categories": [
    {
      "temp_id": 1,
      "name": "Kategoriename",
      "type": "food/drink",
      "description": "Optional"
    }
  ],
  "items": [
    {
      "menu_number": "24b (optional, if present on menu)",
      "name": "Vollständiger Artikelname",
      "description": "VOLLSTÄNDIGE Beschreibung mit allen Details, Zutaten und Zubereitungsarten",
      "price": 12.50,
      "categoryName": "Exakter Kategoriename aus der categories-Liste",
      "allergens": ["gluten", "dairy"],
      "dietary_info": ["vegetarian", "vegan", "gluten_free"],
      "portion_size": "Normal/Klein/Groß",
      "variants": [
        {"name": "Klein", "price": 10.50},
        {"name": "Groß", "price": 15.50}
      ]
    }
  ],
  "parsing_notes": [
    "Hinweise auf Unsicherheiten oder Besonderheiten"
  ]
}

WICHTIG: Die 'description' ist das wichtigste Feld! Erfasse ALLE Textinformationen zu einem Artikel, einschließlich Zutaten, Zubereitungsart, Beilagen und besondere Eigenschaften. Diese Details sind essentiell für die spätere Suchfunktionalität.

Achte auf häufige Textfehler und korrigiere sie intelligent.`;
  }

  /**
   * Создание user prompt с текстом меню
   */
  createUserPrompt(menuText, options) {
    return `Analysiere bitte das folgende Restaurant-Menü und konvertiere es in das angegebene JSON-Format:

MENÜTEXT:
${menuText}

ZUSÄTZLICHE ANFORDERUNGEN:
- Erstelle sinnvolle Kategorien basierend auf dem Menüinhalt
- Achte auf Preisangaben und korrigiere Textfehler
- Erkenne automatisch die Sprache des Menüs
- Identifiziere Allergene und besondere Eigenschaften
- Erstelle eindeutige IDs für alle Artikel

Antworte nur mit dem validen JSON-Objekt.`;
  }


  /**
   * Вызов LLM API с файлами (только для Gemini)
   */
  async callLLMWithFiles(model, systemPrompt, files, options) {
    console.log('🔍 Calling LLM with files:', model.type, model.name);
    console.log('📁 Files count:', files.length);
    console.log('📝 System prompt length:', systemPrompt.length);
    
    // Prepare content array for Gemini
    const content = [systemPrompt];
    
    // Add files to content
    for (const file of files) {
      console.log(`📄 Adding file: ${file.path} (${file.mimeType}, ${file.size} bytes)`);
      content.push({
        inlineData: {
          data: file.data,
          mimeType: file.mimeType
        }
      });
    }
    
    // Add user instruction about multiple files if needed
    if (files.length > 1) {
      content.push(`\nПожалуйста, обработайте все ${files.length} файла в указанном порядке и объедините информацию из всех файлов в одну структуру меню. Сохраните последовательность блюд как они представлены в файлах.`);
    }

    console.log('🤖 Calling Gemini API with files...');
    // Use the unified provider client directly
    const result = await model.client.generateContent(content);
    console.log('✅ Gemini API response received');
    const text = result.text;
    console.log('📄 Response text length:', text.length);
    console.log('📄 First 200 chars:', text.substring(0, 200));
    return text;
  }

  /**
   * Вызов LLM API с текстом
   */
  async callLLM(model, systemPrompt, userPrompt) {
    console.log('🔍 Calling LLM:', model.type, model.name);
    console.log('📝 System prompt length:', systemPrompt.length);
    console.log('📝 User prompt length:', userPrompt.length);
    
    switch (model.type) {
      case 'gemini':
        console.log('🤖 Calling Gemini API...');
        // Use the unified provider client directly
        const result = await model.client.generateContent([
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]);
        console.log('✅ Gemini API response received');
        const text = result.text;
        console.log('📄 Response text length:', text.length);
        console.log('📄 First 200 chars:', text.substring(0, 200));
        return text;


      default:
        throw new Error(`Unsupported model type: ${model.type}`);
    }
  }

  /**
   * Парсинг ответа LLM
   */
  parseLLMResponse(response) {
    try {
      this.logger.debug('Raw LLM response received', { 
        responseLength: response.length,
        responsePreview: response.substring(0, 500) + (response.length > 500 ? '...' : '')
      });

      // Clean response text
      let cleanedResponse = response.trim();
      
      // Remove markdown code blocks if present
      cleanedResponse = cleanedResponse.replace(/```json\s*|\s*```/g, '');
      this.logger.debug('After markdown removal', { 
        cleanedLength: cleanedResponse.length,
        cleanedPreview: cleanedResponse.substring(0, 200) + (cleanedResponse.length > 200 ? '...' : '')
      });
      
      // Find JSON object
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
        this.logger.debug('JSON pattern found', { 
          matchLength: cleanedResponse.length,
          matchPreview: cleanedResponse.substring(0, 200) + (cleanedResponse.length > 200 ? '...' : '')
        });
      } else {
        this.logger.warn('No JSON pattern found in response', { 
          originalResponse: response,
          cleanedResponse: cleanedResponse
        });
      }

      const parsed = JSON.parse(cleanedResponse);
      this.logger.debug('JSON parsing successful', { 
        hasItems: !!parsed.items,
        itemsCount: parsed.items ? parsed.items.length : 0,
        hasCategories: !!parsed.categories,
        categoriesCount: parsed.categories ? parsed.categories.length : 0,
        hasRestaurantInfo: !!parsed.restaurant_info,
        topLevelKeys: Object.keys(parsed)
      });

      return parsed;
    } catch (error) {
      this.logger.error('Failed to parse LLM response as JSON', {
        error: error.message,
        errorStack: error.stack,
        responseLength: response.length,
        responsePreview: response.substring(0, 1000),
        cleanedResponseAttempt: response.trim().replace(/```json\s*|\s*```/g, '')
      });
      throw new Error(`Failed to parse LLM response as JSON: ${error.message}`);
    }
  }

  /**
   * Валидация парсеных данных
   */
  validateParsedData(data) {
    this.logger.debug('Starting validation of parsed data', { 
      hasData: !!data,
      dataType: typeof data,
      topLevelKeys: data ? Object.keys(data) : null
    });

    // Basic validation
    if (!data || typeof data !== 'object') {
      this.logger.warn('Validation failed: data is not an object', { 
        data: data,
        type: typeof data 
      });
      return false;
    }

    if (!data.items || !Array.isArray(data.items) || data.items.length === 0) {
      this.logger.warn('Validation failed: items array is missing or empty', { 
        hasItems: !!data.items,
        itemsType: typeof data.items,
        isArray: Array.isArray(data.items),
        itemsLength: data.items ? data.items.length : 'N/A'
      });
      return false;
    }

    if (!data.categories || !Array.isArray(data.categories) || data.categories.length === 0) {
      this.logger.warn('Validation failed: categories array is missing or empty', { 
        hasCategories: !!data.categories,
        categoriesType: typeof data.categories,
        isArray: Array.isArray(data.categories),
        categoriesLength: data.categories ? data.categories.length : 'N/A'
      });
      return false;
    }

    // Check items have required fields
    for (let i = 0; i < data.items.length; i++) {
      const item = data.items[i];
      if (!item.name || typeof item.price !== 'number' || (!item.category_id && !item.categoryName)) {
        this.logger.warn('Validation failed: item missing required fields', { 
          itemIndex: i,
          itemName: item.name,
          hasName: !!item.name,
          priceType: typeof item.price,
          priceValue: item.price,
          hasCategoryId: !!item.category_id,
          hasCategoryName: !!item.categoryName,
          itemKeys: Object.keys(item)
        });
        return false;
      }
    }

    // Check categories have required fields
    for (let i = 0; i < data.categories.length; i++) {
      const category = data.categories[i];
      if (!category.name || (!category.id && !category.temp_id)) {
        this.logger.warn('Validation failed: category missing required fields', { 
          categoryIndex: i,
          categoryName: category.name,
          hasName: !!category.name,
          hasId: !!category.id,
          hasTempId: !!category.temp_id,
          categoryKeys: Object.keys(category)
        });
        return false;
      }
    }

    this.logger.debug('Validation successful', { 
      itemsCount: data.items.length,
      categoriesCount: data.categories.length
    });
    return true;
  }

  /**
   * Расчет уверенности в результате
   */
  calculateConfidence(data) {
    let score = 0.5; // Base score

    // Items with prices
    const itemsWithPrices = data.items.filter(item => typeof item.price === 'number' && item.price > 0);
    score += (itemsWithPrices.length / data.items.length) * 0.3;

    // Categories coverage
    const categoriesUsed = new Set(data.items.map(item => item.category_id));
    score += (categoriesUsed.size / data.categories.length) * 0.2;

    // Items with descriptions
    const itemsWithDescriptions = data.items.filter(item => item.description && item.description.length > 5);
    score += (itemsWithDescriptions.length / data.items.length) * 0.1;

    // Language detection
    if (data.restaurant_info?.detected_language) {
      score += 0.1;
    }

    return Math.min(score, 1.0);
  }

  /**
   * Улучшение и валидация данных
   */
  async enhanceAndValidate(parsedData, options) {
    // Add missing IDs
    parsedData.categories.forEach((category, index) => {
      if (!category.id) category.id = index + 1;
    });

    parsedData.items.forEach((item, index) => {
      if (!item.id) item.id = index + 1;
      if (!item.short_name) item.short_name = this.generateShortName(item.name);
    });

    // Validate price formats
    parsedData.items.forEach(item => {
      if (typeof item.price === 'string') {
        item.price = parseFloat(item.price.replace(/[^\d.,]/g, '').replace(',', '.'));
      }
      item.price = Math.round(item.price * 100) / 100; // Round to 2 decimal places
    });

    // Enhance categories
    parsedData.categories.forEach(category => {
      if (!category.type) {
        category.type = this.guesseCategoryType(category.name);
      }
    });

    // Add allergen information if missing
    parsedData.items.forEach(item => {
      if (!item.allergens) item.allergens = [];
      if (!item.dietary_info) item.dietary_info = [];
      
      // Try to detect allergens from description
      this.detectAllergensFromText(item.name + ' ' + (item.description || ''), item);
    });

    return parsedData;
  }

  /**
   * Генерация короткого названия для кнопки
   */
  generateShortName(fullName) {
    if (fullName.length <= 12) return fullName;
    
    // Try to create meaningful abbreviation
    const words = fullName.split(' ');
    if (words.length > 1) {
      return words.slice(0, 2).join(' ').substring(0, 12);
    }
    
    return fullName.substring(0, 12);
  }

  /**
   * Определение типа категории
   */
  guesseCategoryType(categoryName) {
    const drinkKeywords = ['getränk', 'drink', 'beverage', 'wein', 'wine', 'bier', 'beer', 'cocktail', 'saft', 'juice', 'kaffee', 'coffee', 'tee', 'tea'];
    const nameLower = categoryName.toLowerCase();
    
    return drinkKeywords.some(keyword => nameLower.includes(keyword)) ? 'drink' : 'food';
  }

  /**
   * Определение аллергенов из текста
   */
  detectAllergensFromText(text, item) {
    const textLower = text.toLowerCase();
    
    const allergenMap = {
      'gluten': ['weizen', 'dinkel', 'roggen', 'gerste', 'hafer', 'gluten'],
      'dairy': ['milch', 'käse', 'butter', 'sahne', 'joghurt', 'quark'],
      'nuts': ['nuss', 'mandel', 'haselnuss', 'walnuss', 'erdnuss'],
      'fish': ['fisch', 'lachs', 'thunfisch', 'forelle'],
      'crustaceans': ['garnele', 'krebs', 'hummer', 'languste'],
      'eggs': ['ei', 'eigelb', 'eiweiß'],
      'soy': ['soja', 'tofu'],
      'sulfites': ['wein', 'trockenfrüchte']
    };

    for (const [allergen, keywords] of Object.entries(allergenMap)) {
      if (keywords.some(keyword => textLower.includes(keyword))) {
        if (!item.allergens.includes(allergen)) {
          item.allergens.push(allergen);
        }
      }
    }

    // Dietary info detection
    if (textLower.includes('vegan')) item.dietary_info.push('vegan');
    if (textLower.includes('vegetarisch') || textLower.includes('vegetarian')) item.dietary_info.push('vegetarian');
    if (textLower.includes('glutenfrei') || textLower.includes('gluten-free')) item.dietary_info.push('gluten_free');
    if (textLower.includes('bio') || textLower.includes('organic')) item.dietary_info.push('organic');
  }

  /**
   * Конвертация в OOP-POS-MDF формат
   */
  async convertToOOPPOSMDF(parsedData, options) {
    const restaurantName = parsedData.restaurant_info?.name || options.restaurantName || 'Parsed Restaurant';
    const currency = parsedData.restaurant_info?.currency || '€';
    const detectedLanguage = parsedData.restaurant_info?.detected_language || this.defaultLanguage;

    // Create audit trail
    const auditTrail = {
      created_at: new Date().toISOString(),
      created_by: 'menu-parser@eckasse.com',
      last_modified_at: new Date().toISOString(),
      last_modified_by: 'menu-parser@eckasse.com',
      version: 1,
      change_log: [
        {
          timestamp: new Date().toISOString(),
          user: 'menu-parser@eckasse.com',
          action: 'menu_parsed',
          description: 'Automatically parsed from menu image/text'
        }
      ]
    };

    // Convert categories - handle both old and new format
    const categories = parsedData.categories.map((cat, index) => {
      const categoryId = cat.temp_id || cat.id || (index + 1);
      return {
        category_unique_identifier: categoryId,
        category_names: this.createMultilingualObject(cat.name, detectedLanguage),
        category_type: cat.type || this.guesseCategoryType(cat.name),
        parent_category_unique_identifier: null,
        default_linked_main_group_unique_identifier: (cat.type === 'drink' || this.guesseCategoryType(cat.name) === 'drink') ? 1 : 2,
        audit_trail: { ...auditTrail }
      };
    });

    // Create category lookup map for new format
    const categoryLookup = new Map();
    categories.forEach(cat => {
      const categoryName = parsedData.categories.find(c => 
        (c.temp_id || c.id) === cat.category_unique_identifier
      )?.name;
      if (categoryName) {
        categoryLookup.set(categoryName, cat.category_unique_identifier);
      }
    });

    // Convert items to multilingual format - handle both old and new format
    const items = parsedData.items.map((item, index) => {
      const itemId = item.id || (index + 1);
      const shortName = item.short_name || this.generateShortName(item.name);
      
      // Handle category linking for new format
      let categoryId;
      if (item.categoryName) {
        // New format: use categoryName to find category_unique_identifier
        categoryId = categoryLookup.get(item.categoryName) || 1;
      } else {
        // Old format: use category_id directly
        categoryId = item.category_id || 1;
      }

      return {
        item_unique_identifier: itemId,
        menu_item_number: item.menu_number || null,
        display_names: {
          menu: this.createMultilingualObject(item.name, detectedLanguage),
          button: this.createMultilingualObject(shortName, detectedLanguage),
          receipt: this.createMultilingualObject(item.name, detectedLanguage)
        },
        item_price_value: item.price,
        pricing_schedules: item.variants ? item.variants.map(variant => ({
          schedule_id: `variant_${variant.name.toLowerCase()}`,
          price: variant.price,
          valid_days: ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
        })) : [],
        availability_schedule: {
          always_available: true,
          schedules: []
        },
        associated_category_unique_identifier: categoryId,
        additional_item_attributes: {
          description: item.description || '',
          allergens: item.allergens || [],
          dietary_info: item.dietary_info || [],
          portion_size: item.portion_size || 'normal',
          menu_parser_generated: true
        },
        item_flags: {
          is_sellable: true,
          has_negative_price: false,
          requires_age_verification: false,
          is_organic: item.dietary_info?.includes('organic') || false
        },
        audit_trail: { ...auditTrail }
      };
    });

    // Create full OOP-POS-MDF configuration
    const config = {
      "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
      company_details: {
        company_unique_identifier: 1,
        company_full_name: restaurantName,
        meta_information: {
          format_version: "2.0.0",
          previous_versions: [],
          date_generated: new Date().toISOString(),
          generated_by: "eckasse-menu-parser-v2.0.0",
          default_currency_symbol: currency,
          default_language: detectedLanguage,
          supported_languages: this.supportedLanguages,
          audit_trail: { ...auditTrail }
        },
        global_configurations: {
          tax_rates_definitions: [
            {
              tax_rate_unique_identifier: 1,
              tax_rate_names: this.createMultilingualObject("Standard (19%)", detectedLanguage),
              rate_percentage: 19.0,
              fiscal_mapping_type: "NORMAL"
            },
            {
              tax_rate_unique_identifier: 2,
              tax_rate_names: this.createMultilingualObject("Ermäßigt (7%)", detectedLanguage),
              rate_percentage: 7.0,
              fiscal_mapping_type: "REDUCED"
            }
          ],
          main_groups_definitions: [
            {
              main_group_unique_identifier: 1,
              main_group_names: this.createMultilingualObject("Getränke", detectedLanguage)
            },
            {
              main_group_unique_identifier: 2,
              main_group_names: this.createMultilingualObject("Speisen", detectedLanguage)
            }
          ],
          payment_methods_definitions: [
            {
              payment_method_unique_identifier: 1,
              payment_method_names: this.createMultilingualObject("Bar", detectedLanguage),
              payment_method_type: "CASH"
            },
            {
              payment_method_unique_identifier: 2,
              payment_method_names: this.createMultilingualObject("Karte", detectedLanguage),
              payment_method_type: "CARD"
            }
          ],
          promotions_definitions: [],
          workflows: [],
          integrations: {},
          security_settings: {
            encryption: { at_rest: true, in_transit: true, algorithm: "AES-256" },
            access_control: { session_timeout: 3600, max_failed_attempts: 3, lockout_duration: 900, require_2fa: false },
            data_privacy: { gdpr_compliance: true, data_retention_days: 2555, anonymization_rules: [] }
          }
        },
        branches: [
          {
            branch_unique_identifier: 1,
            branch_names: this.createMultilingualObject("Hauptfiliale", detectedLanguage),
            branch_address: "Automatisch generiert aus Menü",
            point_of_sale_devices: [
              {
                pos_device_unique_identifier: 1,
                pos_device_names: this.createMultilingualObject("Hauptkasse", detectedLanguage),
                pos_device_type: "DESKTOP",
                pos_device_external_number: 1,
                pos_device_settings: {
                  default_currency_identifier: currency,
                  default_linked_drink_tax_rate_unique_identifier: 1,
                  default_linked_food_tax_rate_unique_identifier: 2
                },
                categories_for_this_pos: categories,
                items_for_this_pos: items
              }
            ]
          }
        ]
      }
    };

    return config;
  }

  /**
   * Создание многоязычного объекта
   */
  createMultilingualObject(text, primaryLanguage) {
    const obj = {};
    obj[primaryLanguage] = text;
    
    // Add fallback to default language if different
    if (primaryLanguage !== this.defaultLanguage) {
      obj[this.defaultLanguage] = text;
    }

    return obj;
  }

  /**
   * CLI интерфейс для парсинга меню
   */
  static async parseMenuFromCLI(args) {
    const parser = new MenuParserLLM({});

    try {
      const inputPath = args[0];
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
      const outputPath = args[1] || `parsed-menu-config_${timestamp}.json`;
      
      if (!inputPath) {
        console.error('Usage: node menu-parser.js <input-image-or-text> [output-file]');
        process.exit(1);
      }

      console.log(`🔍 Parsing menu from: ${inputPath}`);
      const result = await parser.parseMenu(inputPath);

      // Save configuration
      await fs.writeFile(outputPath, JSON.stringify(result.configuration, null, 2));
      
      console.log(`✅ Menu parsed successfully!`);
      console.log(`📊 Found ${result.metadata.itemsFound} items in ${result.metadata.categoriesFound} categories`);
      console.log(`🎯 Confidence: ${(result.metadata.confidence * 100).toFixed(1)}%`);
      console.log(`💾 Configuration saved to: ${outputPath}`);

      // Generate Vectron import if requested
      if (args.includes('--vectron')) {
        const vectronConverter = require('./vectron-converter');
        const vectronData = vectronConverter.convert(result.configuration);
        const vectronPath = outputPath.replace('.json', '-vectron.txt');
        await fs.writeFile(vectronPath, vectronData);
        console.log(`🔄 Vectron import file saved to: ${vectronPath}`);
      }

    } catch (error) {
      console.error('❌ Menu parsing failed:', error.message);
      process.exit(1);
    }
  }
}

// Export for use as module
module.exports = MenuParserLLM;

// Run CLI if called directly
if (require.main === module) {
  MenuParserLLM.parseMenuFromCLI(process.argv.slice(2));
}

--- File: /packages/backend/src/routes/llm.routes.js ---

// File: /packages/backend/src/routes/llm.routes.js
const express = require('express');
const llmController = require('../controllers/llm.controller');
const router = express.Router();

router.post('/ping-gemini', llmController.handleGeminiPing);

module.exports = router;

--- File: /packages/backend/src/schemas/v2.0.0/schema.json ---

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
  "title": "Enhanced OOP-POS-MDF Configuration",
  "description": "Schema for Enhanced Object-Oriented Point-of-Sale Master Data Format v2.0.0",
  "type": "object",
  "required": ["company_details"],
  "properties": {
    "$schema": {
      "type": "string",
      "format": "uri"
    },
    "company_details": {
      "type": "object",
      "required": ["company_unique_identifier", "company_full_name", "meta_information", "branches"],
      "properties": {
        "company_unique_identifier": {
          "type": "integer",
          "minimum": 1
        },
        "company_full_name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255
        },
        "meta_information": {
          "type": "object",
          "required": ["format_version"],
          "properties": {
            "format_version": {
              "type": "string",
              "pattern": "^\\d+\\.\\d+\\.\\d+$"
            },
            "previous_versions": {
              "type": "array",
              "items": {
                "type": "string",
                "pattern": "^\\d+\\.\\d+\\.\\d+$"
              }
            },
            "schema_validation": {
              "type": "object",
              "properties": {
                "required_fields": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "field_constraints": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": ["integer", "decimal", "string", "boolean"]
                      },
                      "min": {
                        "type": "number"
                      },
                      "max": {
                        "type": "number"
                      },
                      "precision": {
                        "type": "integer"
                      }
                    }
                  }
                }
              }
            },
            "migration_info": {
              "type": "object",
              "properties": {
                "from_version": {
                  "type": "string",
                  "pattern": "^\\d+\\.\\d+\\.\\d+$"
                },
                "migration_scripts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["from_version", "to_version", "migration_script"],
                    "properties": {
                      "from_version": {
                        "type": "string",
                        "pattern": "^\\d+\\.\\d+\\.\\d+$"
                      },
                      "to_version": {
                        "type": "string",
                        "pattern": "^\\d+\\.\\d+\\.\\d+$"
                      },
                      "migration_script": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "breaking_changes": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "backward_compatibility": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "auto_migration": {
                  "type": "boolean"
                }
              }
            },
            "date_generated": {
              "type": "string",
              "format": "date-time"
            },
            "generated_by": {
              "type": "string"
            },
            "default_currency_symbol": {
              "type": "string",
              "maxLength": 3
            },
            "default_language": {
              "type": "string",
              "pattern": "^[a-z]{2}$"
            },
            "supported_languages": {
              "type": "array",
              "items": {
                "type": "string",
                "pattern": "^[a-z]{2}$"
              },
              "minItems": 1
            },
            "audit_trail": {
              "$ref": "#/definitions/audit_trail"
            }
          }
        },
        "global_configurations": {
          "type": "object",
          "properties": {
            "tax_rates_definitions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["tax_rate_unique_identifier", "tax_rate_names", "rate_percentage", "fiscal_mapping_type"],
                "properties": {
                  "tax_rate_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "tax_rate_names": {
                    "$ref": "#/definitions/multilingual_text"
                  },
                  "rate_percentage": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 100
                  },
                  "fiscal_mapping_type": {
                    "type": "string",
                    "enum": ["NORMAL", "REDUCED", "ZERO", "EXEMPT"]
                  },
                  "valid_from": {
                    "type": "string",
                    "format": "date"
                  },
                  "valid_until": {
                    "type": ["string", "null"],
                    "format": "date"
                  }
                }
              }
            },
            "main_groups_definitions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["main_group_unique_identifier", "main_group_names"],
                "properties": {
                  "main_group_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "main_group_names": {
                    "$ref": "#/definitions/multilingual_text"
                  }
                }
              }
            },
            "payment_methods_definitions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["payment_method_unique_identifier", "payment_method_names", "payment_method_type"],
                "properties": {
                  "payment_method_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "payment_method_names": {
                    "$ref": "#/definitions/multilingual_text"
                  },
                  "payment_method_type": {
                    "type": "string",
                    "enum": ["CASH", "CARD", "CREDIT_CARD", "MOBILE_PAYMENT", "VOUCHER", "CRYPTOCURRENCY"]
                  }
                }
              }
            },
            "promotions_definitions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["promotion_id", "names", "type", "conditions", "discount"],
                "properties": {
                  "promotion_id": {
                    "type": "string"
                  },
                  "names": {
                    "$ref": "#/definitions/multilingual_text"
                  },
                  "type": {
                    "type": "string",
                    "enum": ["percentage_discount", "fixed_discount", "quantity_discount", "buy_x_get_y"]
                  },
                  "conditions": {
                    "type": "object",
                    "properties": {
                      "min_quantity": {
                        "type": "integer",
                        "minimum": 1
                      },
                      "applicable_categories": {
                        "type": "array",
                        "items": {
                          "type": "integer"
                        }
                      },
                      "applicable_items": {
                        "type": "array",
                        "items": {
                          "type": "integer"
                        }
                      }
                    }
                  },
                  "discount": {
                    "type": "object",
                    "required": ["type", "value"],
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": ["percentage", "fixed_amount"]
                      },
                      "value": {
                        "type": "number",
                        "minimum": 0
                      },
                      "max_discount_amount": {
                        "type": "number",
                        "minimum": 0
                      }
                    }
                  },
                  "validity": {
                    "type": "object",
                    "properties": {
                      "start_date": {
                        "type": "string",
                        "format": "date"
                      },
                      "end_date": {
                        "type": "string",
                        "format": "date"
                      },
                      "days_of_week": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
                        }
                      },
                      "time_range": {
                        "type": "object",
                        "properties": {
                          "start": {
                            "type": "string",
                            "pattern": "^([01]?[0-9]|2[0-3]):[0-5][0-9]$"
                          },
                          "end": {
                            "type": "string",
                            "pattern": "^([01]?[0-9]|2[0-3]):[0-5][0-9]$"
                          }
                        }
                      }
                    }
                  },
                  "is_active": {
                    "type": "boolean"
                  }
                }
              }
            },
            "workflows": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["workflow_id", "name", "trigger", "actions"],
                "properties": {
                  "workflow_id": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  },
                  "trigger": {
                    "type": "object",
                    "required": ["type"],
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": ["schedule", "inventory_threshold", "event", "manual"]
                      }
                    }
                  },
                  "actions": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["type"],
                      "properties": {
                        "type": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "is_active": {
                    "type": "boolean"
                  }
                }
              }
            },
            "integrations": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "provider": {
                    "type": "string"
                  },
                  "is_enabled": {
                    "type": "boolean"
                  }
                }
              }
            },
            "security_settings": {
              "type": "object",
              "properties": {
                "encryption": {
                  "type": "object",
                  "properties": {
                    "at_rest": {
                      "type": "boolean"
                    },
                    "in_transit": {
                      "type": "boolean"
                    },
                    "algorithm": {
                      "type": "string"
                    }
                  }
                },
                "access_control": {
                  "type": "object",
                  "properties": {
                    "session_timeout": {
                      "type": "integer",
                      "minimum": 60
                    },
                    "max_failed_attempts": {
                      "type": "integer",
                      "minimum": 1
                    },
                    "lockout_duration": {
                      "type": "integer",
                      "minimum": 60
                    },
                    "require_2fa": {
                      "type": "boolean"
                    }
                  }
                },
                "data_privacy": {
                  "type": "object",
                  "properties": {
                    "gdpr_compliance": {
                      "type": "boolean"
                    },
                    "data_retention_days": {
                      "type": "integer",
                      "minimum": 1
                    },
                    "anonymization_rules": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "field": {
                            "type": "string"
                          },
                          "after_days": {
                            "type": "integer"
                          },
                          "method": {
                            "type": "string",
                            "enum": ["hash", "anonymize", "delete"]
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "user_management": {
          "type": "object",
          "required": ["roles", "users"],
          "properties": {
            "roles": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "object",
                "required": ["role_unique_identifier", "role_name", "role_display_names", "permissions"],
                "properties": {
                  "role_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "role_name": {
                    "type": "string",
                    "pattern": "^[a-z_]+$",
                    "minLength": 1,
                    "maxLength": 50
                  },
                  "role_display_names": {
                    "$ref": "#/definitions/multilingual_text"
                  },
                  "description": {
                    "type": "string",
                    "maxLength": 500
                  },
                  "permissions": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "pattern": "^[a-z_]+\\.[a-z_]+$"
                    },
                    "minItems": 1
                  },
                  "storno_limits": {
                    "type": "object",
                    "properties": {
                      "daily_limit": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      },
                      "emergency_limit": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      }
                    }
                  },
                  "approval_rights": {
                    "type": "object",
                    "properties": {
                      "can_approve_changes": {
                        "type": "boolean"
                      },
                      "can_manage_users": {
                        "type": "boolean"
                      },
                      "max_approval_amount": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      }
                    }
                  },
                  "is_system_role": {
                    "type": "boolean"
                  },
                  "audit_trail": {
                    "$ref": "#/definitions/audit_trail"
                  }
                }
              }
            },
            "users": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "object",
                "required": ["user_unique_identifier", "username", "email", "full_name", "role_unique_identifier", "storno_limits"],
                "properties": {
                  "user_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "username": {
                    "type": "string",
                    "pattern": "^[a-zA-Z0-9_]+$",
                    "minLength": 3,
                    "maxLength": 50
                  },
                  "email": {
                    "type": "string",
                    "format": "email"
                  },
                  "full_name": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 255
                  },
                  "role_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "assigned_pos_device_unique_identifier": {
                    "type": ["integer", "null"],
                    "minimum": 1
                  },
                  "storno_limits": {
                    "type": "object",
                    "required": ["daily_limit", "emergency_limit"],
                    "properties": {
                      "daily_limit": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      },
                      "emergency_limit": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      },
                      "used_today": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      }
                    }
                  },
                  "trust_score": {
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 100
                  },
                  "status": {
                    "type": "object",
                    "properties": {
                      "is_active": {
                        "type": "boolean"
                      },
                      "force_password_change": {
                        "type": "boolean"
                      },
                      "last_login_at": {
                        "type": ["string", "null"],
                        "format": "date-time"
                      },
                      "failed_login_attempts": {
                        "type": "integer",
                        "minimum": 0
                      },
                      "locked_until": {
                        "type": ["string", "null"],
                        "format": "date-time"
                      }
                    }
                  },
                  "preferences": {
                    "type": "object",
                    "properties": {
                      "language": {
                        "type": "string",
                        "pattern": "^[a-z]{2}$"
                      },
                      "theme": {
                        "type": "string",
                        "enum": ["light", "dark", "auto"]
                      },
                      "notifications": {
                        "type": "object",
                        "properties": {
                          "pending_changes": {
                            "type": "boolean"
                          },
                          "storno_requests": {
                            "type": "boolean"
                          },
                          "system_alerts": {
                            "type": "boolean"
                          }
                        }
                      }
                    }
                  },
                  "audit_trail": {
                    "$ref": "#/definitions/audit_trail"
                  }
                }
              }
            },
            "pending_changes": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["change_unique_identifier", "requested_by_user_unique_identifier", "change_type", "status"],
                "properties": {
                  "change_unique_identifier": {
                    "type": "string",
                    "pattern": "^[a-f0-9-]+$"
                  },
                  "requested_by_user_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "change_type": {
                    "type": "string",
                    "enum": ["product_create", "product_update", "product_delete", "category_create", "category_update", "category_delete", "price_change", "user_update", "role_update"]
                  },
                  "target_entity": {
                    "type": "object",
                    "required": ["type", "identifier"],
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": ["product", "category", "user", "role", "pos_device"]
                      },
                      "identifier": {
                        "type": "integer",
                        "minimum": 1
                      }
                    }
                  },
                  "original_data": {
                    "type": "object"
                  },
                  "proposed_data": {
                    "type": "object"
                  },
                  "reason": {
                    "type": "string",
                    "maxLength": 1000
                  },
                  "priority": {
                    "type": "string",
                    "enum": ["low", "normal", "high", "urgent"]
                  },
                  "status": {
                    "type": "string",
                    "enum": ["pending", "approved", "rejected", "auto_applied"]
                  },
                  "review_info": {
                    "type": "object",
                    "properties": {
                      "reviewed_by_user_unique_identifier": {
                        "type": "integer",
                        "minimum": 1
                      },
                      "reviewed_at": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "review_notes": {
                        "type": "string",
                        "maxLength": 1000
                      }
                    }
                  },
                  "auto_apply_at": {
                    "type": ["string", "null"],
                    "format": "date-time"
                  },
                  "audit_trail": {
                    "$ref": "#/definitions/audit_trail"
                  }
                }
              }
            },
            "storno_log": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["storno_unique_identifier", "user_unique_identifier", "transaction_reference", "amount", "type"],
                "properties": {
                  "storno_unique_identifier": {
                    "type": "string",
                    "pattern": "^[a-f0-9-]+$"
                  },
                  "user_unique_identifier": {
                    "type": "integer",
                    "minimum": 1
                  },
                  "transaction_reference": {
                    "type": "string",
                    "minLength": 1
                  },
                  "amount": {
                    "type": "number",
                    "minimum": 0,
                    "multipleOf": 0.01
                  },
                  "type": {
                    "type": "string",
                    "enum": ["automatic", "admin_approved", "emergency"]
                  },
                  "reason": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 1000
                  },
                  "approval_info": {
                    "type": "object",
                    "properties": {
                      "approved_by_user_unique_identifier": {
                        "type": "integer",
                        "minimum": 1
                      },
                      "approved_at": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "approval_status": {
                        "type": "string",
                        "enum": ["automatic", "pending", "approved", "rejected"]
                      }
                    }
                  },
                  "credit_usage": {
                    "type": "object",
                    "properties": {
                      "within_limit": {
                        "type": "boolean"
                      },
                      "credit_used": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      },
                      "remaining_credit": {
                        "type": "number",
                        "minimum": 0,
                        "multipleOf": 0.01
                      }
                    }
                  },
                  "audit_trail": {
                    "$ref": "#/definitions/audit_trail"
                  }
                }
              }
            }
          }
        },
        "branches": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "required": ["branch_unique_identifier", "branch_names", "point_of_sale_devices"],
            "properties": {
              "branch_unique_identifier": {
                "type": "integer",
                "minimum": 1
              },
              "branch_names": {
                "$ref": "#/definitions/multilingual_text"
              },
              "branch_address": {
                "type": "string"
              },
              "point_of_sale_devices": {
                "type": "array",
                "minItems": 1,
                "items": {
                  "type": "object",
                  "required": ["pos_device_unique_identifier", "pos_device_names", "pos_device_type", "pos_device_external_number", "categories_for_this_pos", "items_for_this_pos"],
                  "properties": {
                    "pos_device_unique_identifier": {
                      "type": "integer",
                      "minimum": 1
                    },
                    "pos_device_names": {
                      "$ref": "#/definitions/multilingual_text"
                    },
                    "pos_device_type": {
                      "type": "string",
                      "enum": ["DESKTOP", "TABLET", "MOBILE", "KIOSK", "HANDHELD"]
                    },
                    "pos_device_external_number": {
                      "type": "integer",
                      "minimum": 1,
                      "maximum": 9999
                    },
                    "pos_device_settings": {
                      "type": "object",
                      "properties": {
                        "default_currency_identifier": {
                          "type": "string"
                        },
                        "default_linked_drink_tax_rate_unique_identifier": {
                          "type": "integer"
                        },
                        "default_linked_food_tax_rate_unique_identifier": {
                          "type": "integer"
                        },
                        "performance": {
                          "type": "object",
                          "properties": {
                            "cache_settings": {
                              "type": "object",
                              "properties": {
                                "items_cache_ttl": {
                                  "type": "integer",
                                  "minimum": 0
                                },
                                "categories_cache_ttl": {
                                  "type": "integer",
                                  "minimum": 0
                                },
                                "preload_popular_items": {
                                  "type": "boolean"
                                },
                                "max_cache_size_mb": {
                                  "type": "integer",
                                  "minimum": 1
                                }
                              }
                            },
                            "ui_optimization": {
                              "type": "object",
                              "properties": {
                                "lazy_load_images": {
                                  "type": "boolean"
                                },
                                "debounce_search_ms": {
                                  "type": "integer",
                                  "minimum": 0
                                },
                                "virtual_scrolling": {
                                  "type": "boolean"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "categories_for_this_pos": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["category_unique_identifier", "category_names", "category_type"],
                        "properties": {
                          "category_unique_identifier": {
                            "type": "integer",
                            "minimum": 1
                          },
                          "category_names": {
                            "$ref": "#/definitions/multilingual_text"
                          },
                          "category_type": {
                            "type": "string",
                            "enum": ["drink", "food", "service", "other"]
                          },
                          "parent_category_unique_identifier": {
                            "type": ["integer", "null"]
                          },
                          "default_linked_main_group_unique_identifier": {
                            "type": "integer"
                          },
                          "audit_trail": {
                            "$ref": "#/definitions/audit_trail"
                          }
                        }
                      }
                    },
                    "items_for_this_pos": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["item_unique_identifier", "display_names", "item_price_value", "associated_category_unique_identifier", "item_flags", "audit_trail"],
                        "properties": {
                          "item_unique_identifier": {
                            "type": "integer",
                            "minimum": 1
                          },
                          "menu_item_number": {
                            "type": ["string", "null"],
                            "description": "An optional, customer-facing number for the item as it appears on the menu (e.g., '24', 'A5'). This is different from the internal unique identifier and is used for easy ordering."
                          },
                          "display_names": {
                            "type": "object",
                            "required": ["menu", "button", "receipt"],
                            "properties": {
                              "menu": {
                                "$ref": "#/definitions/multilingual_text"
                              },
                              "button": {
                                "$ref": "#/definitions/multilingual_text"
                              },
                              "receipt": {
                                "$ref": "#/definitions/multilingual_text"
                              }
                            }
                          },
                          "item_price_value": {
                            "type": "number",
                            "minimum": 0,
                            "multipleOf": 0.01
                          },
                          "pricing_schedules": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "required": ["schedule_id", "price"],
                              "properties": {
                                "schedule_id": {
                                  "type": "string"
                                },
                                "price": {
                                  "type": "number",
                                  "minimum": 0
                                },
                                "valid_days": {
                                  "type": "array",
                                  "items": {
                                    "type": "string",
                                    "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
                                  }
                                },
                                "valid_time": {
                                  "type": "object",
                                  "properties": {
                                    "start": {
                                      "type": "string",
                                      "pattern": "^([01]?[0-9]|2[0-3]):[0-5][0-9]$"
                                    },
                                    "end": {
                                      "type": "string",
                                      "pattern": "^([01]?[0-9]|2[0-3]):[0-5][0-9]$"
                                    }
                                  }
                                },
                                "date_range": {
                                  "type": "object",
                                  "properties": {
                                    "start": {
                                      "type": "string",
                                      "format": "date"
                                    },
                                    "end": {
                                      "type": "string",
                                      "format": "date"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "availability_schedule": {
                            "type": "object",
                            "properties": {
                              "always_available": {
                                "type": "boolean"
                              },
                              "schedules": {
                                "type": "array",
                                "items": {
                                  "type": "object"
                                }
                              }
                            }
                          },
                          "associated_category_unique_identifier": {
                            "type": "integer"
                          },
                          "additional_item_attributes": {
                            "type": "object"
                          },
                          "item_flags": {
                            "type": "object",
                            "required": ["is_sellable", "has_negative_price"],
                            "properties": {
                              "is_sellable": {
                                "type": "boolean"
                              },
                              "has_negative_price": {
                                "type": "boolean"
                              },
                              "requires_age_verification": {
                                "type": "boolean"
                              },
                              "is_organic": {
                                "type": "boolean"
                              }
                            }
                          },
                          "audit_trail": {
                            "$ref": "#/definitions/audit_trail"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "definitions": {
    "multilingual_text": {
      "type": "object",
      "patternProperties": {
        "^[a-z]{2}$": {
          "type": "string",
          "minLength": 1
        }
      },
      "additionalProperties": false,
      "minProperties": 1
    },
    "audit_trail": {
      "type": "object",
      "required": ["created_at", "created_by", "last_modified_at", "last_modified_by", "version"],
      "properties": {
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "created_by": {
          "type": "string",
          "format": "email"
        },
        "last_modified_at": {
          "type": "string",
          "format": "date-time"
        },
        "last_modified_by": {
          "type": "string",
          "format": "email"
        },
        "version": {
          "type": "integer",
          "minimum": 1
        },
        "change_log": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["timestamp", "user", "action"],
            "properties": {
              "timestamp": {
                "type": "string",
                "format": "date-time"
              },
              "user": {
                "type": "string",
                "format": "email"
              },
              "action": {
                "type": "string"
              },
              "old_value": {},
              "new_value": {},
              "reason": {
                "type": "string"
              },
              "description": {
                "type": "string"
              },
              "affected_components": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  }
}

--- File: /packages/backend/src/scripts/backfillEmbeddings.js ---

// File: /packages/backend/src/scripts/backfillEmbeddings.js

const db = require('../db/knex');
const { generateEmbedding, embeddingToBuffer } = require('../services/embedding.service');

async function backfillEmbeddings() {
  try {
    console.log('Starting embeddings backfill...');
    
    // Get all products from the database
    const products = await db('items').select('id', 'display_names');
    console.log(`Found ${products.length} products to process`);
    
    let processed = 0;
    let errors = 0;
    
    for (const product of products) {
      try {
        // Extract German product name from display_names JSON
        const displayNames = JSON.parse(product.display_names);
        const productName = displayNames.menu?.de || displayNames.menu?.en || 'Unknown Product';
        
        console.log(`Processing product ID ${product.id}: "${productName}"`);
        
        // Generate embedding
        const embedding = await generateEmbedding(productName);
        const embeddingBuffer = embeddingToBuffer(embedding);
        
        // Insert into vec_items table  
        await db.raw(
          'INSERT OR REPLACE INTO vec_items(rowid, item_embedding) VALUES (?, ?)',
          [product.id, embeddingBuffer]
        );
        
        processed++;
        console.log(`✓ Processed ${processed}/${products.length}: ${productName}`);
        
        // Add small delay to respect API rate limits
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        console.error(`✗ Error processing product ID ${product.id}:`, error.message);
        errors++;
      }
    }
    
    console.log(`\nBackfill completed:`);
    console.log(`- Processed: ${processed} products`);
    console.log(`- Errors: ${errors} products`);
    console.log(`- Success rate: ${((processed / products.length) * 100).toFixed(1)}%`);
    
  } catch (error) {
    console.error('Fatal error during backfill:', error);
    process.exit(1);
  } finally {
    await db.destroy();
  }
}

// Run the backfill if this script is executed directly
if (require.main === module) {
  backfillEmbeddings();
}

module.exports = backfillEmbeddings;

--- File: /packages/backend/src/scripts/migrate.js ---

// File: /packages/backend/src/scripts/migrate.js

const db = require('../db/knex');

async function runMigrations() {
  try {
    console.log('Running database migrations...');
    
    // Check if vec_items table already exists
    const exists = await db.schema.hasTable('vec_items');
    
    if (!exists) {
      console.log('Creating vec_items virtual table...');
      
      // Create the virtual table using raw SQL since the extension is loaded
      await db.raw(`
        CREATE VIRTUAL TABLE vec_items USING vec0(
          item_embedding FLOAT[768]
        )
      `);
      
      console.log('✓ vec_items table created successfully');
    } else {
      console.log('vec_items table already exists');
    }
    
    // Test the table by inserting a sample vector
    console.log('Testing vector operations...');
    
    const testVector = new Float32Array(768).fill(0.1);
    const testVectorJson = JSON.stringify(Array.from(testVector));
    
    await db.raw(
      'INSERT INTO vec_items(rowid, item_embedding) VALUES (?, ?)',
      [999999, testVectorJson]
    );
    
    // Query it back
    const result = await db.raw('SELECT rowid FROM vec_items WHERE rowid = 999999');
    console.log('✓ Vector operations working, test row:', result[0]);
    
    // Clean up test data
    await db.raw('DELETE FROM vec_items WHERE rowid = 999999');
    console.log('✓ Test data cleaned up');
    
    console.log('Migration completed successfully!');
    
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  } finally {
    await db.destroy();
  }
}

// Run migrations if this script is executed directly
if (require.main === module) {
  runMigrations();
}

module.exports = runMigrations;

--- File: /packages/backend/src/scripts/parse_and_init.js ---

#!/usr/bin/env node

/**
 * Universal script to parse a menu PDF and fully initialize the database.
 * 1. Parses the PDF to get structured data.
 * 2. Cleans the database.
 * 3. Imports the parsed data.
 * 4. Saves the "Original Menu" layout version.
 * 5. Enriches the data to create an "AI Optimized" layout version.
 * 6. Saves the "AI Optimized" layout version.
 * 
 * Usage: node packages/backend/src/scripts/parse_and_init.js <path_to_pdf>
 */

require('dotenv').config({ path: '../../../.env' });
const fs = require('fs').promises;
const path = require('path');
const db = require('../db/knex');
const MenuParserLLM = require('../lib/menu_parser_llm');
const { importFromOopMdf } = require('../services/import.service');
const { enrichMdfData } = require('../services/enrichment.service');
const layoutService = require('../services/layout.service');
const logger = require('../config/logger');
const chalk = require('chalk');

async function main() {
  const filePath = process.argv[2];
  if (!filePath) {
    console.error(chalk.red('❌ Error: Please provide a path to the menu PDF file.'));
    console.log(chalk.yellow('Usage: npm run setup:restaurant -- <path_to_pdf>'));
    process.exit(1);
  }

  logger.info(`🚀 Starting full initialization from: ${filePath}`);

  try {
    // === Step 1: Parse Menu ===
    logger.info('Step 1: Parsing menu PDF with LLM...');
    const parser = new MenuParserLLM();
    const restaurantName = path.basename(filePath, path.extname(filePath)).replace(/menu|karte/i, '').trim();
    const parsedResult = await parser.parseMenu(filePath, { restaurantName });
    const mdfData = parsedResult.configuration;
    logger.info('✅ Menu parsed successfully.');

    // === Step 2: Clean Database ===
    logger.info('Step 2: Cleaning all existing data...');
    await db.transaction(async (trx) => {
        await trx('menu_layouts').del();
        await trx('vec_items').del();
        await trx('items').del();
        await trx('categories').del();
        await trx('pos_devices').del();
        await trx('branches').del();
        await trx('companies').del();
    });
    logger.info('✅ Database cleaned.');

    // === Step 3: Import Parsed Data ===
    logger.info('Step 3: Importing data and generating initial embeddings...');
    await importFromOopMdf(mdfData);
    logger.info('✅ Data imported successfully.');
    
    // === Step 4: Save "Original Menu" Layout ===
    logger.info('Step 4: Saving "Original Menu Layout" snapshot...');
    const originalCategories = await db('categories').select('*');
    const originalLayout = await layoutService.saveLayout('Original Menu Layout', originalCategories, 'ORIGINAL_MENU');
    await layoutService.activateLayout(originalLayout.id); // Activate the original layout by default
    logger.info(`✅ "Original Menu Layout" saved with ID: ${originalLayout.id} and activated.`);

    // === Step 5: Enrich Data for "Smart" Layout ===
    logger.info('Step 5: Enriching data for "AI Optimized Layout"...');
    const enrichedData = await enrichMdfData(mdfData);
    const enrichedCategories = enrichedData.company_details.branches[0].point_of_sale_devices[0].categories_for_this_pos;
    logger.info('✅ Enrichment complete.');

    // === Step 6: Save "AI Optimized" Layout ===
    logger.info('Step 6: Saving "AI Optimized Layout" snapshot...');
    const aiLayout = await layoutService.saveLayout('AI Optimized Layout', enrichedCategories, 'AI_OPTIMIZED');
    logger.info(`✅ "AI Optimized Layout" saved with ID: ${aiLayout.id}.`);
    
    logger.info(chalk.green('\n🎉🎉🎉 Full initialization complete! The POS is ready.'));

  } catch (error) {
    logger.error('❌ Full initialization script failed:', { error: error.message, stack: error.stack });
    process.exit(1);
  } finally {
    await db.destroy();
  }
}

main();

--- File: /packages/backend/src/scripts/recover_pending_operations.js ---

const db = require('../db/knex');
const loggingService = require('../services/logging.service');
const logger = require('../config/logger');

/**
 * Scans the write-ahead log for pending fiscal operations and ensures they are committed.
 * This script is designed to be run on application startup to recover from unexpected shutdowns.
 */
async function recoverPendingFiscalOperations() {
  logger.info('Starting recovery process for pending fiscal operations...');

  try {
    // Find operations that were successfully signed by TSE but not yet committed to the final fiscal log.
    const operationsToCommit = await db('pending_fiscal_operations')
      .where('status', 'TSE_SUCCESS')
      .select('*');

    if (operationsToCommit.length > 0) {
      logger.warn({ count: operationsToCommit.length }, `Found ${operationsToCommit.length} pending fiscal operations to recover.`);
      for (const operation of operationsToCommit) {
        try {
          // The event_type and user_id are not stored in the pending log, which is a design limitation we accept for now.
          // For recovery, we'll use generic values.
          const recovered_event_type = 'recovered_transaction';
          const recovered_user_id = null; // We cannot know the user from the pending log alone.

          await loggingService.commitFiscalOperation(operation.id, recovered_event_type, recovered_user_id);
          logger.info({ operation_id: operation.operation_id }, `Successfully recovered and committed operation.`);
        } catch (commitError) {
          logger.error({ 
            msg: 'CRITICAL: Failed to commit a recovered fiscal operation.',
            operation_id: operation.operation_id,
            error: commitError.message
          });
        }
      }
    } else {
      logger.info('No pending fiscal operations found. System is clean.');
    }

    // Additionally, log operations that failed or are stuck in pending for manual review.
    const failedOperations = await db('pending_fiscal_operations')
      .whereIn('status', ['PENDING', 'TSE_FAILED']);
    
    if (failedOperations.length > 0) {
        logger.warn({ count: failedOperations.length }, `Found ${failedOperations.length} failed or stuck operations requiring review.`);
    }

  } catch (error) {
    logger.error({ msg: 'Recovery process failed.', error: error.message, stack: error.stack });
    // We allow the server to continue starting, but the issue is logged as critical.
  }
}

// Allow direct execution for testing purposes
if (require.main === module) {
  recoverPendingFiscalOperations().finally(() => db.destroy());
}

module.exports = { recoverPendingFiscalOperations };

--- File: /packages/backend/src/scripts/testHybridSearch.js ---

// File: /packages/backend/src/scripts/testHybridSearch.js

const { searchProducts, hybridSearch } = require('../services/search.service');
const db = require('../db/knex');

async function testHybridSearch() {
  console.log('🧪 Testing Hybrid Search System\n');
  
  try {
    // Test cases for different search scenarios
    const testCases = [
      {
        name: 'Exact FTS Match',
        query: 'Super Widget',
        expected: 'Should find exact match via FTS'
      },
      {
        name: 'Partial FTS Match',
        query: 'Widget',
        expected: 'Should find partial match via FTS'
      },
      {
        name: 'Semantic Vector Search',
        query: 'amazing product',
        expected: 'Should find semantic match via vector search'
      },
      {
        name: 'Typo Correction',
        query: 'Supr Widge',
        expected: 'Should correct typos and find match'
      },
      {
        name: 'Cup/Mug Semantic',
        query: 'cup',
        expected: 'Should find Eco Mug via semantic search'
      },
      {
        name: 'Non-existent Product',
        query: 'flying car',
        expected: 'Should return no results or suggestions'
      }
    ];

    for (const testCase of testCases) {
      console.log(`\n📋 Test: ${testCase.name}`);
      console.log(`🔍 Query: "${testCase.query}"`);
      console.log(`📝 Expected: ${testCase.expected}`);
      console.log('─'.repeat(50));
      
      const startTime = Date.now();
      const result = await searchProducts(testCase.query);
      const endTime = Date.now();
      
      console.log(`✅ Success: ${result.success}`);
      console.log(`💬 Message: ${result.message}`);
      console.log(`🔧 Method: ${result.metadata?.searchMethod || 'unknown'}`);
      console.log(`⏱️  Time: ${endTime - startTime}ms`);
      
      if (result.results && result.results.length > 0) {
        console.log(`📊 Results (${result.results.length}):`);
        result.results.forEach((item, index) => {
          console.log(`  ${index + 1}. ${item.productName} - ${item.price}€`);
          if (item.similarity) console.log(`     Similarity: ${item.similarity}%`);
          if (item.levenshteinDistance !== undefined) {
            console.log(`     Edit Distance: ${item.levenshteinDistance}`);
          }
        });
      }
      
      console.log('─'.repeat(50));
    }

    // Test direct hybrid search with different options
    console.log('\n🔬 Testing Direct Hybrid Search Options\n');
    
    const advancedTests = [
      {
        name: 'FTS Only Mode',
        query: 'Widget',
        options: { ftsOnly: true }
      },
      {
        name: 'Vector Only Mode', 
        query: 'cup',
        options: { vectorOnly: true }
      },
      {
        name: 'Strict Levenshtein',
        query: 'Widge',
        options: { levenshteinThreshold: 1 }
      },
      {
        name: 'Loose Vector Distance',
        query: 'beverage container',
        options: { vectorDistanceThreshold: 0.9 }
      }
    ];

    for (const test of advancedTests) {
      console.log(`\n🎯 Advanced Test: ${test.name}`);
      console.log(`🔍 Query: "${test.query}"`);
      console.log(`⚙️  Options: ${JSON.stringify(test.options)}`);
      console.log('─'.repeat(40));
      
      const result = await hybridSearch(test.query, test.options);
      
      console.log(`🔧 Method: ${result.metadata.searchMethod}`);
      console.log(`⏱️  Time: ${result.metadata.executionTime}ms`);
      console.log(`📊 Results: ${result.results.length}`);
      
      if (result.results.length > 0) {
        result.results.slice(0, 2).forEach((item, index) => {
          console.log(`  ${index + 1}. ${item.productName} (${item.search_type})`);
        });
      }
      console.log('─'.repeat(40));
    }

    console.log('\n✅ Hybrid Search Testing Completed Successfully!');
    
  } catch (error) {
    console.error('❌ Error during testing:', error);
    throw error;
  } finally {
    await db.destroy();
  }
}

// Run tests if this script is executed directly
if (require.main === module) {
  testHybridSearch()
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Test failed:', error);
      process.exit(1);
    });
}

module.exports = testHybridSearch;

--- File: /packages/backend/src/server.js ---

const path = require('path'); // Add this line
require('dotenv').config({ path: path.resolve(__dirname, '../../../.env') }); // Add this line
// Ensure this is BEFORE any other require that might need env variables, like your llm.service.js

// packages/backend/src/server.js
const http = require('http');
// Исправленный импорт для совместимости с разными версиями ws
const WebSocket = require('ws');
const app = require('./app'); // Ваше Express-приложение
const logger = require('./config/logger');
const layoutService = require('./services/layout.service');
const db = require('./db/knex');
const loggingService = require('./services/logging.service');

require('dotenv').config({ path: path.resolve(__dirname, '../../../.env') });

const PORT = process.env.BACKEND_PORT || 3030;
const nodeVersionRequired = '20.0.0';
const currentVersion = process.version;
console.log(`[DEBUG] Node.js version active for this script: ${currentVersion}`);

// Проверка версии Node.js для совместимости с v24
const semver = require('semver');
if (semver.major(currentVersion) < 20) {
  console.warn(`[WARNING] Node.js version ${currentVersion} may not be fully compatible. Recommended: v20+ or v24+`);
} else {
  console.log(`[INFO] Node.js version ${currentVersion} is compatible.`);
}
const httpServer = http.createServer(app);

// Используем правильный конструктор WebSocket Server
const wss = new WebSocket.Server({ server: httpServer });

// Хранилище для отслеживания активных/обработанных operationId (упрощенно)
const processedOperationIds = new Set();
const OPERATION_ID_TTL = 60000; // Время жизни ID операции в мс (например, 1 минута)

async function handleWebSocketMessage(ws, rawMessage) {
  let parsedMessage;
  try {
    parsedMessage = JSON.parse(rawMessage.toString());
    logger.info({ type: 'websocket_request', direction: 'in', data: parsedMessage, clientId: ws.id || 'unknown' });
  } catch (error) {
    logger.error({ msg: 'Invalid WebSocket message format (not JSON)', raw: rawMessage.toString(), clientId: ws.id, err: error });
    ws.send(JSON.stringify({ error: 'Invalid message format. Expected JSON.' , operationId: null }));
    return;
  }

  const { operationId, command, payload } = parsedMessage;

  if (!operationId) {
    logger.warn({ msg: 'WebSocket message without operationId', data: parsedMessage, clientId: ws.id });
    ws.send(JSON.stringify({ error: 'operationId is required', operationId: null }));
    return;
  }

  if (processedOperationIds.has(operationId)) {
    logger.info({ msg: 'Duplicate WebSocket operationId received, ignoring.', operationId, clientId: ws.id });
    // Отправляем подтверждение, что запрос уже обработан (или был обработан)
    // Можно добавить детали, если результат был сохранен
    const response = {
      operationId,
      status: 'already_processed',
      message: `Operation ${operationId} was already processed or is in progress.`,
      channel: 'websocket'
    };
    ws.send(JSON.stringify(response));
    logger.info({ type: 'websocket_response', direction: 'out', data: response, clientId: ws.id });
    return;
  }

  // Помечаем операцию как обрабатываемую
  processedOperationIds.add(operationId);
  setTimeout(() => {
    processedOperationIds.delete(operationId); // Очистка ID через некоторое время
  }, OPERATION_ID_TTL);

  // --- Обработка команды ---
  let responsePayload;
  let status = 'success';
  let responseCommand = command + 'Response';

  try {
    if (command === 'ping_ws') {
      responsePayload = { message: 'pong_ws', receivedPayload: payload };
    } else if (command === 'listLayouts') {
      responsePayload = await layoutService.listLayouts();
    } else if (command === 'activateLayout') {
      await layoutService.activateLayout(payload.id);
      responsePayload = { success: true, message: `Layout ${payload.id} activated.` };
    } else if (command === 'saveLayout') {
      const categories = await db('categories').select('*'); // Example: saving current state
      responsePayload = await layoutService.saveLayout(payload.name, categories);
    } else if (command === 'findOrCreateActiveTransaction') {
      const { criteria, userId } = payload;
      const transactionManagementService = require('./services/transaction_management.service.js');
      responsePayload = await transactionManagementService.findOrCreateActiveTransaction(criteria, userId);
      if (responsePayload && responsePayload.id) {
          const items = await db('active_transaction_items')
            .leftJoin('items', 'active_transaction_items.item_id', 'items.id')
            .select('active_transaction_items.*', 'items.display_names')
            .where('active_transaction_items.active_transaction_id', responsePayload.id);
          responsePayload.items = items;
      }
      responseCommand = 'orderUpdated';
    } else if (command === 'addItemToTransaction') {
      const { transactionId, itemId, quantity, userId } = payload;
      const transactionManagementService = require('./services/transaction_management.service.js');
      responsePayload = await transactionManagementService.addItemToTransaction(transactionId, itemId, quantity, userId);
      // Fetch items with display_names from products table
      if (responsePayload && responsePayload.id) {
          const items = await db('active_transaction_items')
            .leftJoin('items', 'active_transaction_items.item_id', 'items.id')
            .select('active_transaction_items.*', 'items.display_names')
            .where('active_transaction_items.active_transaction_id', responsePayload.id);
          responsePayload.items = items;
      }
      responseCommand = 'orderUpdated';
    } else if (command === 'finishTransaction') {
      const { transactionId, paymentData, userId } = payload;
      const transactionManagementService = require('./services/transaction_management.service.js');
      responsePayload = await transactionManagementService.finishTransaction(transactionId, paymentData, userId);
      responseCommand = 'transactionFinished';
    } else if (command === 'getCategories') {
      responsePayload = await db('categories').select('*');
    } else if (command === 'getItemsByCategory') {
      const { categoryId } = payload;
      if (!categoryId) {
        throw new Error('categoryId is required');
      }
      const productService = require('./services/product.service');
      responsePayload = await productService.getProductsByCategoryId(categoryId);
    } else if (command === 'getRecentReceipts') {
      const { limit } = payload || {};
      const reportingService = require('./services/reporting.service');
      responsePayload = await reportingService.getRecentTransactions(limit);
    } else if (command === 'logClientEvent') {
      const { level, message, context } = payload;
      // Log the event from the client without sending a response back
      loggingService.logSystemEvent(level, message, { ...context, source: 'frontend', clientId: ws.id });
      return; // End execution here for fire-and-forget logs
    
    // Authentication commands
    } else if (command === 'login') {
      const { username, password, ipAddress, userAgent } = payload;
      if (!username || !password) {
        throw new Error('Username and password are required');
      }
      const authService = require('./services/auth.service');
      responsePayload = await authService.authenticateUser(
        username, 
        password, 
        ipAddress || 'unknown', 
        userAgent || 'unknown'
      );
    } else if (command === 'logout') {
      const { sessionId } = payload;
      if (!sessionId) {
        throw new Error('SessionId is required');
      }
      const authService = require('./services/auth.service');
      const result = await authService.logout(sessionId);
      responsePayload = { success: result, message: result ? 'Logged out successfully' : 'Logout failed' };
    } else if (command === 'getCurrentUser') {
      const { sessionId } = payload;
      if (!sessionId) {
        throw new Error('SessionId is required');
      }
      const authService = require('./services/auth.service');
      const user = await authService.getCurrentUser(sessionId);
      responsePayload = user ? { success: true, user } : { success: false, error: 'Invalid session' };
    
    // Product management with permissions
    } else if (command === 'updateProduct') {
      const { productId, updates, sessionId } = payload;
      if (!productId || !updates || !sessionId) {
        throw new Error('ProductId, updates, and sessionId are required');
      }
      const productService = require('./services/product.service');
      responsePayload = await productService.updateExistingProduct(productId, updates, sessionId);
    
    // Storno operations
    } else if (command === 'performStorno') {
      const { sessionId, transactionId, amount, reason, isEmergency } = payload;
      if (!sessionId || !transactionId || !amount || !reason) {
        throw new Error('SessionId, transactionId, amount, and reason are required');
      }
      const transactionService = require('./services/transaction.service');
      responsePayload = await transactionService.performStorno(
        sessionId, 
        transactionId, 
        parseFloat(amount), 
        reason, 
        Boolean(isEmergency)
      );
    } else if (command === 'approveStorno') {
      const { managerSessionId, stornoId, approvalNotes } = payload;
      if (!managerSessionId || !stornoId) {
        throw new Error('ManagerSessionId and stornoId are required');
      }
      const transactionService = require('./services/transaction.service');
      responsePayload = await transactionService.approveStorno(managerSessionId, stornoId, approvalNotes);
    } else if (command === 'rejectStorno') {
      const { managerSessionId, stornoId, rejectionReason } = payload;
      if (!managerSessionId || !stornoId) {
        throw new Error('ManagerSessionId and stornoId are required');
      }
      const transactionService = require('./services/transaction.service');
      responsePayload = await transactionService.rejectStorno(managerSessionId, stornoId, rejectionReason);
    } else if (command === 'getPendingStornos') {
      const { sessionId } = payload;
      if (!sessionId) {
        throw new Error('SessionId is required');
      }
      const transactionService = require('./services/transaction.service');
      responsePayload = await transactionService.getPendingStornos(sessionId);
    
    // Manager operations for pending changes
    } else if (command === 'getPendingChanges') {
      const { sessionId, filterType } = payload;
      if (!sessionId) {
        throw new Error('SessionId is required');
      }
      const managerService = require('./services/manager.service');
      responsePayload = await managerService.getPendingChanges(sessionId, filterType);
    } else if (command === 'approveChange') {
      const { sessionId, changeId, approvalNotes } = payload;
      if (!sessionId || !changeId) {
        throw new Error('SessionId and changeId are required');
      }
      const managerService = require('./services/manager.service');
      responsePayload = await managerService.approveChange(sessionId, changeId, approvalNotes);
    } else if (command === 'rejectChange') {
      const { sessionId, changeId, rejectionReason } = payload;
      if (!sessionId || !changeId) {
        throw new Error('SessionId and changeId are required');
      }
      const managerService = require('./services/manager.service');
      responsePayload = await managerService.rejectChange(sessionId, changeId, rejectionReason);
    } else if (command === 'batchProcessChanges') {
      const { sessionId, actions } = payload;
      if (!sessionId || !actions || !Array.isArray(actions)) {
        throw new Error('SessionId and actions array are required');
      }
      const managerService = require('./services/manager.service');
      responsePayload = await managerService.batchProcessChanges(sessionId, actions);
    } else if (command === 'getManagerDashboard') {
      const { sessionId } = payload;
      if (!sessionId) {
        throw new Error('SessionId is required');
      }
      const managerService = require('./services/manager.service');
      responsePayload = await managerService.getDashboardStats(sessionId);
    
    // Permission checking
    } else if (command === 'checkPermission') {
      const { sessionId, permission } = payload;
      if (!sessionId || !permission) {
        throw new Error('SessionId and permission are required');
      }
      const authService = require('./services/auth.service');
      const hasPermission = await authService.hasPermission(sessionId, permission);
      responsePayload = { hasPermission, permission };
    } else if (command === 'canPerformAction') {
      const { sessionId, action } = payload;
      if (!sessionId || !action) {
        throw new Error('SessionId and action are required');
      }
      const authService = require('./services/auth.service');
      const canPerform = await authService.canPerformAction(sessionId, action);
      responsePayload = { canPerform, action };
    
    // Pending transaction resolution
    } else if (command === 'resolvePendingTransaction') {
      const { transactionId, resolution, userId } = payload;
      if (!transactionId || !resolution || !userId) {
        throw new Error('TransactionId, resolution, and userId are required');
      }
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.resolvePendingTransaction(transactionId, resolution, userId);
    
    // Parked orders management
    } else if (command === 'parkTransaction') {
      const { transactionId, tableIdentifier, userId, updateTimestamp } = payload;
      if (!transactionId || !tableIdentifier || !userId) {
        throw new Error('TransactionId, tableIdentifier, and userId are required');
      }
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.parkTransaction(transactionId, tableIdentifier, userId, updateTimestamp);
    } else if (command === 'activateTransaction') {
      const { transactionId, userId, updateTimestamp } = payload;
      if (!transactionId || !userId) {
        throw new Error('TransactionId and userId are required');
      }
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.activateTransaction(transactionId, userId, updateTimestamp);
      responseCommand = 'orderUpdated';
    } else if (command === 'getParkedTransactions') {
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.getParkedTransactions();
    } else if (command === 'updateTransactionMetadata') {
      const { transactionId, metadata, userId, updateTimestamp = false } = payload;
      if (!transactionId || !metadata || !userId) {
        throw new Error('TransactionId, metadata, and userId are required');
      }
      const transactionManagementService = require('./services/transaction_management.service');
      responsePayload = await transactionManagementService.updateTransactionMetadata(transactionId, metadata, userId, updateTimestamp);
    } else if (command === 'checkTableAvailability') {
      const { tableNumber, excludeTransactionId } = payload;
      if (!tableNumber) {
        throw new Error('Table number is required');
      }
      const transactionManagementService = require('./services/transaction_management.service');
      const isInUse = await transactionManagementService.checkTableNumberInUse(tableNumber, excludeTransactionId);
      responsePayload = { tableNumber, isInUse };
      responseCommand = 'checkTableAvailabilityResponse';
    
    } else {
      status = 'error';
      responsePayload = { message: 'Unknown command', originalCommand: command };
      logger.warn({ msg: 'Unknown WebSocket command', command, operationId, clientId: ws.id });
    }
  } catch (error) {
    status = 'error';
    responsePayload = { message: 'Command execution failed', error: error.message };
    logger.error({ msg: 'WebSocket command execution error', command, operationId, clientId: ws.id, error: error.message });
  }
  // --- Конец обработки команды ---

  const response = { 
    operationId, 
    command: responseCommand, 
    status, 
    payload: responsePayload, 
    channel: 'websocket',
    serverTime: new Date().toISOString()
  };
  ws.send(JSON.stringify(response));
  logger.info({ type: 'websocket_response', direction: 'out', data: response, clientId: ws.id });
}


wss.on('connection', (ws, req) => {
  // req.socket.remoteAddress можно использовать для получения IP, если нужно
  ws.id = Date.now() + '_' + Math.random().toString(36).substring(2,7); // Простой уникальный ID для клиента
  logger.info({ msg: 'WebSocket client connected', clientId: ws.id, remoteAddress: req.socket.remoteAddress });

  ws.on('message', (message) => {
    handleWebSocketMessage(ws, message);
  });

  ws.on('close', () => {
    logger.info({ msg: 'WebSocket client disconnected', clientId: ws.id });
  });

  ws.on('error', (error) => {
    logger.error({ msg: 'WebSocket client error', clientId: ws.id, err: error });
  });

  ws.send(JSON.stringify({ 
    message: 'Welcome to ecKasse WebSocket API!', 
    clientId: ws.id,
    serverTime: new Date().toISOString()
  }));

  // Send pending recovery transactions to the newly connected client
  (async () => {
    try {
      const transactionManagementService = require('./services/transaction_management.service');
      const pendingTransactions = await transactionManagementService.getPendingTransactions();
      
      if (pendingTransactions.length > 0) {
        const pendingMessage = {
          command: 'pendingTransactions',
          payload: {
            transactions: pendingTransactions,
            count: pendingTransactions.length
          },
          timestamp: new Date().toISOString(),
          clientId: ws.id
        };
        
        ws.send(JSON.stringify(pendingMessage));
        logger.info({ 
          msg: 'Sent pending recovery transactions to client', 
          clientId: ws.id, 
          count: pendingTransactions.length 
        });
      } else {
        logger.info({ 
          msg: 'No pending recovery transactions to send to client', 
          clientId: ws.id 
        });
        
        // Send company/branch info since no pending transactions exist
        try {
          const companyInfo = await getCompanyAndBranchInfo();
          const initialAppDataMessage = {
            command: 'initialAppData',
            payload: {
              companyInfo
            },
            serverTime: new Date().toISOString(),
            clientId: ws.id
          };
          
          ws.send(JSON.stringify(initialAppDataMessage));
          logger.info({ 
            msg: 'Sent initial app data (company info) to client', 
            clientId: ws.id,
            companyInfo
          });
        } catch (error) {
          logger.error({ 
            msg: 'Failed to send initial app data to client', 
            clientId: ws.id, 
            error: error.message 
          });
        }
      }
    } catch (error) {
      logger.error({ 
        msg: 'Failed to send pending recovery transactions to client', 
        clientId: ws.id, 
        error: error.message 
      });
    }
  })();
});

/**
 * Gets company and branch information from the database
 */
async function getCompanyAndBranchInfo() {
  try {
    // Get company information - assuming there's a company/settings table
    // This is a placeholder - adjust according to your actual database schema
    const companyData = await db('companies').first() || {};
    const branchData = await db('branches').first() || {};
    
    return {
      companyName: companyData.name || 'ecKasse Demo',
      branchName: branchData.name || 'Hauptfiliale',
      branchAddress: branchData.address || 'Musterstraße 1, 12345 Berlin'
    };
    
  } catch (error) {
    logger.warn({ 
      msg: 'Could not fetch company/branch info from database, using defaults', 
      error: error.message 
    });
    
    // Return default values if database tables don't exist yet
    return {
      companyName: 'ecKasse Demo',
      branchName: 'Hauptfiliale',
      branchAddress: 'Musterstraße 1, 12345 Berlin'
    };
  }
}

/**
 * Runs recovery process to identify stale active transactions and mark them as pending for manual resolution.
 * This function runs on startup and finds transactions left in 'active' state from previous sessions.
 */
async function runRecoveryProcess() {
  logger.info('Starting recovery process for stale active transactions...');
  
  try {
    // Find all transactions that are still 'active' but have resolution_status 'none'
    // These are transactions that were left hanging from a previous session
    const staleTransactions = await db('active_transactions')
      .where('status', 'active')
      .where('resolution_status', 'none')
      .select('id', 'uuid', 'created_at');

    if (staleTransactions.length > 0) {
      // Update their resolution_status to 'pending' for manual resolution
      await db('active_transactions')
        .where('status', 'active')
        .where('resolution_status', 'none')
        .update('resolution_status', 'pending');

      logger.warn({ 
        count: staleTransactions.length,
        transactions: staleTransactions.map(t => ({ id: t.id, uuid: t.uuid, created_at: t.created_at }))
      }, `Marked ${staleTransactions.length} stale transactions as pending for recovery.`);
    } else {
      logger.info('No stale active transactions found. System is clean.');
    }
  } catch (error) {
    logger.error({ 
      msg: 'Failed to run recovery process for stale active transactions.', 
      error: error.message, 
      stack: error.stack 
    });
    // Continue startup even if recovery fails, but log the critical error
  }
}

/**
 * Initializes and starts the server.
 * Runs the recovery process for pending fiscal operations before accepting connections.
 */
async function startServer() {
  const { recoverPendingFiscalOperations } = require('./scripts/recover_pending_operations');
  
  // Ensure data integrity by recovering any pending operations from the last session.
  await recoverPendingFiscalOperations();
  
  // Run recovery process for stale active transactions
  await runRecoveryProcess();

  // Now, start the server.
  httpServer.listen(PORT, () => {
    logger.info(`Backend server (HTTP & WebSocket) listening on http://localhost:${PORT}`);
  });
}

// Start the server with the recovery mechanism.
startServer();

--- File: /packages/backend/src/services/auth.service.js ---

// Authentication and user management service
const bcrypt = require('bcrypt');
const crypto = require('crypto');
const db = require('../db/knex');
const logger = require('../config/logger');

/**
 * AuthService handles user authentication, session management, and permission checking
 */
class AuthService {
    constructor() {
        this.activeSessions = new Map(); // In-memory session store
        this.sessionTimeout = 8 * 60 * 60 * 1000; // 8 hours in milliseconds
    }

    /**
     * Authenticate user with username and password
     * @param {string} username - User's username
     * @param {string} password - User's password
     * @param {string} ipAddress - Client IP address
     * @param {string} userAgent - Client user agent
     * @returns {Object} Authentication result with session token or error
     */
    async authenticateUser(username, password, ipAddress = 'unknown', userAgent = 'unknown') {
        logger.info({ 
            service: 'AuthService', 
            function: 'authenticateUser', 
            username, 
            ipAddress 
        }, 'Attempting user authentication');

        try {
            // Get user with role information
            const user = await db('users')
                .select([
                    'users.*',
                    'roles.role_name',
                    'roles.permissions',
                    'roles.can_approve_changes',
                    'roles.can_manage_users'
                ])
                .join('roles', 'users.role_id', 'roles.id')
                .where('users.username', username)
                .where('users.is_active', true)
                .first();

            if (!user) {
                await this.logFailedAttempt(username, ipAddress, 'user_not_found');
                throw new Error('Invalid credentials');
            }

            // Check if user is locked
            if (user.locked_until && new Date(user.locked_until) > new Date()) {
                const lockTimeRemaining = Math.ceil((new Date(user.locked_until) - new Date()) / 1000 / 60);
                throw new Error(`Account locked. Try again in ${lockTimeRemaining} minutes.`);
            }

            // Verify password
            const passwordValid = await bcrypt.compare(password, user.password_hash);
            
            if (!passwordValid) {
                await this.handleFailedLogin(user.id, ipAddress);
                throw new Error('Invalid credentials');
            }

            // Reset failed login attempts on successful login
            await this.resetFailedAttempts(user.id);

            // Create session
            const sessionData = await this.createSession(user, ipAddress, userAgent);

            // Update last login
            await db('users')
                .where('id', user.id)
                .update({
                    last_login_at: new Date(),
                    last_login_ip: ipAddress
                });

            logger.info({ 
                userId: user.id, 
                username: user.username, 
                role: user.role_name,
                sessionId: sessionData.sessionId
            }, 'User authenticated successfully');

            return {
                success: true,
                user: {
                    id: user.id,
                    username: user.username,
                    full_name: user.full_name,
                    email: user.email,
                    role: user.role_name,
                    permissions: JSON.parse(user.permissions),
                    storno_daily_limit: parseFloat(user.storno_daily_limit),
                    storno_emergency_limit: parseFloat(user.storno_emergency_limit),
                    storno_used_today: parseFloat(user.storno_used_today),
                    trust_score: user.trust_score,
                    can_approve_changes: user.can_approve_changes,
                    can_manage_users: user.can_manage_users,
                    force_password_change: user.force_password_change
                },
                session: sessionData
            };

        } catch (error) {
            logger.error({ 
                service: 'AuthService', 
                function: 'authenticateUser', 
                username, 
                error: error.message 
            }, 'Authentication failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Create a new session for authenticated user
     * @param {Object} user - User object from database
     * @param {string} ipAddress - Client IP address
     * @param {string} userAgent - Client user agent
     * @returns {Object} Session data
     */
    async createSession(user, ipAddress, userAgent) {
        const sessionId = crypto.randomUUID();
        const expiresAt = new Date(Date.now() + this.sessionTimeout);

        // Store session in database
        await db('user_sessions').insert({
            session_id: sessionId,
            user_id: user.id,
            expires_at: expiresAt,
            ip_address: ipAddress,
            user_agent: userAgent,
            is_active: true
        });

        // Store session in memory for quick access
        this.activeSessions.set(sessionId, {
            userId: user.id,
            username: user.username,
            role: user.role_name,
            permissions: JSON.parse(user.permissions),
            expiresAt: expiresAt.getTime(),
            ipAddress,
            userAgent
        });

        return {
            sessionId,
            expiresAt: expiresAt.toISOString(),
            timeout: this.sessionTimeout
        };
    }

    /**
     * Validate session and get user info
     * @param {string} sessionId - Session ID to validate
     * @returns {Object|null} User session data or null if invalid
     */
    async validateSession(sessionId) {
        if (!sessionId) return null;

        // Check memory cache first
        const memorySession = this.activeSessions.get(sessionId);
        if (memorySession && memorySession.expiresAt > Date.now()) {
            return memorySession;
        }

        // Check database if not in memory or expired
        const dbSession = await db('user_sessions')
            .select([
                'user_sessions.*',
                'users.username',
                'users.is_active',
                'roles.role_name',
                'roles.permissions'
            ])
            .join('users', 'user_sessions.user_id', 'users.id')
            .join('roles', 'users.role_id', 'roles.id')
            .where('user_sessions.session_id', sessionId)
            .where('user_sessions.is_active', true)
            .where('user_sessions.expires_at', '>', new Date())
            .where('users.is_active', true)
            .first();

        if (!dbSession) {
            // Clean up invalid session from memory
            this.activeSessions.delete(sessionId);
            return null;
        }

        // Refresh memory cache
        const sessionData = {
            userId: dbSession.user_id,
            username: dbSession.username,
            role: dbSession.role_name,
            permissions: JSON.parse(dbSession.permissions),
            expiresAt: new Date(dbSession.expires_at).getTime(),
            ipAddress: dbSession.ip_address,
            userAgent: dbSession.user_agent
        };

        this.activeSessions.set(sessionId, sessionData);
        return sessionData;
    }

    /**
     * Check if user has specific permission
     * @param {string} sessionId - Session ID
     * @param {string} permission - Permission to check (e.g., 'products.edit')
     * @returns {boolean} True if user has permission
     */
    async hasPermission(sessionId, permission) {
        const session = await this.validateSession(sessionId);
        if (!session) return false;

        return session.permissions.includes(permission) || 
               session.permissions.includes('system.admin');
    }

    /**
     * Check if user can perform action based on role
     * @param {string} sessionId - Session ID
     * @param {string} action - Action to check (e.g., 'approve_changes', 'manage_users')
     * @returns {boolean} True if user can perform action
     */
    async canPerformAction(sessionId, action) {
        const session = await this.validateSession(sessionId);
        if (!session) return false;

        const actionPermissions = {
            'approve_changes': ['changes.approve', 'system.admin'],
            'manage_users': ['users.manage', 'system.admin'],
            'unlimited_storno': ['storno.approve_unlimited', 'system.admin'],
            'create_products': ['products.create', 'system.admin'],
            'edit_products': ['products.edit', 'system.admin'],
            'delete_products': ['products.delete', 'system.admin'],
            'view_reports': ['reports.view_all', 'reports.view_department', 'reports.view_own']
        };

        const requiredPerms = actionPermissions[action] || [];
        return requiredPerms.some(perm => session.permissions.includes(perm));
    }

    /**
     * Logout user and invalidate session
     * @param {string} sessionId - Session ID to invalidate
     * @returns {boolean} True if successfully logged out
     */
    async logout(sessionId) {
        try {
            // Remove from memory
            this.activeSessions.delete(sessionId);

            // Deactivate in database
            await db('user_sessions')
                .where('session_id', sessionId)
                .update({ is_active: false });

            logger.info({ sessionId }, 'User logged out successfully');
            return true;
        } catch (error) {
            logger.error({ sessionId, error: error.message }, 'Error during logout');
            return false;
        }
    }

    /**
     * Handle failed login attempt
     * @param {number} userId - User ID
     * @param {string} ipAddress - IP address of failed attempt
     */
    async handleFailedLogin(userId, ipAddress) {
        const user = await db('users').where('id', userId).first();
        const newFailedAttempts = (user.failed_login_attempts || 0) + 1;
        const maxAttempts = 5; // Configurable

        const updateData = { failed_login_attempts: newFailedAttempts };

        // Lock account if too many failed attempts
        if (newFailedAttempts >= maxAttempts) {
            const lockDuration = 30 * 60 * 1000; // 30 minutes
            updateData.locked_until = new Date(Date.now() + lockDuration);
            
            logger.warn({ 
                userId, 
                username: user.username, 
                failedAttempts: newFailedAttempts,
                lockedUntil: updateData.locked_until
            }, 'User account locked due to failed login attempts');
        }

        await db('users').where('id', userId).update(updateData);
        await this.logFailedAttempt(user.username, ipAddress, 'invalid_password');
    }

    /**
     * Reset failed login attempts
     * @param {number} userId - User ID
     */
    async resetFailedAttempts(userId) {
        await db('users')
            .where('id', userId)
            .update({ 
                failed_login_attempts: 0, 
                locked_until: null 
            });
    }

    /**
     * Log failed login attempt
     * @param {string} username - Username that failed
     * @param {string} ipAddress - IP address
     * @param {string} reason - Reason for failure
     */
    async logFailedAttempt(username, ipAddress, reason) {
        logger.warn({ 
            service: 'AuthService',
            event: 'failed_login',
            username, 
            ipAddress, 
            reason 
        }, 'Failed login attempt');

        // Could store in separate audit table if needed
    }

    /**
     * Clean up expired sessions (should be called periodically)
     */
    async cleanupExpiredSessions() {
        try {
            // Remove from database
            const result = await db('user_sessions')
                .where('expires_at', '<', new Date())
                .orWhere('is_active', false)
                .del();

            // Clean up memory cache
            for (const [sessionId, session] of this.activeSessions.entries()) {
                if (session.expiresAt <= Date.now()) {
                    this.activeSessions.delete(sessionId);
                }
            }

            logger.info({ 
                service: 'AuthService',
                removedSessions: result,
                activeSessions: this.activeSessions.size
            }, 'Cleaned up expired sessions');

        } catch (error) {
            logger.error({ 
                service: 'AuthService', 
                error: error.message 
            }, 'Error cleaning up expired sessions');
        }
    }

    /**
     * Get current user by session ID
     * @param {string} sessionId - Session ID
     * @returns {Object|null} Current user data or null
     */
    async getCurrentUser(sessionId) {
        const session = await this.validateSession(sessionId);
        if (!session) return null;

        const user = await db('users')
            .select([
                'users.id',
                'users.username',
                'users.full_name',
                'users.email',
                'users.storno_daily_limit',
                'users.storno_emergency_limit',
                'users.storno_used_today',
                'users.trust_score',
                'roles.role_name',
                'roles.permissions',
                'roles.can_approve_changes',
                'roles.can_manage_users'
            ])
            .join('roles', 'users.role_id', 'roles.id')
            .where('users.id', session.userId)
            .where('users.is_active', true)
            .first();

        if (!user) return null;

        return {
            id: user.id,
            username: user.username,
            full_name: user.full_name,
            email: user.email,
            role: user.role_name,
            permissions: JSON.parse(user.permissions),
            storno_daily_limit: parseFloat(user.storno_daily_limit),
            storno_emergency_limit: parseFloat(user.storno_emergency_limit),
            storno_used_today: parseFloat(user.storno_used_today),
            trust_score: user.trust_score,
            can_approve_changes: user.can_approve_changes,
            can_manage_users: user.can_manage_users
        };
    }
}

// Create singleton instance
const authService = new AuthService();

// Clean up expired sessions every hour
setInterval(() => {
    authService.cleanupExpiredSessions();
}, 60 * 60 * 1000);

module.exports = authService;

--- File: /packages/backend/src/services/category.service.js ---

// Placeholder for category management logic

/**
 * Create a new product category
 * @param {Object} details - Category details (name, type)
 * @returns {Object} Created category data
 */
async function createNewCategory(details) {
    console.log(`(SERVICE STUB) Creating category: ${details.name} of type ${details.type}...`);
    return { 
        success: true, 
        categoryId: 'cat_mock_' + Date.now(),
        name: details.name,
        type: details.type
    };
}

/**
 * Update an existing category
 * @param {string} id - Category ID or name
 * @param {Object} updates - Fields to update
 * @returns {Object} Updated category data
 */
async function updateExistingCategory(id, updates) {
    console.log(`(SERVICE STUB) Updating category ${id} with:`, updates);
    return { 
        success: true, 
        categoryId: id,
        updated: true,
        changes: updates
    };
}

/**
 * Get all categories
 * @returns {Object} List of all categories
 */
async function getAllCategories() {
    console.log(`(SERVICE STUB) Getting all categories...`);
    return { 
        success: true, 
        categories: [
            { id: 'cat_mock_1', name: 'Drinks', type: 'drink' },
            { id: 'cat_mock_2', name: 'Food', type: 'food' },
            { id: 'cat_mock_3', name: 'Desserts', type: 'food' }
        ]
    };
}

module.exports = { 
    createNewCategory, 
    updateExistingCategory, 
    getAllCategories 
};

--- File: /packages/backend/src/services/embedding.service.js ---

// File: /packages/backend/src/services/embedding.service.js

const { geminiClient: ai } = require('./llm.provider');
const { handleGeminiError, createGeminiErrorLog } = require('../utils/geminiErrorHandler');

// Отключаем моки - используем только реальный API
const USE_MOCK_EMBEDDINGS = false;

/**
 * Generate embedding vector for text using Google's gemini-embedding-001 model
 * @param {string} text - Text to generate embedding for
 * @param {Object} options - Additional options
 * @returns {Promise<number[]>} - Array of 768 float values representing the embedding
 */
async function generateEmbedding(text, options = {}) {
  
  try {
    console.log(`🔍 Генерирую embedding для: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
    
    const response = await ai.models.embedContent({
      model: options.model || 'gemini-embedding-001',
      contents: [text],
      config: {
        taskType: options.taskType || "RETRIEVAL_DOCUMENT",
        outputDimensionality: options.outputDimensionality || 768
      }
    });
    
    // Правильное извлечение values из структуры ответа
    if (!response.embeddings || response.embeddings.length === 0) {
      throw new Error('API returned no embeddings.');
    }
    
    const embeddingObject = response.embeddings[0];
    const embedding = embeddingObject.values;
    const stats = embeddingObject.statistics;
    
    // The `statistics` object is optional
    if (stats && typeof stats.token_count !== 'undefined') {
      console.log(`✅ Embedding создан: ${embedding.length} измерений, ${stats.token_count} токенов`);
      if (stats.truncated) {
        console.warn('⚠️  Текст был обрезан при создании embedding');
      }
    } else {
      console.log(`✅ Embedding создан: ${embedding.length} измерений (статистика токенов недоступна)`);
    }
    
    return embedding;
    
  } catch (error) {
    // Обработка специфических ошибок Gemini API
    const geminiErrorInfo = handleGeminiError(error, { 
      language: 'ru', 
      includeRetryInfo: true 
    });
    
    // Создаем структурированный лог
    const errorLog = createGeminiErrorLog(error, {
      operation: 'embedding_generation',
      text: text.substring(0, 50), // Первые 50 символов текста
      isTemporary: geminiErrorInfo.isTemporary
    });
    
    // Выводим лог в консоль с соответствующим уровнем
    if (errorLog.level === 'warn') {
      console.warn('🚦 GEMINI EMBEDDING LIMIT:', errorLog.userMessage);
      console.warn('   Retry in:', errorLog.retryDelay + 's');
    } else {
      console.error('❌ GEMINI EMBEDDING ERROR:', errorLog.userMessage);
    }
    
    throw error;
  }
}

/**
 * Generate embeddings for multiple texts at once
 * @param {string[]} texts - Array of texts to generate embeddings for
 * @param {Object} options - Additional options
 * @returns {Promise<number[][]>} - Array of embedding vectors
 */
async function generateBatchEmbeddings(texts, options = {}) {
  
  try {
    console.log(`🔍 Генерирую batch embeddings для ${texts.length} текстов`);
    
    const response = await ai.models.embedContent({
      model: options.model || 'gemini-embedding-001',
      contents: texts,
      config: {
        taskType: options.taskType || "RETRIEVAL_DOCUMENT",
        outputDimensionality: options.outputDimensionality || 768
      }
    });
    
    // Извлекаем values из каждого embedding
    const embeddings = response.embeddings.map(embedding => embedding.values);
    const totalTokens = response.embeddings.reduce((sum, emb) => {
      return sum + (emb.statistics?.token_count || 0);
    }, 0);
    
    console.log(`✅ Batch embeddings созданы: ${embeddings.length} векторов, ${totalTokens} токенов`);
    
    return embeddings;
    
  } catch (error) {
    const geminiErrorInfo = handleGeminiError(error, { 
      language: 'ru', 
      includeRetryInfo: true 
    });
    
    console.error('❌ GEMINI BATCH EMBEDDING ERROR:', geminiErrorInfo.userMessage);
    throw error;
  }
}

/**
 * Get embedding statistics for text
 * @param {string} text - Text to analyze
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} - Statistics object
 */
async function getEmbeddingStats(text, options = {}) {
  
  try {
    const response = await ai.models.embedContent({
      model: options.model || 'gemini-embedding-001',
      contents: [text],
      config: {
        taskType: options.taskType || "RETRIEVAL_DOCUMENT",
        outputDimensionality: options.outputDimensionality || 768
      }
    });
    
    const embedding = response.embeddings[0];
    
    return {
      dimensions: embedding.values.length,
      tokenCount: embedding.statistics?.token_count ?? 0,
      truncated: embedding.statistics?.truncated ?? false,
      billableCharacters: response.metadata?.billable_character_count || 0
    };
    
  } catch (error) {
    console.error('❌ Error getting embedding stats:', error.message);
    throw error;
  }
}

/**
 * Convert embedding array to Float32Array buffer for sqlite-vec
 * @param {number[]} embedding - Array of float values
 * @returns {Buffer} - Buffer suitable for sqlite-vec
 */
function embeddingToBuffer(embedding) {
  const float32Array = new Float32Array(embedding);
  return Buffer.from(float32Array.buffer);
}

/**
 * Convert Buffer back to regular array
 * @param {Buffer} buffer - Buffer from sqlite-vec
 * @returns {number[]} - Array of float values
 */
function bufferToEmbedding(buffer) {
  const float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length / 4);
  return Array.from(float32Array);
}

/**
 * Convert embedding array to JSON string (deprecated - for compatibility)
 * @param {number[]} embedding - Array of float values
 * @returns {string} - JSON string
 */
function embeddingToJson(embedding) {
  return JSON.stringify(embedding);
}

/**
 * Convert JSON string back to regular array (deprecated - for compatibility)
 * @param {string} jsonString - JSON string
 * @returns {number[]} - Array of float values
 */
function jsonToEmbedding(jsonString) {
  return JSON.parse(jsonString);
}

module.exports = {
  generateEmbedding,
  generateBatchEmbeddings,
  getEmbeddingStats,
  embeddingToBuffer,
  bufferToEmbedding,
  embeddingToJson,
  jsonToEmbedding
};

--- File: /packages/backend/src/services/enrichment.service.js ---

/**
 * Multi-pass enrichment service for OOP-POS-MDF data
 * This service performs AI-powered enrichment of menu items and categories
 */

const chalk = require('chalk');
const { generateEmbedding } = require('./embedding.service');
const { invokeSimpleQuery } = require('./llm.service');

// Intelligent prompt templates for name abbreviation
const BUTTON_NAME_PROMPT_TEMPLATE = `
You are an expert UI text designer creating concise labels for POS system buttons.
Your task is to create a short name for a button from a full product name.

## INSTRUCTIONS ##
1.  **Output Format:** The result MUST be two lines, separated by a single newline character (\\n).
2.  **Character Limit:** Each of the two lines MUST NOT exceed 10 characters.
3.  **Content Logic:**
    - Analyze the full product name to identify the two most significant and descriptive words.
    - Remove all articles, prepositions, and connector words (e.g., "di", "and", "with").
    - Place the most important word on the first line and the second most important word on the second line.
4.  **CRITICAL OUTPUT RULE:** Your response MUST contain ONLY the resulting text for the button. DO NOT include any explanations, markdown, JSON formatting, or any other characters.

## EXAMPLES ##

- Full Name: "Pesto di Mykonos"
- Correct Output: Pesto\\nMykonos

- Full Name: "Lemon Garlic Shrimps"
- Correct Output: Lemon\\nShrimps

- Full Name: "90s Pasta Salad"
- Incorrect Output: 90s Pasta\\nSalad (First line is too long)
- Correct Output: Pasta\\nSalad

- Full Name: "Avocado Pistachio Cream"
- Incorrect Output: {"button": "Avocado..."} (Contains JSON)
- Correct Output: Avocado\\nPistachio

## YOUR TASK ##
Now, apply this logic to the following product.
Full Name: "{productName}"
`;

const RECEIPT_NAME_PROMPT_TEMPLATE = `
You are an expert at summarizing text for limited-space displays like cash register receipts.
Your task is to create a condensed, single-line name from a full product name.

## INSTRUCTIONS ##
1.  **Output Format:** The result MUST be a single line of text.
2.  **Character Limit:** The entire output MUST NOT exceed 42 characters.
3.  **Content Logic:**
    - Retain the most important and identifying words.
    - Use common, understandable abbreviations if necessary to meet the length requirement (e.g., "Cream" -> "Crm", "Chocolate" -> "Choc").
    - Remove generic words if the specific words are more descriptive.
4.  **CRITICAL OUTPUT RULE:** Your response MUST contain ONLY the resulting text. DO NOT include any explanations or formatting.

## EXAMPLES ##

- Full Name: "Hello Pasta with Truffle Mushroom Cream Sauce"
- Correct Output: Hello Pasta Truffle Mushroom Crm

- Full Name: "Extra Parmesan Add-on"
- Correct Output: Extra Parmesan Add-on

## YOUR TASK ##
Now, apply this logic to the following product.
Full Name: "{productName}"
`;

/**
 * Main enrichment function that orchestrates the multi-pass process
 * @param {Object} mdfData - The OOP-POS-MDF configuration object
 * @param {Object} options - Enrichment options
 * @returns {Promise<Object>} - Enriched MDF data
 */
async function enrichMdfData(mdfData, options = {}) {
    console.log(chalk.blue('🔬 Starting multi-pass enrichment process...'));
    
    // Create a deep copy to avoid modifying the original
    const enrichedData = JSON.parse(JSON.stringify(mdfData));
    
    try {
        // Pass 1: Initial validation and preparation
        console.log(chalk.blue('\n📋 Pass 1: Validating and preparing data...'));
        await validateAndPrepareData(enrichedData);
        
        // Pass 2: Item enrichment and abbreviation generation
        if (!options.skipWebSearch) {
            console.log(chalk.blue('\n🔍 Pass 2: Enriching items with web data and generating abbreviations...'));
            await enrichItemsWithWebData(enrichedData);
        } else {
            console.log(chalk.gray('\n⏭️  Pass 2: Skipping web search enrichment'));
        }
        
        // Pass 3: Warengruppen (Main Groups) assignment
        if (!options.skipMainGroups) {
            console.log(chalk.blue('\n🏷️  Pass 3: Generating and assigning main groups (Warengruppen)...'));
            await generateAndAssignMainGroups(enrichedData);
        } else {
            console.log(chalk.gray('\n⏭️  Pass 3: Skipping main groups generation'));
        }
        
        // Pass 4: Final validation and cleanup
        console.log(chalk.blue('\n✅ Pass 4: Final validation and cleanup...'));
        await finalizeEnrichment(enrichedData);
        
        console.log(chalk.green('\n🎉 Multi-pass enrichment completed successfully!'));
        return enrichedData;
        
    } catch (error) {
        console.error(chalk.red(`\n❌ Enrichment failed: ${error.message}`));
        throw error;
    }
}

/**
 * Pass 1: Validate and prepare the data structure
 * @param {Object} enrichedData - The MDF data to validate
 */
async function validateAndPrepareData(enrichedData) {
    // Verify essential structure exists
    if (!enrichedData.company_details) {
        throw new Error('Invalid MDF structure: missing company_details');
    }
    
    if (!enrichedData.company_details.branches) {
        throw new Error('Invalid MDF structure: missing branches');
    }
    
    // Count items and categories for progress tracking
    let totalItems = 0;
    let totalCategories = 0;
    
    for (const branch of enrichedData.company_details.branches) {
        if (branch.point_of_sale_devices) {
            for (const pos of branch.point_of_sale_devices) {
                if (pos.items_for_this_pos) {
                    totalItems += pos.items_for_this_pos.length;
                }
                if (pos.categories_for_this_pos) {
                    totalCategories += pos.categories_for_this_pos.length;
                }
            }
        }
    }
    
    console.log(chalk.cyan(`   Found ${totalItems} items and ${totalCategories} categories to process`));
    
    // Initialize global configurations if not present
    if (!enrichedData.company_details.global_configurations) {
        enrichedData.company_details.global_configurations = {};
    }
    
    if (!enrichedData.company_details.global_configurations.main_groups_definitions) {
        enrichedData.company_details.global_configurations.main_groups_definitions = [];
    }
    
    console.log(chalk.green('   ✅ Data structure validated and prepared'));
}

/**
 * Pass 2: Enrich items with web data and generate abbreviations
 * @param {Object} enrichedData - The MDF data to enrich
 */
async function enrichItemsWithWebData(enrichedData) {
    let processedItems = 0;
    let totalItems = 0;
    
    // Count total items first
    for (const branch of enrichedData.company_details.branches) {
        if (branch.point_of_sale_devices) {
            for (const pos of branch.point_of_sale_devices) {
                if (pos.items_for_this_pos) {
                    totalItems += pos.items_for_this_pos.length;
                }
            }
        }
    }
    
    console.log(chalk.cyan(`   Processing ${totalItems} items...`));
    
    // Process each item
    for (const branch of enrichedData.company_details.branches) {
        if (branch.point_of_sale_devices) {
            for (const pos of branch.point_of_sale_devices) {
                if (pos.items_for_this_pos) {
                    for (const item of pos.items_for_this_pos) {
                        processedItems++;
                        
                        try {
                            console.log(chalk.gray(`   Processing item ${processedItems}/${totalItems}: ${item.display_names?.menu?.de || 'Unknown'}`));
                            
                            // Enrich with web data
                            await enrichItemWithWebData(item);
                            
                            // Generate receipt abbreviation
                            await generateReceiptAbbreviation(item);
                            
                            // Generate button abbreviation
                            await generateButtonAbbreviation(item);
                            
                            // Small delay to avoid rate limiting
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                        } catch (error) {
                            console.log(chalk.yellow(`   ⚠️  Warning: Failed to enrich item ${item.display_names?.menu?.de || 'Unknown'}: ${error.message}`));
                        }
                    }
                }
            }
        }
    }
    
    console.log(chalk.green(`   ✅ Processed ${processedItems} items`));
}

/**
 * Enrich a single item with web data
 * @param {Object} item - The item to enrich
 */
async function enrichItemWithWebData(item) {
    const itemName = item.display_names?.menu?.de || 'Unknown Item';
    
    try {
        // Create search query for the item
        const searchQuery = `Based on the dish "${itemName}", identify its cuisine type, typical ingredients, and meal type (appetizer, main course, dessert). Respond only with a JSON object containing keys: cuisine, ingredients, mealType.`;
        
        // Get LLM response using optimized query function
        const response = await invokeSimpleQuery(searchQuery);
        
        // Try to parse JSON response
        let enrichmentData;
        try {
            // Extract JSON from response text
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                enrichmentData = JSON.parse(jsonMatch[0]);
            } else {
                // Fallback: create structured data from text response
                enrichmentData = {
                    cuisine: 'Unknown',
                    ingredients: ['Unknown'],
                    mealType: 'Unknown'
                };
            }
        } catch (parseError) {
            console.log(chalk.yellow(`     Warning: Could not parse LLM response for ${itemName}`));
            enrichmentData = {
                cuisine: 'Unknown',
                ingredients: ['Unknown'],
                mealType: 'Unknown'
            };
        }
        
        // Initialize additional_item_attributes if not present
        if (!item.additional_item_attributes) {
            item.additional_item_attributes = {};
        }
        
        // Add enrichment data
        item.additional_item_attributes.ai_enrichment = {
            cuisine: enrichmentData.cuisine || 'Unknown',
            ingredients: Array.isArray(enrichmentData.ingredients) ? enrichmentData.ingredients : ['Unknown'],
            mealType: enrichmentData.mealType || 'Unknown',
            enriched_at: new Date().toISOString()
        };
        
    } catch (error) {
        console.log(chalk.yellow(`     Warning: Web enrichment failed for ${itemName}: ${error.message}`));
        
        // Add minimal enrichment data as fallback
        if (!item.additional_item_attributes) {
            item.additional_item_attributes = {};
        }
        item.additional_item_attributes.ai_enrichment = {
            cuisine: 'Unknown',
            ingredients: ['Unknown'],
            mealType: 'Unknown',
            enriched_at: new Date().toISOString(),
            error: error.message
        };
    }
}

/**
 * Generate receipt abbreviation for an item using intelligent prompt
 * @param {Object} item - The item to generate abbreviation for
 */
async function generateReceiptAbbreviation(item) {
    const itemName = item.display_names?.menu?.de || 'Unknown Item';
    
    try {
        const receiptQuery = RECEIPT_NAME_PROMPT_TEMPLATE.replace('{productName}', itemName);
        const response = await invokeSimpleQuery(receiptQuery);
        
        // Clean up the response
        let receiptText = response.trim();
        
        // Remove quotes if present
        receiptText = receiptText.replace(/^["']|["']$/g, '');
        
        // Ensure it's within the 42-character limit
        if (receiptText.length > 42) {
            receiptText = receiptText.substring(0, 42);
        }
        
        // Ensure we have display_names structure
        if (!item.display_names) {
            item.display_names = {};
        }
        
        // Update receipt name
        item.display_names.receipt = { de: receiptText };
        
    } catch (error) {
        console.log(chalk.yellow(`     Warning: Receipt abbreviation failed for ${itemName}: ${error.message}`));
        
        // Fallback: create simple abbreviation
        let fallbackAbbreviation = itemName;
        if (fallbackAbbreviation.length > 42) {
            fallbackAbbreviation = fallbackAbbreviation.substring(0, 42);
        }
        
        if (!item.display_names) {
            item.display_names = {};
        }
        item.display_names.receipt = { de: fallbackAbbreviation };
    }
}

/**
 * Generate button abbreviation for an item using intelligent prompt
 * @param {Object} item - The item to generate abbreviation for
 */
async function generateButtonAbbreviation(item) {
    const itemName = item.display_names?.menu?.de || 'Unknown Item';
    
    try {
        const buttonQuery = BUTTON_NAME_PROMPT_TEMPLATE.replace('{productName}', itemName);
        const response = await invokeSimpleQuery(buttonQuery);
        
        // Clean up the response
        let buttonText = response.trim();
        
        // Remove quotes if present
        buttonText = buttonText.replace(/^["']|["']$/g, '');
        
        // Handle literal \n in the response and convert to actual newline
        buttonText = buttonText.replace(/\\n/g, '\n');
        
        // Ensure we have exactly two lines
        const lines = buttonText.split('\n');
        let line1 = lines[0] || itemName.substring(0, 10);
        let line2 = lines[1] || '';
        
        // Truncate lines to 10 characters to ensure compliance
        line1 = line1.substring(0, 10).trim();
        line2 = line2.substring(0, 10).trim();
        
        const finalButtonText = line2 ? `${line1}\n${line2}` : line1;
        
        // Ensure we have display_names structure
        if (!item.display_names) {
            item.display_names = {};
        }
        
        // Update button name
        item.display_names.button = { de: finalButtonText };
        
    } catch (error) {
        console.log(chalk.yellow(`     Warning: Button abbreviation failed for ${itemName}: ${error.message}`));
        
        // Fallback: create simple button text
        let fallbackButton = itemName.substring(0, 10);
        
        if (!item.display_names) {
            item.display_names = {};
        }
        item.display_names.button = { de: fallbackButton };
    }
}

/**
 * Pass 3: Generate and assign main groups (Warengruppen)
 * @param {Object} enrichedData - The MDF data to process
 */
async function generateAndAssignMainGroups(enrichedData) {
    console.log(chalk.cyan('   Analyzing items to generate main groups...'));
    
    // Collect all enriched items for analysis
    const allItems = [];
    const allCategories = [];
    
    for (const branch of enrichedData.company_details.branches) {
        if (branch.point_of_sale_devices) {
            for (const pos of branch.point_of_sale_devices) {
                if (pos.items_for_this_pos) {
                    allItems.push(...pos.items_for_this_pos);
                }
                if (pos.categories_for_this_pos) {
                    allCategories.push(...pos.categories_for_this_pos);
                }
            }
        }
    }
    
    // Generate main groups based on all items
    const mainGroups = await generateMainGroups(allItems);
    
    // Update global configurations
    enrichedData.company_details.global_configurations.main_groups_definitions = mainGroups;
    
    // Assign categories to main groups
    await assignCategoriesToMainGroups(enrichedData, allCategories, allItems, mainGroups);
    
    console.log(chalk.green(`   ✅ Generated ${mainGroups.length} main groups and assigned categories`));
}

/**
 * Generate main groups based on item analysis
 * @param {Array} allItems - All items to analyze
 * @returns {Promise<Array>} - Array of main group definitions
 */
async function generateMainGroups(allItems) {
    try {
        // Create item analysis summary
        const itemSummary = allItems.map(item => ({
            name: item.display_names?.menu?.de || 'Unknown',
            cuisine: item.additional_item_attributes?.ai_enrichment?.cuisine || 'Unknown',
            mealType: item.additional_item_attributes?.ai_enrichment?.mealType || 'Unknown',
            ingredients: item.additional_item_attributes?.ai_enrichment?.ingredients || []
        }));
        
        const analysisQuery = `Analyze the following list of restaurant dishes and their attributes. Define a concise list of logical 'Main Groups' (Warengruppen) that cover all these items. The group names should be in German. Respond only with a JSON array of strings, like ["Vorspeisen", "Hauptgerichte", "Italienische Spezialitäten", "Getränke"].

Items to analyze:
${itemSummary.map(item => `- ${item.name} (${item.cuisine}, ${item.mealType})`).join('\n')}`;
        
        const response = await invokeSimpleQuery(analysisQuery);
        
        // Parse main groups from response
        let mainGroupNames;
        try {
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                mainGroupNames = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('No JSON array found in response');
            }
        } catch (parseError) {
            console.log(chalk.yellow('   Warning: Could not parse main groups, using defaults'));
            mainGroupNames = ['Vorspeisen', 'Hauptgerichte', 'Getränke', 'Desserts'];
        }
        
        // Convert to main group definitions
        const mainGroups = mainGroupNames.map((name, index) => ({
            main_group_unique_identifier: index + 1,
            main_group_names: { de: name }
        }));
        
        console.log(chalk.cyan(`   Generated main groups: ${mainGroupNames.join(', ')}`));
        return mainGroups;
        
    } catch (error) {
        console.log(chalk.yellow(`   Warning: Main groups generation failed: ${error.message}`));
        
        // Fallback main groups
        return [
            { main_group_unique_identifier: 1, main_group_names: { de: 'Vorspeisen' } },
            { main_group_unique_identifier: 2, main_group_names: { de: 'Hauptgerichte' } },
            { main_group_unique_identifier: 3, main_group_names: { de: 'Getränke' } },
            { main_group_unique_identifier: 4, main_group_names: { de: 'Desserts' } }
        ];
    }
}

/**
 * Assign categories to main groups
 * @param {Object} enrichedData - The MDF data
 * @param {Array} allCategories - All categories
 * @param {Array} allItems - All items
 * @param {Array} mainGroups - Available main groups
 */
async function assignCategoriesToMainGroups(enrichedData, allCategories, allItems, mainGroups) {
    console.log(chalk.cyan('   Assigning categories to main groups...'));
    
    const mainGroupNames = mainGroups.map(group => group.main_group_names.de);
    
    for (const category of allCategories) {
        try {
            // Find items in this category
            const categoryItems = allItems.filter(item => 
                item.linked_category_unique_identifier === category.category_unique_identifier
            );
            
            if (categoryItems.length === 0) {
                console.log(chalk.yellow(`   Warning: No items found for category ${category.category_names?.de || 'Unknown'}`));
                continue;
            }
            
            // Create item list for this category
            const itemNames = categoryItems.map(item => item.display_names?.menu?.de || 'Unknown');
            
            const assignmentQuery = `Given the main groups: ${JSON.stringify(mainGroupNames)}, which group is the best fit for a category that contains the following items: ${JSON.stringify(itemNames)}? Respond with only the single best-fit group name.`;
            
            const response = await invokeSimpleQuery(assignmentQuery);
            
            // Find matching main group
            const bestFitGroup = response.trim().replace(/['"]/g, '');
            const matchingGroup = mainGroups.find(group => 
                group.main_group_names.de === bestFitGroup
            );
            
            if (matchingGroup) {
                category.default_linked_main_group_unique_identifier = matchingGroup.main_group_unique_identifier;
                console.log(chalk.gray(`     Assigned "${category.category_names?.de}" to "${bestFitGroup}"`));
            } else {
                console.log(chalk.yellow(`     Warning: Could not find matching main group for "${bestFitGroup}"`));
                // Assign to first main group as fallback
                category.default_linked_main_group_unique_identifier = mainGroups[0].main_group_unique_identifier;
            }
            
        } catch (error) {
            console.log(chalk.yellow(`     Warning: Assignment failed for category ${category.category_names?.de}: ${error.message}`));
            // Assign to first main group as fallback
            category.default_linked_main_group_unique_identifier = mainGroups[0].main_group_unique_identifier;
        }
    }
}

/**
 * Pass 4: Finalize enrichment with validation and cleanup
 * @param {Object} enrichedData - The MDF data to finalize
 */
async function finalizeEnrichment(enrichedData) {
    // Update metadata to indicate enrichment
    if (!enrichedData.company_details.meta_information) {
        enrichedData.company_details.meta_information = {};
    }
    
    enrichedData.company_details.meta_information.enriched_at = new Date().toISOString();
    enrichedData.company_details.meta_information.enriched_by = 'eckasse-enrichment-service';
    
    // Add enrichment audit trail
    if (!enrichedData.company_details.meta_information.audit_trail) {
        enrichedData.company_details.meta_information.audit_trail = {};
    }
    
    if (!enrichedData.company_details.meta_information.audit_trail.change_log) {
        enrichedData.company_details.meta_information.audit_trail.change_log = [];
    }
    
    enrichedData.company_details.meta_information.audit_trail.change_log.push({
        timestamp: new Date().toISOString(),
        change_type: 'enrichment',
        description: 'Multi-pass AI enrichment applied',
        changed_by: 'eckasse-enrichment-service'
    });
    
    console.log(chalk.green('   ✅ Enrichment finalized and metadata updated'));
}

module.exports = {
    enrichMdfData
};

--- File: /packages/backend/src/services/export.service.js ---

/**
 * Export Service for OOP-POS-MDF Data Export
 * 
 * This service handles exporting the current database state back to 
 * oop-pos-mdf JSON format for backup, review, or re-import purposes.
 * 
 * Features:
 * - Full database export to oop-pos-mdf v2.0.0 format
 * - Hierarchical data reconstruction (companies → branches → pos_devices → categories → items)
 * - Export metadata with timestamps and version information
 * - Validation of exported data structure
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

const db = require('../db/knex');
const logger = require('../config/logger');
const crypto = require('crypto');
const { bufferToEmbedding } = require('./embedding.service');

/**
 * Export current database state to OOP-POS-MDF JSON format
 * @param {Object} options - Export options
 * @returns {Promise<Object>} - Complete oop-pos-mdf configuration
 */
async function exportToOopMdf(options = {}) {
  const startTime = Date.now();
  const includeEmbeddings = options.includeEmbeddings !== false; // Default to true
  
  logger.info('Starting OOP-POS-MDF export', { 
    timestamp: new Date().toISOString(),
    options,
    includeEmbeddings
  });

  try {
    // Step 1: Export companies with global configurations
    const companies = await exportCompanies();
    
    if (companies.length === 0) {
      throw new Error('No companies found in database - nothing to export');
    }

    // For now, export the first company (single-company system)
    const company = companies[0];
    
    // Step 2: Export all hierarchical data with optimized bulk queries
    const exportedData = await exportHierarchicalDataOptimized(company.id, includeEmbeddings);
    const branches = exportedData.branches;

    // Step 4: Build final oop-pos-mdf structure
    const exportedConfig = {
      "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
      company_details: {
        company_unique_identifier: company.id,
        company_full_name: company.company_full_name,
        
        // Parse and update meta information
        meta_information: {
          ...JSON.parse(company.meta_information || '{}'),
          export_timestamp: new Date().toISOString(),
          exported_by: "eckasse-cli-export-v2.0.0",
          export_version: "2.0.0"
        },
        
        // Parse global configurations
        global_configurations: JSON.parse(company.global_configurations || '{}'),
        
        // Add branches
        branches: branches
      }
    };

    const duration = Date.now() - startTime;
    
    logger.info('OOP-POS-MDF export completed', {
      duration,
      companies: companies.length,
      branches: branches.length,
      totalPosDevices: branches.reduce((sum, b) => sum + b.point_of_sale_devices.length, 0),
      totalCategories: branches.reduce((sum, b) => 
        sum + b.point_of_sale_devices.reduce((s, p) => s + p.categories_for_this_pos.length, 0), 0),
      totalItems: branches.reduce((sum, b) => 
        sum + b.point_of_sale_devices.reduce((s, p) => s + p.items_for_this_pos.length, 0), 0)
    });

    return {
      success: true,
      configuration: exportedConfig,
      metadata: {
        exportedAt: new Date().toISOString(),
        exportVersion: "2.0.0",
        duration,
        stats: {
          companies: companies.length,
          branches: branches.length,
          posDevices: branches.reduce((sum, b) => sum + b.point_of_sale_devices.length, 0),
          categories: branches.reduce((sum, b) => 
            sum + b.point_of_sale_devices.reduce((s, p) => s + p.categories_for_this_pos.length, 0), 0),
          items: branches.reduce((sum, b) => 
            sum + b.point_of_sale_devices.reduce((s, p) => s + p.items_for_this_pos.length, 0), 0)
        }
      }
    };

  } catch (error) {
    logger.error('OOP-POS-MDF export failed', { error: error.message, stack: error.stack });
    throw error;
  }
}

/**
 * Optimized hierarchical data export with bulk queries
 * @param {number} companyId - Company ID
 * @param {boolean} includeEmbeddings - Whether to include embeddings
 */
async function exportHierarchicalDataOptimized(companyId, includeEmbeddings = true) {
  const startTime = Date.now();
  
  // Step 1: Get all branches for this company
  const branches = await db('branches')
    .select('*')
    .where('company_id', companyId);
  
  if (branches.length === 0) {
    return { branches: [] };
  }
  
  const branchIds = branches.map(b => b.id);
  
  // Step 2: Get all POS devices for all branches in one query
  const posDevices = await db('pos_devices')
    .select('*')
    .whereIn('branch_id', branchIds);
  
  const posDeviceIds = posDevices.map(p => p.id);
  
  // Step 3: Get all categories for all POS devices in one query
  const categories = await db('categories')
    .select('*')
    .whereIn('pos_device_id', posDeviceIds);
  
  // Step 4: Get all items with optimized query (conditional embedding join)
  let itemsQuery = db('items')
    .leftJoin('categories', 'items.associated_category_unique_identifier', 'categories.id')
    .whereIn('items.pos_device_id', posDeviceIds);

  if (includeEmbeddings) {
    itemsQuery = itemsQuery
      .leftJoin('vec_items', 'items.id', 'vec_items.rowid')
      .select('items.*', 'categories.source_unique_identifier as category_source_id', 'vec_items.item_embedding as embedding_vector');
  } else {
    itemsQuery = itemsQuery
      .select('items.*', 'categories.source_unique_identifier as category_source_id');
  }

  const items = await itemsQuery;
  
  // Step 5: Create lookup maps for efficient grouping
  const posDevicesByBranch = new Map();
  const categoriesByPosDevice = new Map();
  const itemsByPosDevice = new Map();
  
  // Group POS devices by branch
  posDevices.forEach(device => {
    if (!posDevicesByBranch.has(device.branch_id)) {
      posDevicesByBranch.set(device.branch_id, []);
    }
    posDevicesByBranch.get(device.branch_id).push(device);
  });
  
  // Group categories by POS device
  categories.forEach(category => {
    if (!categoriesByPosDevice.has(category.pos_device_id)) {
      categoriesByPosDevice.set(category.pos_device_id, []);
    }
    categoriesByPosDevice.get(category.pos_device_id).push(category);
  });
  
  // Group items by POS device
  items.forEach(item => {
    if (!itemsByPosDevice.has(item.pos_device_id)) {
      itemsByPosDevice.set(item.pos_device_id, []);
    }
    itemsByPosDevice.get(item.pos_device_id).push(item);
  });
  
  // Step 6: Build hierarchical structure
  const processedBranches = branches.map(branch => {
    const branchPosDevices = posDevicesByBranch.get(branch.id) || [];
    
    const processedPosDevices = branchPosDevices.map(device => {
      const deviceCategories = categoriesByPosDevice.get(device.id) || [];
      const deviceItems = itemsByPosDevice.get(device.id) || [];
      
      return {
        pos_device_unique_identifier: device.id,
        pos_device_names: JSON.parse(device.pos_device_name || '{}'),
        pos_device_type: device.pos_device_type,
        pos_device_external_number: device.pos_device_external_number,
        pos_device_settings: JSON.parse(device.pos_device_settings || '{}'),
        categories_for_this_pos: processCategories(deviceCategories),
        items_for_this_pos: processItems(deviceItems, includeEmbeddings)
      };
    });
    
    return {
      branch_unique_identifier: branch.id,
      branch_names: JSON.parse(branch.branch_name || '{}'),
      branch_address: branch.branch_address,
      point_of_sale_devices: processedPosDevices
    };
  });
  
  const duration = Date.now() - startTime;
  logger.info('Optimized hierarchical export completed', {
    duration,
    branches: branches.length,
    posDevices: posDevices.length,
    categories: categories.length,
    items: items.length
  });
  
  return { branches: processedBranches };
}

/**
 * Process categories data in memory
 */
function processCategories(categories) {
  // Build mapping of internal IDs to source identifiers for parent lookup
  const categoryIdMap = new Map();
  categories.forEach(cat => {
    categoryIdMap.set(cat.id, cat.source_unique_identifier);
  });
  
  return categories.map(category => ({
    category_unique_identifier: parseInt(category.source_unique_identifier),
    category_names: JSON.parse(category.category_names || '{}'),
    category_type: category.category_type,
    parent_category_unique_identifier: category.parent_category_id ? 
      parseInt(categoryIdMap.get(category.parent_category_id)) : null,
    default_linked_main_group_unique_identifier: category.default_linked_main_group_unique_identifier,
    audit_trail: JSON.parse(category.audit_trail || '{}')
  }));
}

/**
 * Process items data in memory with conditional embedding handling
 */
function processItems(items, includeEmbeddings) {
  return items.map(item => {
    const exportedItem = {
      item_unique_identifier: parseInt(item.source_unique_identifier),
      associated_category_unique_identifier: parseInt(item.category_source_id),
      display_names: JSON.parse(item.display_names || '{}'),
      item_price_value: parseFloat(item.item_price_value),
      pricing_schedules: JSON.parse(item.pricing_schedules || '[]'),
      availability_schedule: JSON.parse(item.availability_schedule || '{}'),
      additional_item_attributes: JSON.parse(item.additional_item_attributes || '{}'),
      item_flags: JSON.parse(item.item_flags || '{}'),
      audit_trail: JSON.parse(item.audit_trail || '{}')
    };

    // Include embedding data if available and requested
    if (includeEmbeddings && item.embedding_vector) {
      // Reconstruct semantic string for hash validation
      const displayNames = JSON.parse(item.display_names || '{}');
      const additionalAttrs = JSON.parse(item.additional_item_attributes || '{}');
      const semanticString = [
        displayNames.de || displayNames.en || '',
        displayNames.en || '',
        additionalAttrs.description || '',
        additionalAttrs.ingredients || ''
      ].filter(Boolean).join(' ').trim();
      
      // Calculate hash of the semantic string
      const sourceHash = crypto.createHash('sha256').update(semanticString).digest('hex');
      
      exportedItem.embedding_data = {
        model: "gemini-embedding-exp-03-07",
        vector: bufferToEmbedding(item.embedding_vector),
        source_hash: sourceHash
      };
    }

    return exportedItem;
  });
}

/**
 * Export companies from database
 */
async function exportCompanies() {
  const companies = await db('companies').select('*');
  return companies;
}

// Legacy functions removed - using optimized exportHierarchicalDataOptimized instead

/**
 * Export with file naming that includes 'exp' suffix
 * @param {Object} options - Export options
 * @returns {Promise<Object>} - Export result with suggested filename
 */
async function exportToOopMdfWithFileName(options = {}) {
  const result = await exportToOopMdf(options);
  
  // Generate filename with 'exp' suffix
  const companyName = result.configuration.company_details.company_full_name || 'Company';
  const sanitizedName = companyName.replace(/[^a-zA-Z0-9]/g, '_');
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
  const filename = `${sanitizedName}_${timestamp}_exp.json`;
  
  return {
    ...result,
    suggestedFilename: filename
  };
}

module.exports = {
  exportToOopMdf,
  exportToOopMdfWithFileName
};

--- File: /packages/backend/src/services/import.service.js ---

/**
 * Import Service for OOP-POS-MDF Data with Integrated Vectorization
 * 
 * This service handles importing complete oop-pos-mdf JSON configurations
 * into the normalized SQLite database with real-time vector embedding generation.
 * 
 * Features:
 * - Atomic transaction-based import
 * - Hierarchical data insertion (companies -> branches -> pos_devices -> categories -> items)
 * - On-the-fly vector embedding generation for each item
 * - Automatic database cleanup before import
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

const db = require('../db/knex');
const { generateEmbedding, embeddingToBuffer } = require('./embedding.service');
const logger = require('../config/logger');
const crypto = require('crypto');

/**
 * Import a complete oop-pos-mdf JSON configuration into the database
 * @param {Object} jsonData - The parsed oop-pos-mdf JSON data
 * @param {Object} options - Import options
 * @returns {Promise<Object>} - Import result with statistics
 */
async function importFromOopMdf(jsonData, options = {}) {
  const startTime = Date.now();
  const stats = {
    companies: 0,
    branches: 0,
    posDevices: 0,
    categories: 0,
    items: 0,
    embeddings: 0,
    errors: []
  };

  logger.info('Starting OOP-POS-MDF import', { 
    companyName: jsonData.company_details?.company_full_name,
    timestamp: new Date().toISOString()
  });

  try {
    // Wrap entire operation in a transaction for atomicity
    const result = await db.transaction(async (trx) => {
      // Step 1: Clean existing data (respecting foreign key constraints)
      await cleanExistingData(trx);
      
      // Step 2: Import hierarchical data
      const importResult = await importHierarchicalData(trx, jsonData, stats);
      
      return importResult;
    });

    const duration = Date.now() - startTime;
    logger.info('OOP-POS-MDF import completed successfully', {
      duration: `${duration}ms`,
      stats,
      timestamp: new Date().toISOString()
    });

    return {
      success: true,
      stats,
      duration,
      message: 'Import completed successfully'
    };

  } catch (error) {
    const duration = Date.now() - startTime;
    logger.error('OOP-POS-MDF import failed', {
      error: error.message,
      stack: error.stack,
      duration: `${duration}ms`,
      stats,
      timestamp: new Date().toISOString()
    });

    throw new Error(`Import failed: ${error.message}`);
  }
}

/**
 * Clean existing data in correct order (child to parent)
 * @param {Object} trx - Knex transaction object
 */
async function cleanExistingData(trx) {
  logger.info('Cleaning existing data from database');
  
  // Delete in order: vec_items -> items -> categories -> pos_devices -> branches -> companies
  try {
    await trx.raw('DELETE FROM vec_items');
  } catch (error) {
    logger.warn('vec_items table not found, skipping cleanup');
  }
  await trx('items').del();
  await trx('categories').del();
  await trx('pos_devices').del();
  await trx('branches').del();
  await trx('companies').del();
  
  // Reset auto-increment sequences
  await trx.raw('UPDATE sqlite_sequence SET seq = 0 WHERE name IN (?, ?, ?, ?, ?)', 
    ['companies', 'branches', 'pos_devices', 'categories', 'items']);
  
  logger.info('Database cleanup completed');
}

/**
 * Import hierarchical data structure
 * @param {Object} trx - Knex transaction object
 * @param {Object} jsonData - The oop-pos-mdf JSON data
 * @param {Object} stats - Statistics object to update
 * @returns {Promise<Object>} - Import result
 */
async function importHierarchicalData(trx, jsonData, stats) {
  const companyDetails = jsonData.company_details;
  
  if (!companyDetails) {
    throw new Error('Invalid JSON: company_details is required');
  }

  // Step 1: Insert company
  logger.info('Importing company data', { 
    companyName: companyDetails.company_full_name 
  });
  
  const companyResult = await trx('companies').insert({
    company_full_name: companyDetails.company_full_name,
    meta_information: JSON.stringify(companyDetails.meta_information || {}),
    global_configurations: JSON.stringify(companyDetails.global_configurations || {})
  }).returning('id');
  
  const companyId = companyResult[0].id || companyResult[0];

  stats.companies++;

  // Step 2: Import branches
  if (!companyDetails.branches || !Array.isArray(companyDetails.branches)) {
    throw new Error('Invalid JSON: branches array is required');
  }

  for (const branch of companyDetails.branches) {
    logger.info('Importing branch data', { 
      branchName: branch.branch_names?.de || branch.branch_names?.en || 'Unknown Branch'
    });

    const branchResult = await trx('branches').insert({
      company_id: companyId,
      branch_name: JSON.stringify(branch.branch_names || {}),
      branch_address: branch.branch_address || ''
    }).returning('id');
    
    const branchId = branchResult[0].id || branchResult[0];

    stats.branches++;

    // Step 3: Import POS devices for this branch
    if (!branch.point_of_sale_devices || !Array.isArray(branch.point_of_sale_devices)) {
      logger.warn('No POS devices found for branch', { branchId });
      continue;
    }

    for (const posDevice of branch.point_of_sale_devices) {
      logger.info('Importing POS device data', { 
        posDeviceName: posDevice.pos_device_names?.de || posDevice.pos_device_names?.en || 'Unknown POS'
      });

      const posDeviceResult = await trx('pos_devices').insert({
        branch_id: branchId,
        pos_device_name: JSON.stringify(posDevice.pos_device_names || {}),
        pos_device_type: posDevice.pos_device_type || 'DESKTOP',
        pos_device_external_number: posDevice.pos_device_external_number || 1,
        pos_device_settings: JSON.stringify(posDevice.pos_device_settings || {})
      }).returning('id');
      
      const posDeviceId = posDeviceResult[0].id || posDeviceResult[0];

      stats.posDevices++;

      // Step 4: Import categories for this POS device
      const categoryIdMap = new Map(); // Map from JSON category_unique_identifier to DB id
      
      if (posDevice.categories_for_this_pos && Array.isArray(posDevice.categories_for_this_pos)) {
        for (const category of posDevice.categories_for_this_pos) {
          logger.debug('Importing category', { 
            categoryName: category.category_names?.de || category.category_names?.en || 'Unknown Category',
            categoryUniqueId: category.category_unique_identifier
          });

          const categoryResult = await trx('categories').insert({
            pos_device_id: posDeviceId,
            source_unique_identifier: String(category.category_unique_identifier),
            category_names: JSON.stringify(category.category_names || {}),
            category_type: category.category_type || 'food',
            parent_category_id: category.parent_category_unique_identifier || null,
            default_linked_main_group_unique_identifier: category.default_linked_main_group_unique_identifier || null,
            audit_trail: JSON.stringify(category.audit_trail || {})
          }).returning('id');
          
          const categoryId = categoryResult[0].id || categoryResult[0];

          // Store mapping for item linking
          categoryIdMap.set(category.category_unique_identifier, categoryId);
          stats.categories++;
        }
      }

      // Step 5: Import items with integrated vectorization
      if (posDevice.items_for_this_pos && Array.isArray(posDevice.items_for_this_pos)) {
        await importItemsWithVectorization(trx, posDevice.items_for_this_pos, posDeviceId, categoryIdMap, stats);
      }
    }
  }

  return {
    companyId,
    totalItems: stats.items,
    totalEmbeddings: stats.embeddings
  };
}

/**
 * Import items with integrated vectorization
 * @param {Object} trx - Knex transaction object
 * @param {Array} items - Items array from oop-pos-mdf
 * @param {number} posDeviceId - POS device ID
 * @param {Map} categoryIdMap - Map of category unique IDs to database IDs
 * @param {Object} stats - Statistics object to update
 */
async function importItemsWithVectorization(trx, items, posDeviceId, categoryIdMap, stats) {
  logger.info(`Processing ${items.length} items with vectorization for POS device ${posDeviceId}`);
  
  // Create reverse category lookup for semantic string construction
  const categoryNameMap = new Map();
  for (const [uniqueId, dbId] of categoryIdMap) {
    // Get category name from database
    const categoryRow = await trx('categories').where('id', dbId).first();
    if (categoryRow && categoryRow.category_names) {
      try {
        const categoryNames = JSON.parse(categoryRow.category_names);
        const categoryName = categoryNames.de || categoryNames.en || Object.values(categoryNames)[0] || 'Unknown Category';
        categoryNameMap.set(uniqueId, categoryName);
      } catch (error) {
        logger.warn('Failed to parse category names', { categoryId: dbId, error: error.message });
        categoryNameMap.set(uniqueId, 'Unknown Category');
      }
    }
  }
  
  for (const item of items) {
    const itemName = item.display_names?.menu?.de || item.display_names?.menu?.en || 'Unknown Item';
    
    logger.debug('Processing item with vectorization', { itemName });
    
    // Validate category reference
    const categoryId = categoryIdMap.get(item.associated_category_unique_identifier) || null;
    
    if (!categoryId) {
      logger.warn('Item has invalid category reference', {
        itemName,
        categoryUniqueId: item.associated_category_unique_identifier
      });
      stats.errors.push(`Item "${itemName}" has invalid category reference`);
      continue;
    }

    try {
      // Step 1: Insert item data into items table
      const itemResult = await trx('items').insert({
        pos_device_id: posDeviceId,
        source_unique_identifier: String(item.item_unique_identifier),
        associated_category_unique_identifier: categoryId,
        display_names: JSON.stringify(item.display_names || {}),
        item_price_value: item.item_price_value || 0,
        pricing_schedules: JSON.stringify(item.pricing_schedules || []),
        availability_schedule: JSON.stringify(item.availability_schedule || {}),
        additional_item_attributes: JSON.stringify(item.additional_item_attributes || {}),
        item_flags: JSON.stringify(item.item_flags || {}),
        audit_trail: JSON.stringify(item.audit_trail || {})
      }).returning('id');
      
      const itemId = itemResult[0].id || itemResult[0];

      stats.items++;

      // Step 2: Check for existing embedding data and validate
      let embedding = null;
      let embeddingBuffer = null;
      let skipApiCall = false;

      if (item.embedding_data && item.embedding_data.vector && item.embedding_data.source_hash) {
        // Reconstruct semantic string for hash validation
        const categoryName = categoryNameMap.get(item.associated_category_unique_identifier) || 'Unknown Category';
        const description = item.additional_item_attributes?.description || '';
        const ingredients = item.additional_item_attributes?.ingredients || '';
        
        const currentSemanticString = [
          item.display_names?.menu?.de || item.display_names?.menu?.en || '',
          item.display_names?.menu?.en || '',
          description,
          ingredients
        ].filter(Boolean).join(' ').trim();
        
        const currentHash = crypto.createHash('sha256').update(currentSemanticString).digest('hex');
        
        if (currentHash === item.embedding_data.source_hash) {
          // Hash matches - reuse existing embedding
          logger.debug('Reusing existing embedding (hash match)', { 
            itemId, 
            itemName,
            hash: currentHash.substring(0, 8) + '...'
          });
          
          embedding = item.embedding_data.vector;
          embeddingBuffer = embeddingToBuffer(embedding);
          skipApiCall = true;
          stats.embeddings++;
        } else {
          logger.warn('Embedding hash mismatch - text has changed, generating new embedding', {
            itemId,
            itemName,
            expectedHash: item.embedding_data.source_hash.substring(0, 8) + '...',
            currentHash: currentHash.substring(0, 8) + '...'
          });
        }
      }

      // Step 3: Generate new embedding if needed
      if (!skipApiCall) {
        const categoryName = categoryNameMap.get(item.associated_category_unique_identifier) || 'Unknown Category';
        const description = item.additional_item_attributes?.description || '';
        
        const semanticString = `Category: ${categoryName}. Product: ${itemName}. Description: ${description}`.trim();
        
        logger.debug('Generated semantic string for new embedding', { 
          itemId, 
          itemName, 
          semanticString: semanticString.substring(0, 100) + (semanticString.length > 100 ? '...' : '')
        });

        embedding = await generateEmbedding(semanticString);
        embeddingBuffer = embeddingToBuffer(embedding);
        stats.embeddings++;
      }

      // Step 4: Insert vector data into vec_items table
      // The rowid of vec_items must match the id from the items table
      try {
        await trx.raw(
          'INSERT INTO vec_items(rowid, item_embedding) VALUES (?, ?)',
          [itemId, embeddingBuffer]
        );
      } catch (error) {
        logger.warn('vec_items table not found, skipping embedding insertion');
      }
      
      logger.debug('Item import completed', { 
        itemId, 
        itemName
      });

    } catch (error) {
      logger.error('Failed to import item', {
        itemName,
        error: error.message,
        stack: error.stack
      });
      
      stats.errors.push(`Failed to import item "${itemName}": ${error.message}`);
      
      // Continue with next item rather than failing entire import
      continue;
    }
  }
  
  logger.info('Item vectorization completed', {
    posDeviceId,
    totalItems: items.length,
    successfulItems: stats.items,
    successfulEmbeddings: stats.embeddings,
    errors: stats.errors.length
  });
}

module.exports = {
  importFromOopMdf
};

--- File: /packages/backend/src/services/layout.service.js ---

const db = require('../db/knex');
const logger = require('../config/logger');

/**
 * Saves the current state of categories as a new layout version.
 * @param {string} name - The name for the new layout (e.g., "Summer Menu").
 * @param {Array} categories - The array of category objects to save.
 * @param {string} sourceType - The source of the layout ('AI_OPTIMIZED', 'ORIGINAL_MENU', etc.).
 */
async function saveLayout(name, categories, sourceType = 'USER_CREATED') {
  logger.info({ name, sourceType }, 'Saving new menu layout...');
  const layoutData = JSON.stringify(categories);
  const [newLayout] = await db('menu_layouts').insert({
    name,
    layout_data: layoutData,
    source_type: sourceType,
    is_active: false // New layouts are not active by default
  }).returning('*');
  return newLayout;
}

/**
 * Lists all available layout versions.
 */
async function listLayouts() {
  return await db('menu_layouts').select('id', 'name', 'created_at', 'is_active', 'source_type').orderBy('created_at', 'desc');
}

/**
 * Activates a specific layout version.
 * @param {number} layoutId - The ID of the layout to activate.
 */
async function activateLayout(layoutId) {
  return db.transaction(async (trx) => {
    // Deactivate all other layouts
    await trx('menu_layouts').update({ is_active: false });
    // Activate the selected one
    await trx('menu_layouts').where({ id: layoutId }).update({ is_active: true });
  });
}

/**
 * Gets the currently active layout.
 */
async function getActiveLayout() {
    const activeLayout = await db('menu_layouts').where({ is_active: true }).first();
    if (!activeLayout) {
        // Fallback to the most recent layout if none are active
        return db('menu_layouts').orderBy('created_at', 'desc').first();
    }
    return activeLayout;
}

module.exports = { saveLayout, listLayouts, activateLayout, getActiveLayout };

--- File: /packages/backend/src/services/llm.provider.js ---

// packages/backend/src/services/llm.provider.js
const { GoogleGenAI } = require('@google/genai');

if (!process.env.GEMINI_API_KEY) {
  console.error('❌ FATAL: GEMINI_API_KEY is not configured. The application cannot function.');
  throw new Error('GEMINI_API_KEY is missing from environment variables.');
}

const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

/**
 * A shared, singleton instance of the Google AI client.
 */
const geminiClient = genAI;

/**
 * A helper to get a specific model from the shared client.
 * @param {object} options - Model options like modelName.
 * @returns {import('@google/generative-ai').GenerativeModel}
 */
function getGeminiModel(options = {}) {
    const modelName = options.modelName || 'gemini-2.0-flash';
    return {
        modelName,
        generateContent: (content) => geminiClient.models.generateContent({
            model: modelName,
            contents: content
        })
    };
}

module.exports = {
  geminiClient,
  getGeminiModel
};

--- File: /packages/backend/src/services/llm.service.js ---

// File: /packages/backend/src/services/llm.service.js

const { Type } = require("@google/genai");
const { getGeminiModel } = require('./llm.provider');

const logger = require('../config/logger');
const knex = require('../db/knex');
const { handleGeminiError, createGeminiErrorLog } = require('../utils/geminiErrorHandler');
const { searchProducts } = require('./search.service');
const { generateSalesReport } = require('./reporting.service');
const { createProduct } = require('./product.service');


// Language detection utilities
const LANGUAGE_PATTERNS = {
    russian: /[а-яё]/i,
    german: /[äöüß]/i,
    english: /^[a-z\s.,!?'"\-()0-9]+$/i
};

const EXPLICIT_LANGUAGE_COMMANDS = {
    russian: /(?:отвечай|говори|переключись).*(?:на\s*русском|по-русски)/i,
    german: /(?:speak|reply|answer).*(?:in\s*german|auf\s*deutsch)|(?:sprich|antworte).*deutsch/i,
    english: /(?:speak|reply|answer).*(?:in\s*english|на\s*английском)/i
};

/**
 * Detect the primary language of a text
 * @param {string} text - The text to analyze
 * @returns {string} - Detected language code ('ru', 'de', 'en')
 */
function detectLanguage(text) {
    const cleanText = text.trim().toLowerCase();
    
    // Check for explicit language commands first
    for (const [lang, pattern] of Object.entries(EXPLICIT_LANGUAGE_COMMANDS)) {
        if (pattern.test(cleanText)) {
            return lang === 'russian' ? 'ru' : lang === 'german' ? 'de' : 'en';
        }
    }
    
    // Check for Russian (Cyrillic)
    if (LANGUAGE_PATTERNS.russian.test(text)) {
        return 'ru';
    }
    
    // Check for German (umlauts and ß)
    if (LANGUAGE_PATTERNS.german.test(text)) {
        return 'de';
    }
    
    // Default to English if no specific patterns found
    return 'en';
}

/**
 * Determine if a text is a short phrase (likely a product name)
 * @param {string} text - The text to analyze
 * @returns {boolean} - True if it's a short phrase
 */
function isShortPhrase(text) {
    const words = text.trim().split(/\s+/);
    return words.length <= 3;
}

/**
 * Check if user is explicitly requesting a language switch
 * @param {string} text - The text to analyze
 * @returns {string|null} - Language code if explicit command detected, null otherwise
 */
function detectExplicitLanguageCommand(text) {
    const cleanText = text.trim().toLowerCase();
    
    for (const [lang, pattern] of Object.entries(EXPLICIT_LANGUAGE_COMMANDS)) {
        if (pattern.test(cleanText)) {
            return lang === 'russian' ? 'ru' : lang === 'german' ? 'de' : 'en';
        }
    }
    
    return null;
}

/**
 * Get or initialize conversation language state
 * @param {Array} chatHistory - Current chat history
 * @returns {Object} - Language state object
 */
function getLanguageState(chatHistory) {
    // Check if language state exists in history metadata
    if (chatHistory && chatHistory.length > 0 && chatHistory[0]._languageState) {
        return chatHistory[0]._languageState;
    }
    
    // Default to Russian if no state found
    return { current_language: 'ru' };
}

/**
 * Update language state in chat history
 * @param {Array} chatHistory - Current chat history
 * @param {string} newLanguage - New language code
 * @returns {Array} - Updated chat history
 */
function updateLanguageState(chatHistory, newLanguage) {
    const updatedHistory = [...chatHistory];
    
    // Add language state to first message if history exists
    if (updatedHistory.length > 0) {
        updatedHistory[0]._languageState = { current_language: newLanguage };
    }
    
    return updatedHistory;
}

// Tool function declarations for native SDK
const findProductDeclaration = {
    name: "findProduct",
    description: "Searches for products in the database. Can filter results by dietary needs (vegetarian/vegan) and exclude specific allergens.",
    parameters: {
        type: Type.OBJECT,
        properties: {
            query: {
                type: Type.STRING,
                description: "The product name or general category to search for (e.g., 'pasta', 'salad', 'Tiramisu')."
            },
            excludeAllergens: {
                type: Type.ARRAY,
                description: "A list of allergens to exclude from the results, e.g., ['nuts', 'dairy'].",
                items: {
                    type: Type.STRING
                }
            },
            dietaryFilter: {
                type: Type.STRING,
                description: "Filter for specific dietary needs.",
                enum: ["vegetarian", "vegan"]
            }
        },
        required: ["query"]
    }
};

const createProductDeclaration = {
    name: "createProduct",
    description: "Use this tool to create a new product in the database. It requires a name, a price, and a category name. For example: 'Create a product named Latte for 3.50 in the Drinks category'.",
    parameters: {
        type: Type.OBJECT,
        properties: {
            name: {
                type: Type.STRING,
                description: "The name of the product"
            },
            price: {
                type: Type.NUMBER,
                description: "The price of the product"
            },
            category: {
                type: Type.STRING,
                description: "The category name for the product"
            },
            description: {
                type: Type.STRING,
                description: "Optional description of the product"
            }
        },
        required: ["name", "price", "category"]
    }
};

const getSalesReportDeclaration = {
    name: "getSalesReport",
    description: "Use this tool to get a sales report for a specific period. Supported periods are 'today', 'week', and 'month'. The data can also be grouped by 'category' or 'hour'. For example: 'show me the sales report for this week grouped by category'.",
    parameters: {
        type: Type.OBJECT,
        properties: {
            period: {
                type: Type.STRING,
                description: "Time period for the report",
                enum: ["today", "week", "month"]
            },
            groupBy: {
                type: Type.STRING,
                description: "How to group the report data",
                enum: ["category", "hour", "none"]
            }
        },
        required: ["period"]
    }
};

const toolsConfig = {
    functionDeclarations: [findProductDeclaration, createProductDeclaration, getSalesReportDeclaration]
};

// Tool function implementations
const toolFunctions = {
    findProduct: async (args) => {
        const productName = args.query;
        const filters = {
            excludeAllergens: args.excludeAllergens || [],
            dietaryFilter: args.dietaryFilter || null
        };
        logger.info({ tool: 'findProduct', input: productName, filters }, '🤖 Agent is using hybrid product search with filters...');
        try {
            const searchResult = await searchProducts(productName, filters);
            logger.info({ searchMetadata: searchResult.metadata }, `Search complete: ${searchResult.metadata?.searchMethod}`);
            return searchResult;
        } catch (error) {
            logger.error({ msg: "Error in findProduct tool (hybrid search)", error });
            return { 
                success: false, 
                message: "An error occurred during the search.",
                results: [],
                metadata: { error: error.message }
            };
        }
    },
    
    createProduct: async (args) => {
        logger.info({ tool: 'createProduct', input: args }, '🤖 Agent is calling the real product service...');
        try {
            const productData = {
                name: args.name,
                price: args.price,
                categoryName: args.category,
                description: args.description || `A new ${args.name}`
            };
            
            const result = await createProduct(productData, { type: 'ai_agent', model: 'gemini-2.5-flash' });
            return result;
        } catch (error) {
            logger.error({ tool: 'createProduct', error: error.message }, 'Error in createProduct tool');
            return {
                success: false,
                message: 'Error creating product: ' + error.message,
                error: error.message
            };
        }
    },
    
    getSalesReport: async (args) => {
        logger.info({ tool: 'getSalesReport', input: args }, '🤖 Agent is calling the real reporting service...');
        try {
            const period = args.period || 'today';
            const groupBy = args.groupBy || 'none';
            const report = await generateSalesReport({ period, groupBy });
            return report;
        } catch (error) {
            logger.error({ tool: 'getSalesReport', error: error.message }, 'Error in getSalesReport tool');
            return {
                success: false,
                message: 'Error generating sales report: ' + error.message,
                error: error.message
            };
        }
    }
};

/**
 * Get the default Gemini model configuration
 */
function getDefaultModelConfig() {
    return { name: "gemini-2.5-flash", temperature: 0.1 };
}

/**
 * Create system prompt for the conversation
 */
function createSystemPrompt(conversationLanguage = 'ru') {
    return `You are an AI assistant for the "ecKasse" POS system. Your primary role is to help users manage their store through natural language.

**General Guidelines:**
- **CRITICAL: ALWAYS use tools:** When a user asks about finding, searching, or looking for products, ALWAYS use the findProduct tool first. Never try to answer without checking the database. NEVER ask for clarification before searching - always search first with the user's exact query.
- **Tool Usage:** Use the provided tools to interact with the database. Always base your answers on the output of the tools. Do not make up information.
- **Product Search:** For ANY request that involves finding products (words like "найди", "find", "search", "ищи", "ищу", "покажи", "show"), immediately use the findProduct tool with the user's query.
- **Context:** Use the conversation history to understand follow-up questions (e.g., "what is its price?").
- **Clarity:** After using a tool, provide a clear response based on the tool's output.

**Advanced Language Handling Rules:**
1. **Primary Language:** Your current conversation language is "${conversationLanguage}". Always respond in this language unless instructed otherwise.
2. **Language Detection:** Analyze every user message to determine its language.
3. **Full Sentence Language Switch:** If the user writes a complete sentence (4+ words) in a different language, this indicates a conversation language change. Switch your responses to this new language.
4. **Short Phrases (Product Names):** If the user writes a short phrase (1-3 words) in a different language, treat it as a product name. Use the phrase for tool searches but respond in your current primary language.
5. **Explicit Language Commands:** If the user explicitly asks you to switch languages (e.g., "speak English", "отвечай на русском", "sprich Deutsch"), immediately switch to the requested language and confirm the switch.
6. **Context Preservation:** When switching languages, maintain the same helpful and professional tone.

**Language Examples:**
- User (RU): "Найди Bruschetta" → You MUST call findProduct tool with query "Bruschetta", then respond in Russian
- User (EN): "Could you please find the Eco Mug?" → You MUST call findProduct tool with query "Eco Mug", then switch to English and respond in English
- User (Any): "Please respond in German" → You switch to German and confirm: "Verstanden. Ich antworte jetzt auf Deutsch."

**Tool Usage Examples:**
- To find vegetarian pasta: findProduct({query: "pasta", dietaryFilter: "vegetarian"})
- To find a dessert with no nuts: findProduct({query: "dessert", excludeAllergens: ["nuts"]})
- To find a shrimp dish: findProduct({query: "shrimps"})

**MANDATORY Tool Usage Examples - You MUST follow these patterns:**
- User: "Найди Super Widget" → You MUST call: findProduct({"query": "Super Widget"})
- User: "ищи кружку" → You MUST call: findProduct({"query": "кружку"}) - NEVER ask for clarification, search immediately
- User: "Find coffee" → You MUST call: findProduct({"query": "coffee"})
- User: "Show me mugs" → You MUST call: findProduct({"query": "mugs"})

Your primary goal is to translate the user's request into the most effective tool call. If the user mentions dietary needs or allergies, you MUST use the corresponding filter parameters in the \`findProduct\` tool.

**Context Handling Examples:**
- Previous: "I found Eco Mug for 12.50€" → User: "how much does it cost?" → You: "Eco Mug costs 12.50€" (NO tool call needed)
- Previous: "Точное совпадение не найдено, но есть похожий товар: Premium Coffee Cup - 8.75€" → User: "сколько она стоит?" → You: "Premium Coffee Cup стоит 8.75€" (NO tool call needed)

**Search Result Interpretation Rules:**
When using the findProduct tool, interpret the response according to these rules:

1. **Exact or Close Match (success: true):** If the tool returns success: true and results array, inform the user that the product was found. State the name and price of the first item in the results array. If there are other close matches in the array, list them as alternatives.
   Example response: "Да, товар 'Eco Mug' найден. Его цена 12.50€. Также найден похожий товар: 'Super Widget'."

2. **No Exact Match with Suggestions (success: false with results):** If the tool returns success: false but with results array containing suggestions, politely inform the user that an exact match was not found and offer the product names from the results array as suggestions.
   Example response: "Товар 'чашка' не найден. Возможно, вы имели в виду: Eco Mug, Super Widget?"

3. **No Results (success: false with empty results):** If the findProduct tool returns success: false AND results array is empty, you MUST respond with EXACTLY this text and nothing else: "К сожалению, товар по вашему запросу не найден."

4. **Context Rule:** If the user asks a follow-up question like "what is its price?" or "how much?" or "сколько она стоит?", you MUST refer to the previous conversation to identify which product they're asking about. Use the product name and price from your previous response to answer directly, without calling tools again.
   
   **Specific Context Scenario:** If the previous conversation included finding products (like "ищи кружку" followed by a product result), and the user asks "сколько она стоит?", extract the product name and price from your previous response and state: "[Product Name] стоит [Price]€."

5. **Response Language:** Always formulate your response in your current primary language (${conversationLanguage}), unless the language handling rules above indicate a switch.`;
}

async function sendMessage(userMessage, chatHistory = []) {
    // Enhanced logging for debugging
    console.log(`[AGENT_INPUT] User Message: "${userMessage}"`);
    console.log(`[AGENT_INPUT] Chat History Length: ${chatHistory.length}`);
    
    logger.info({ msg: 'Message received by native Gemini service', message: userMessage });
    
    // Get current language state from conversation
    const languageState = getLanguageState(chatHistory);
    let currentLanguage = languageState.current_language;
    
    // Detect language of the current user message
    const detectedLanguage = detectLanguage(userMessage);
    logger.info({ msg: 'Language analysis', currentLanguage, detectedLanguage, isShortPhrase: isShortPhrase(userMessage) });
    
    // Check for explicit language switch command
    const explicitLanguageCommand = detectExplicitLanguageCommand(userMessage);
    
    // Determine if we should switch conversation language
    let shouldSwitchLanguage = false;
    let newLanguage = currentLanguage;
    
    if (explicitLanguageCommand) {
        // User explicitly requested a language switch
        shouldSwitchLanguage = true;
        newLanguage = explicitLanguageCommand;
        logger.info({ msg: 'Explicit language command detected', newLanguage });
    } else if (detectedLanguage !== currentLanguage) {
        // User message is in a different language
        if (isShortPhrase(userMessage)) {
            // Short phrase - likely a product name, keep current language
            logger.info({ msg: 'Short phrase detected, keeping current language', currentLanguage });
        } else {
            // Full sentence - switch conversation language
            shouldSwitchLanguage = true;
            newLanguage = detectedLanguage;
            logger.info({ msg: 'Full sentence in new language detected, switching', newLanguage });
        }
    }
    
    // Update chat history with new language state if needed
    let updatedChatHistory = chatHistory;
    if (shouldSwitchLanguage) {
        updatedChatHistory = updateLanguageState(chatHistory, newLanguage);
        currentLanguage = newLanguage;
    }
    
    // Convert chat history to native SDK format
    const history = updatedChatHistory.filter(msg => !msg._languageState).map(msg => {
        const content = Array.isArray(msg.parts) ? msg.parts.map(p => p.text).join('') : msg.parts;
        return {
            role: msg.role === 'user' ? 'user' : 'model',
            parts: [{ text: content }]
        };
    });
    
    const modelConfig = getDefaultModelConfig();
    const modelName = modelConfig.name;
    logger.info({ msg: `Using model ${modelName}`, conversationLanguage: currentLanguage });
    
    try {
            // Enhanced logging for first Gemini call
            const systemPrompt = createSystemPrompt(currentLanguage);
            console.log(`[GEMINI_CALL_1] System Prompt: "${systemPrompt}"`);
            console.log(`[GEMINI_CALL_1] Sending request to model...`);
            
            // Use the native SDK generateContent API
            const model = getGeminiModel({ modelName });
            let result = await model.generateContent({
                model: modelName,
                systemInstruction: createSystemPrompt(currentLanguage),
                contents: [
                    ...history,
                    { role: 'user', parts: [{ text: userMessage }] }
                ],
                config: {
                    tools: [toolsConfig],
                    generationConfig: {
                        temperature: modelConfig.temperature
                    }
                }
            });
            
            // The result structure has candidates array, not a response property
            if (!result.candidates || result.candidates.length === 0) {
                throw new Error('No candidates in response');
            }
            
            const candidate = result.candidates[0];
            let content = candidate.content;
            
            // Enhanced logging for response analysis
            const functionCalls = content.parts && content.parts.some(part => part.functionCall) 
                ? content.parts.filter(part => part.functionCall).map(part => part.functionCall)
                : [];
            console.log('[GEMINI_RESPONSE_1] Raw model response received.');
            console.log(`[GEMINI_RESPONSE_1] Parsed Function Calls: ${JSON.stringify(functionCalls, null, 2)}`);
            
            // Check for function calls and handle tool execution loop
            if (content.parts && content.parts.some(part => part.functionCall)) {
                const functionCallParts = content.parts.filter(part => part.functionCall);
                logger.info({ msg: 'Function calls detected', count: functionCallParts.length, functions: functionCallParts.map(fc => fc.functionCall.name) });
                
                const functionResponseParts = [];
                
                // Execute all function calls
                for (const part of functionCallParts) {
                    const functionCall = part.functionCall;
                    const functionName = functionCall.name;
                    const functionArgs = functionCall.args;
                    
                    // Enhanced logging for tool execution
                    console.log(`[TOOL_EXEC] Attempting to execute tool: "${functionName}"`);
                    console.log(`[TOOL_EXEC] Arguments: ${JSON.stringify(functionArgs, null, 2)}`);
                    
                    logger.info({ msg: `Executing function: ${functionName}`, args: functionArgs });
                    
                    if (toolFunctions[functionName]) {
                        try {
                            const functionResult = await toolFunctions[functionName](functionArgs);
                            
                            // Enhanced logging for tool result
                            console.log(`[TOOL_RESULT] Raw result from tool "${functionName}": ${JSON.stringify(functionResult, null, 2)}`);
                            
                            functionResponseParts.push({
                                functionResponse: {
                                    name: functionName,
                                    response: functionResult
                                }
                            });
                        } catch (error) {
                            logger.error({ msg: `Error executing function ${functionName}`, error: error.message });
                            functionResponseParts.push({
                                functionResponse: {
                                    name: functionName,
                                    response: { error: `Error executing ${functionName}: ${error.message}` }
                                }
                            });
                        }
                    } else {
                        logger.error({ msg: `Unknown function: ${functionName}` });
                        functionResponseParts.push({
                            functionResponse: {
                                name: functionName,
                                response: { error: `Unknown function: ${functionName}` }
                            }
                        });
                    }
                }
                
                // Enhanced logging for second Gemini call
                console.log('[GEMINI_CALL_2] Sending tool results back to model for final response.');
                
                // Send function responses back to the model
                result = await model.generateContent({
                    model: modelName,
                    systemInstruction: createSystemPrompt(currentLanguage),
                    contents: [
                        ...history,
                        { role: 'user', parts: [{ text: userMessage }] },
                        { role: 'model', parts: content.parts },
                        { role: 'user', parts: functionResponseParts }
                    ],
                    config: {
                        tools: [toolsConfig],
                        generationConfig: {
                            temperature: modelConfig.temperature
                        }
                    }
                });
                
                if (!result.candidates || result.candidates.length === 0) {
                    throw new Error('No candidates in function response');
                }
                content = result.candidates[0].content;
            }
            
            // Extract text from content parts
            const responseText = content.parts
                .filter(part => part.text)
                .map(part => part.text)
                .join('');
            
            // Enhanced logging for final output
            console.log(`[AGENT_OUTPUT] "${responseText}"`);
            
            logger.info({ msg: `Model ${modelName} succeeded`, response_length: responseText.length });
            
            // Create new history with language state preserved
            const newHistory = [
                ...updatedChatHistory,
                { role: 'user', parts: [{ text: userMessage }] },
                { role: 'model', parts: [{ text: responseText }] },
            ];
            
            // Ensure language state is preserved in the new history
            if (newHistory.length > 0 && shouldSwitchLanguage) {
                newHistory[0]._languageState = { current_language: currentLanguage };
            }
            
            return { text: responseText, history: newHistory };
            
    } catch (error) {
        logger.error({ msg: `Model ${modelName} failed`, error: error.message });
        
        const geminiErrorInfo = handleGeminiError(error, { language: currentLanguage, includeRetryInfo: true });
        const errorLog = createGeminiErrorLog(error, {
            operation: 'llm_chat',
            userMessage: userMessage.substring(0, 100),
            chatHistoryLength: updatedChatHistory.length,
            lastModelAttempted: modelName
        });

        if (errorLog.level === 'warn') {
            logger.warn(errorLog);
        } else {
            logger.error(errorLog);
        }
        
        let responseText = geminiErrorInfo.userMessage;
        if (geminiErrorInfo.isTemporary && geminiErrorInfo.retryMessage) {
            responseText += ' ' + geminiErrorInfo.retryMessage;
        }
        
        return {
            text: responseText,
            history: updatedChatHistory,
            isTemporary: geminiErrorInfo.isTemporary,
            errorType: geminiErrorInfo.errorType
        };
    }
}

/**
 * Simple query function for programmatic LLM calls (like enrichment)
 * Uses lightweight prompt to reduce token usage
 */
async function invokeSimpleQuery(promptText) {
    try {
        const model = getGeminiModel({ modelName: 'gemini-2.5-flash' });
        const result = await model.generateContent({
            systemInstruction: "You are a helpful assistant that responds accurately and concisely. If the user asks for JSON, provide only the valid JSON object and nothing else.",
            generationConfig: {
                temperature: 0.1
            },
            contents: [{ role: 'user', parts: [{ text: promptText }] }]
        });
        
        if (!result.candidates || result.candidates.length === 0) {
            throw new Error('No candidates in response');
        }
        
        const content = result.candidates[0].content;
        return content.parts
            .filter(part => part.text)
            .map(part => part.text)
            .join('');
    } catch (error) {
        console.error('Error in invokeSimpleQuery:', error);
        return JSON.stringify({ error: `Failed to process simple query: ${error.message}` });
    }
}

module.exports = { sendMessage, invokeSimpleQuery };

--- File: /packages/backend/src/services/logging.service.js ---

const db = require('../db/knex');
const logger = require('../config/logger');
const crypto = require('crypto');

/**
 * LoggingService provides a centralized interface for all logging activities:
 * 1. Fiscal Log (TSE-signed, internal hash chain)
 * 2. Operational Log (user/system actions, internal hash chain)
 * 3. System Log (debugging, performance)
 */
class LoggingService {

  /**
   * Logs a fiscal event, ensuring atomicity and dual integrity (TSE + internal hash chain).
   * @param {string} event_type The type of event (e.g., 'finishTransaction').
   * @param {number} user_id The ID of the user performing the action.
   * @param {object} payload_for_tse The data to be sent to the TSE.
   * @returns {Promise<{success: boolean, log?: object, error?: string}>}
   */
  async logFiscalEvent(event_type, user_id, payload_for_tse) {
    const operation_id = crypto.randomUUID();
    let pendingOperationId;

    try {
      // Step 1: Create 'PENDING' record in the write-ahead log.
      const [pendingOp] = await db('pending_fiscal_operations').insert({
        operation_id,
        status: 'PENDING',
        payload_for_tse: JSON.stringify(payload_for_tse)
      }).returning('id');
      pendingOperationId = pendingOp.id || pendingOp;

      // Step 2: Simulate the call to the external TSE API.
      const tse_response = await this.simulateTseSign(payload_for_tse);
      if (!tse_response.success) {
        throw new Error(tse_response.error);
      }

      // Step 3: Update the pending record to 'TSE_SUCCESS'.
      await db('pending_fiscal_operations')
        .where('id', pendingOperationId)
        .update({
          status: 'TSE_SUCCESS',
          tse_response: JSON.stringify(tse_response.data)
        });

      // Step 4-8: Commit the successful operation to the final fiscal log.
      return await this.commitFiscalOperation(pendingOperationId, event_type, user_id);

    } catch (error) {
      logger.error({
        msg: 'Fiscal event logging failed.',
        operation_id,
        error: error.message,
      });

      if (pendingOperationId) {
        await db('pending_fiscal_operations')
          .where('id', pendingOperationId)
          .update({
            status: 'TSE_FAILED',
            last_error: error.message
          });
      }
      return { success: false, error: error.message };
    }
  }

  /**
   * Commits a TSE-successful operation from the pending log to the final fiscal_log.
   * This function is idempotent and can be called by the recovery process.
   * @param {number} pendingOpId The ID of the record in the pending_fiscal_operations table.
   * @param {string} event_type The type of event being logged.
   * @param {number} user_id The ID of the user performing the action.
   */
  async commitFiscalOperation(pendingOpId, event_type, user_id) {
    return await db.transaction(async (trx) => {
      const operation = await trx('pending_fiscal_operations').where('id', pendingOpId).first();

      if (!operation) throw new Error(`Pending operation with ID ${pendingOpId} not found.`);
      if (operation.status === 'COMMITTED') {
        logger.warn({ msg: 'Attempted to re-commit an already committed fiscal operation.', operation_id: operation.operation_id });
        return { success: true, message: 'Operation already committed.' };
      }
      if (operation.status !== 'TSE_SUCCESS') throw new Error(`Cannot commit operation with status '${operation.status}'.`);

      const lastLog = await trx('fiscal_log').orderBy('id', 'desc').first();
      const previous_log_hash = lastLog ? lastLog.current_log_hash : '0'.repeat(64);

      const tseResponseData = JSON.parse(operation.tse_response);
      const newLogEntry = {
        log_id: operation.operation_id,
        timestamp_utc: new Date().toISOString(),
        event_type,
        user_id,
        transaction_number_tse: tseResponseData.transaction_number,
        payload_for_tse: operation.payload_for_tse,
        tse_response: operation.tse_response,
        previous_log_hash
      };
      
      const canonicalString = `${newLogEntry.log_id}${newLogEntry.timestamp_utc}${newLogEntry.event_type}${newLogEntry.transaction_number_tse}${newLogEntry.payload_for_tse}${newLogEntry.previous_log_hash}`;
      const current_log_hash = crypto.createHash('sha256').update(canonicalString).digest('hex');

      const [insertedLog] = await trx('fiscal_log').insert({ ...newLogEntry, current_log_hash }).returning('*');

      await trx('pending_fiscal_operations').where('id', pendingOpId).update({ status: 'COMMITTED' });

      logger.info({ msg: 'Fiscal event committed successfully.', log_id: insertedLog.log_id });
      return { success: true, log: insertedLog };
    });
  }

  /**
   * Logs an operational event with an internal hash chain for integrity.
   */
  async logOperationalEvent(event_type, user_id, details = {}) {
    try {
      return await db.transaction(async (trx) => {
        const lastLog = await trx('operational_log').orderBy('id', 'desc').first();
        const previous_log_hash = lastLog ? lastLog.current_log_hash : '0'.repeat(64);

        const newLogEntry = {
          log_id: crypto.randomUUID(),
          timestamp_utc: new Date().toISOString(),
          event_type,
          user_id,
          details: JSON.stringify(details),
          previous_log_hash
        };

        const canonicalString = `${newLogEntry.log_id}${newLogEntry.timestamp_utc}${newLogEntry.event_type}${newLogEntry.user_id}${newLogEntry.details}${newLogEntry.previous_log_hash}`;
        const current_log_hash = crypto.createHash('sha256').update(canonicalString).digest('hex');

        const [insertedLog] = await trx('operational_log').insert({ ...newLogEntry, current_log_hash }).returning('*');

        logger.info({ msg: 'Operational event logged successfully', event_type, log_id: insertedLog.log_id });
        return { success: true, log: insertedLog };
      });
    } catch (error) {
      logger.error({ msg: 'CRITICAL: Failed to write to operational_log table.', db_error: error.message, original_log: { event_type, user_id, details } });
      return { success: false, error: error.message };
    }
  }

  /**
   * Logs a system/debug event.
   */
  async logSystemEvent(level, message, context = {}) {
    try {
      await db('system_log').insert({
        timestamp: new Date(),
        level: level,
        message: message,
        context: JSON.stringify(context)
      });
      return { success: true };
    } catch (error) {
      logger.error({ msg: 'CRITICAL: Failed to write to system_log table.', db_error: error.message, original_log: { level, message, context } });
      return { success: false, error: error.message };
    }
  }

  /**
   * Simulates a call to a TSE provider.
   * @returns {Promise<object>} A simulated successful TSE response.
   */
  async simulateTseSign(payload) {
    await new Promise(resolve => setTimeout(resolve, 20)); // Simulate network latency
    return {
      success: true,
      data: {
        transaction_number: Math.floor(Date.now() / 1000) - 1700000000 + Math.floor(Math.random() * 100),
        signature_counter: Math.floor(Math.random() * 100000),
        log_time: new Date().toISOString(),
        signature: crypto.createHash('sha256').update(JSON.stringify(payload)).digest('base64'),
        tse_serial_number: 'mock-tse-serial-12345'
      }
    };
  }
}

// Export a singleton instance of the service
module.exports = new LoggingService();

--- File: /packages/backend/src/services/manager.service.js ---

// Manager service for handling pending changes and approvals
const crypto = require('crypto');
const db = require('../db/knex');
const logger = require('../config/logger');

/**
 * ManagerService handles all manager-specific operations including
 * approving/rejecting pending changes, managing users, and oversight functions
 */
class ManagerService {

    /**
     * Get all pending changes for manager review
     * @param {string} sessionId - Manager session ID
     * @param {string} filterType - Optional filter by change type
     * @returns {Object} List of pending changes
     */
    async getPendingChanges(sessionId, filterType = null) {
        logger.info({ 
            service: 'ManagerService', 
            function: 'getPendingChanges',
            sessionId,
            filterType
        }, 'Fetching pending changes for manager review');

        try {
            // Validate manager permissions
            const manager = await this.validateManagerPermissions(sessionId);
            if (!manager.success) {
                return manager; // Return error response
            }

            let query = db('pending_changes')
                .select([
                    'pending_changes.*',
                    'users.username as requested_by_username',
                    'users.full_name as requested_by_name',
                    'reviewer.username as reviewed_by_username',
                    'reviewer.full_name as reviewed_by_name'
                ])
                .join('users', 'pending_changes.requested_by_user_id', 'users.id')
                .leftJoin('users as reviewer', 'pending_changes.reviewed_by_user_id', 'reviewer.id')
                .where('pending_changes.status', 'pending')
                .orderBy('pending_changes.priority', 'desc')
                .orderBy('pending_changes.created_at', 'asc');

            if (filterType) {
                query = query.where('pending_changes.change_type', filterType);
            }

            const pendingChanges = await query;

            const formattedChanges = pendingChanges.map(change => ({
                id: change.change_id,
                type: change.change_type,
                target: {
                    type: change.target_entity_type,
                    id: change.target_entity_id
                },
                original_data: JSON.parse(change.original_data || '{}'),
                proposed_data: JSON.parse(change.proposed_data || '{}'),
                reason: change.reason,
                priority: change.priority,
                status: change.status,
                requested_by: {
                    username: change.requested_by_username,
                    full_name: change.requested_by_name
                },
                requested_at: change.created_at,
                auto_apply_at: change.auto_apply_at,
                requires_admin_approval: change.requires_admin_approval
            }));

            logger.info({ 
                managerId: manager.user.id,
                pendingCount: formattedChanges.length,
                filterType
            }, 'Retrieved pending changes for manager');

            return {
                success: true,
                changes: formattedChanges,
                total: formattedChanges.length
            };

        } catch (error) {
            logger.error({ 
                service: 'ManagerService', 
                function: 'getPendingChanges',
                sessionId,
                error: error.message 
            }, 'Failed to get pending changes');
            
            return {
                success: false,
                error: error.message,
                changes: []
            };
        }
    }

    /**
     * Approve a pending change
     * @param {string} sessionId - Manager session ID
     * @param {string} changeId - Change ID to approve
     * @param {string} approvalNotes - Manager's approval notes
     * @returns {Object} Approval result
     */
    async approveChange(sessionId, changeId, approvalNotes = '') {
        logger.info({ 
            service: 'ManagerService', 
            function: 'approveChange',
            sessionId,
            changeId,
            approvalNotes
        }, 'Processing change approval');

        try {
            return await db.transaction(async (trx) => {
                // Validate manager permissions
                const manager = await this.validateManagerPermissions(sessionId, trx);
                if (!manager.success) {
                    return manager;
                }

                // Get the pending change
                const change = await trx('pending_changes')
                    .where('change_id', changeId)
                    .where('status', 'pending')
                    .first();

                if (!change) {
                    throw new Error('Pending change not found or already processed');
                }

                // Apply the change based on type
                const applicationResult = await this.applyChange(trx, change);
                if (!applicationResult.success) {
                    throw new Error(`Failed to apply change: ${applicationResult.error}`);
                }

                // Update the pending change record
                await trx('pending_changes')
                    .where('change_id', changeId)
                    .update({
                        status: 'approved',
                        reviewed_by_user_id: manager.user.id,
                        reviewed_at: new Date(),
                        review_notes: approvalNotes
                    });

                // Update trust score of requesting user
                await this.updateUserTrustScore(trx, change.requested_by_user_id, 2);

                logger.info({ 
                    managerId: manager.user.id,
                    changeId,
                    changeType: change.change_type,
                    requestedBy: change.requested_by_user_id
                }, 'Change approved and applied successfully');

                return {
                    success: true,
                    message: `Change ${change.change_type} approved and applied successfully`,
                    change: {
                        id: changeId,
                        type: change.change_type,
                        status: 'approved',
                        approved_by: manager.user.full_name,
                        approved_at: new Date().toISOString(),
                        application_result: applicationResult
                    }
                };
            });

        } catch (error) {
            logger.error({ 
                service: 'ManagerService', 
                function: 'approveChange',
                changeId,
                error: error.message 
            }, 'Change approval failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Reject a pending change
     * @param {string} sessionId - Manager session ID
     * @param {string} changeId - Change ID to reject
     * @param {string} rejectionReason - Reason for rejection
     * @returns {Object} Rejection result
     */
    async rejectChange(sessionId, changeId, rejectionReason = '') {
        logger.info({ 
            service: 'ManagerService', 
            function: 'rejectChange',
            sessionId,
            changeId,
            rejectionReason
        }, 'Processing change rejection');

        try {
            return await db.transaction(async (trx) => {
                // Validate manager permissions
                const manager = await this.validateManagerPermissions(sessionId, trx);
                if (!manager.success) {
                    return manager;
                }

                // Get the pending change
                const change = await trx('pending_changes')
                    .where('change_id', changeId)
                    .where('status', 'pending')
                    .first();

                if (!change) {
                    throw new Error('Pending change not found or already processed');
                }

                // Update the pending change record
                await trx('pending_changes')
                    .where('change_id', changeId)
                    .update({
                        status: 'rejected',
                        reviewed_by_user_id: manager.user.id,
                        reviewed_at: new Date(),
                        review_notes: rejectionReason
                    });

                // Slightly decrease trust score of requesting user
                await this.updateUserTrustScore(trx, change.requested_by_user_id, -1);

                logger.info({ 
                    managerId: manager.user.id,
                    changeId,
                    changeType: change.change_type,
                    requestedBy: change.requested_by_user_id,
                    reason: rejectionReason
                }, 'Change rejected by manager');

                return {
                    success: true,
                    message: `Change ${change.change_type} rejected`,
                    change: {
                        id: changeId,
                        type: change.change_type,
                        status: 'rejected',
                        rejected_by: manager.user.full_name,
                        rejected_at: new Date().toISOString(),
                        rejection_reason: rejectionReason
                    }
                };
            });

        } catch (error) {
            logger.error({ 
                service: 'ManagerService', 
                function: 'rejectChange',
                changeId,
                error: error.message 
            }, 'Change rejection failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Batch approve/reject multiple changes
     * @param {string} sessionId - Manager session ID
     * @param {Array} actions - Array of {changeId, action, notes}
     * @returns {Object} Batch operation result
     */
    async batchProcessChanges(sessionId, actions) {
        logger.info({ 
            service: 'ManagerService', 
            function: 'batchProcessChanges',
            sessionId,
            actionsCount: actions.length
        }, 'Processing batch change operations');

        try {
            const results = {
                successful: [],
                failed: []
            };

            for (const action of actions) {
                try {
                    let result;
                    if (action.action === 'approve') {
                        result = await this.approveChange(sessionId, action.changeId, action.notes);
                    } else if (action.action === 'reject') {
                        result = await this.rejectChange(sessionId, action.changeId, action.notes);
                    } else {
                        throw new Error(`Invalid action: ${action.action}`);
                    }

                    if (result.success) {
                        results.successful.push({
                            changeId: action.changeId,
                            action: action.action,
                            result: result
                        });
                    } else {
                        results.failed.push({
                            changeId: action.changeId,
                            action: action.action,
                            error: result.error
                        });
                    }
                } catch (error) {
                    results.failed.push({
                        changeId: action.changeId,
                        action: action.action,
                        error: error.message
                    });
                }
            }

            logger.info({ 
                sessionId,
                successful: results.successful.length,
                failed: results.failed.length
            }, 'Batch change processing completed');

            return {
                success: true,
                results: results,
                summary: {
                    total: actions.length,
                    successful: results.successful.length,
                    failed: results.failed.length
                }
            };

        } catch (error) {
            logger.error({ 
                service: 'ManagerService', 
                function: 'batchProcessChanges',
                sessionId,
                error: error.message 
            }, 'Batch change processing failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Get manager dashboard statistics
     * @param {string} sessionId - Manager session ID
     * @returns {Object} Dashboard statistics
     */
    async getDashboardStats(sessionId) {
        try {
            const manager = await this.validateManagerPermissions(sessionId);
            if (!manager.success) {
                return manager;
            }

            const stats = await db.transaction(async (trx) => {
                // Pending changes by type
                const pendingChanges = await trx('pending_changes')
                    .select('change_type')
                    .count('* as count')
                    .where('status', 'pending')
                    .groupBy('change_type');

                // Pending stornos
                const pendingStornos = await trx('storno_log')
                    .count('* as count')
                    .where('approval_status', 'pending')
                    .first();

                // Today's approved changes
                const todayApproved = await trx('pending_changes')
                    .count('* as count')
                    .where('status', 'approved')
                    .where('reviewed_at', '>=', new Date().toISOString().split('T')[0])
                    .first();

                // Users with low trust scores (< 30)
                const lowTrustUsers = await trx('users')
                    .count('* as count')
                    .where('trust_score', '<', 30)
                    .where('is_active', true)
                    .first();

                // High priority pending changes
                const urgentChanges = await trx('pending_changes')
                    .count('* as count')
                    .where('status', 'pending')
                    .whereIn('priority', ['high', 'urgent'])
                    .first();

                return {
                    pending_changes: {
                        total: pendingChanges.reduce((sum, item) => sum + item.count, 0),
                        by_type: pendingChanges.reduce((obj, item) => {
                            obj[item.change_type] = item.count;
                            return obj;
                        }, {})
                    },
                    pending_stornos: parseInt(pendingStornos.count),
                    today_approved: parseInt(todayApproved.count),
                    low_trust_users: parseInt(lowTrustUsers.count),
                    urgent_changes: parseInt(urgentChanges.count)
                };
            });

            return {
                success: true,
                stats: stats
            };

        } catch (error) {
            logger.error({ 
                service: 'ManagerService', 
                function: 'getDashboardStats',
                sessionId,
                error: error.message 
            }, 'Failed to get dashboard stats');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Apply a change based on its type
     * @param {Object} trx - Database transaction
     * @param {Object} change - Change object from pending_changes table
     * @returns {Object} Application result
     */
    async applyChange(trx, change) {
        const proposedData = JSON.parse(change.proposed_data);
        
        try {
            switch (change.change_type) {
                case 'product_update':
                    return await this.applyProductUpdate(trx, change.target_entity_id, proposedData);
                
                case 'product_create':
                    return await this.applyProductCreate(trx, proposedData);
                
                case 'price_change':
                    return await this.applyPriceChange(trx, change.target_entity_id, proposedData);
                
                case 'category_create':
                    return await this.applyCategoryCreate(trx, proposedData);
                
                case 'category_update':
                    return await this.applyCategoryUpdate(trx, change.target_entity_id, proposedData);
                
                default:
                    throw new Error(`Unsupported change type: ${change.change_type}`);
            }
        } catch (error) {
            logger.error({ 
                changeId: change.change_id,
                changeType: change.change_type,
                error: error.message 
            }, 'Failed to apply change');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Apply product update
     * @param {Object} trx - Database transaction
     * @param {number} productId - Product ID to update
     * @param {Object} proposedData - New product data
     * @returns {Object} Update result
     */
    async applyProductUpdate(trx, productId, proposedData) {
        const updateData = {};
        
        if (proposedData.name) {
            updateData.display_names = JSON.stringify({
                menu: { de: proposedData.name },
                button: { de: proposedData.name },
                receipt: { de: proposedData.name }
            });
        }
        
        if (proposedData.price !== undefined) {
            updateData.item_price_value = proposedData.price;
        }
        
        if (proposedData.category_id) {
            updateData.associated_category_unique_identifier = proposedData.category_id;
        }

        // Update audit trail
        updateData.audit_trail = JSON.stringify({
            last_modified_at: new Date().toISOString(),
            last_modified_by: 'manager_approval',
            version: new Date().getTime(),
            change_log: [{
                timestamp: new Date().toISOString(),
                action: 'manager_approved_update',
                changes: proposedData
            }]
        });

        await trx('items').where('id', productId).update(updateData);

        return {
            success: true,
            message: 'Product updated successfully',
            applied_changes: proposedData
        };
    }

    /**
     * Apply price change
     * @param {Object} trx - Database transaction
     * @param {number} productId - Product ID
     * @param {Object} proposedData - Price change data
     * @returns {Object} Update result
     */
    async applyPriceChange(trx, productId, proposedData) {
        await trx('items')
            .where('id', productId)
            .update({
                item_price_value: proposedData.new_price,
                audit_trail: JSON.stringify({
                    last_modified_at: new Date().toISOString(),
                    last_modified_by: 'manager_approval',
                    version: new Date().getTime(),
                    change_log: [{
                        timestamp: new Date().toISOString(),
                        action: 'price_change_approved',
                        old_price: proposedData.old_price,
                        new_price: proposedData.new_price,
                        reason: proposedData.reason
                    }]
                })
            });

        return {
            success: true,
            message: `Price updated from €${proposedData.old_price} to €${proposedData.new_price}`,
            applied_changes: proposedData
        };
    }

    /**
     * Validate manager permissions
     * @param {string} sessionId - Session ID
     * @param {Object} trx - Optional database transaction
     * @returns {Object} Validation result with user data
     */
    async validateManagerPermissions(sessionId, trx = db) {
        const session = await trx('user_sessions')
            .select([
                'user_sessions.*',
                'users.*',
                'roles.role_name',
                'roles.permissions',
                'roles.can_approve_changes',
                'roles.can_manage_users'
            ])
            .join('users', 'user_sessions.user_id', 'users.id')
            .join('roles', 'users.role_id', 'roles.id')
            .where('user_sessions.session_id', sessionId)
            .where('user_sessions.is_active', true)
            .where('user_sessions.expires_at', '>', new Date())
            .where('users.is_active', true)
            .first();

        if (!session) {
            return {
                success: false,
                error: 'Invalid session or user not found'
            };
        }

        if (!session.can_approve_changes) {
            return {
                success: false,
                error: 'Insufficient permissions - manager role required'
            };
        }

        return {
            success: true,
            user: {
                id: session.user_id,
                username: session.username,
                full_name: session.full_name,
                role_name: session.role_name,
                permissions: JSON.parse(session.permissions),
                can_approve_changes: session.can_approve_changes,
                can_manage_users: session.can_manage_users
            }
        };
    }

    /**
     * Update user trust score
     * @param {Object} trx - Database transaction
     * @param {number} userId - User ID
     * @param {number} change - Change amount
     */
    async updateUserTrustScore(trx, userId, change) {
        const user = await trx('users').where('id', userId).first();
        if (!user) return;

        const newScore = Math.max(0, Math.min(100, user.trust_score + change));
        await trx('users').where('id', userId).update({ trust_score: newScore });

        logger.debug({ 
            userId,
            oldScore: user.trust_score,
            newScore,
            change
        }, 'User trust score updated');
    }
}

module.exports = new ManagerService();

--- File: /packages/backend/src/services/product.service.js ---

// Product management service with real database logic

const db = require('../db/knex');
const logger = require('../config/logger');
const { generateEmbedding, embeddingToBuffer } = require('./embedding.service');
const loggingService = require('./logging.service');

/**
 * Create a new product in the database
 * @param {Object} productData - Product details (name, price, categoryName, description)
 * @returns {Object} Created product data
 */
async function createProduct(productData, initiator = { type: 'system', id: null }) {
    const { name, price, categoryName, description } = productData;
    
    logger.info({ service: 'ProductService', function: 'createProduct', productData, initiator }, 'Creating new product...');

    try {
        return await db.transaction(async (trx) => {
            // Step 1: Find the category ID by searching for matching categoryName
            logger.info({ categoryName, type: typeof categoryName }, 'Looking up category');
            
            const category = await trx('categories')
                .whereRaw("JSON_EXTRACT(category_names, '$.de') = ?", [categoryName])
                .first();

            if (!category) {
                throw new Error(`Category '${categoryName}' not found. Available categories should be queried first.`);
            }

            logger.info({ categoryId: category.id, categoryName }, 'Found matching category');

            // Step 2: Get the pos_device_id from the category (we'll use the same one)
            const posDeviceId = category.pos_device_id;

            // Step 3: Generate a unique identifier for the new product
            const sourceUniqueIdentifier = `product_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Step 4: Prepare display names in the required JSON format
            const displayNames = JSON.stringify({
                menu: { de: name },
                button: { de: name },
                receipt: { de: name }
            });

            // Step 5: Prepare item flags and audit trail
            const itemFlags = JSON.stringify({
                is_sellable: true,
                has_negative_price: false
            });

            const auditTrail = JSON.stringify({
                created_at: new Date().toISOString(),
                created_by: initiator.type,
                initiator_id: initiator.id,
                version: 1
            });

            // Step 6: Insert the new item into the database
            const [newItemResult] = await trx('items').insert({
                pos_device_id: posDeviceId,
                source_unique_identifier: sourceUniqueIdentifier,
                associated_category_unique_identifier: category.id,
                display_names: displayNames,
                item_price_value: parseFloat(price),
                item_flags: itemFlags,
                audit_trail: auditTrail
            }).returning('id');

            // Extract the actual ID value (could be object or number depending on database)
            const newItemId = typeof newItemResult === 'object' ? newItemResult.id : newItemResult;
            logger.info({ newItemId }, 'Product inserted into items table');

            // Step 7: Generate and insert vector embedding
            const embeddingText = `Product: ${name}. Category: ${categoryName}. Description: ${description || name}. Price: ${price}`;
            
            logger.info({ embeddingText }, 'Generating embedding for new product');
            const embedding = await generateEmbedding(embeddingText);
            const embeddingBuffer = embeddingToBuffer(embedding);

            // Step 8: Insert the vector into vec_items table with the same rowid as the item ID
            await trx.raw(`
                INSERT INTO vec_items(rowid, item_embedding) 
                VALUES (?, ?)
            `, [newItemId, embeddingBuffer]);

            logger.info({ newItemId }, 'Vector embedding inserted into vec_items table');

            // Step 9: Create result data structure
            const createdProduct = {
                id: newItemId,
                name: name,
                price: parseFloat(price),
                categoryName: categoryName,
                categoryId: category.id,
                sourceUniqueIdentifier: sourceUniqueIdentifier,
                description: description || name,
                createdAt: new Date().toISOString()
            };

            // Step 10: Log fiscal event for master data change
            await loggingService.logFiscalEvent('master_data_change_create', initiator.id, {
                entity: 'product',
                product: createdProduct,
                initiator
            });

            const result = {
                success: true,
                data: createdProduct
            };

            logger.info({ service: 'ProductService', result }, 'Product created successfully');
            return result;
        });

    } catch (error) {
        logger.error({ service: 'ProductService', error: error.message, stack: error.stack }, 'Failed to create product');
        return {
            success: false,
            message: 'Error creating product: ' + error.message,
            error: error.message
        };
    }
}

/**
 * Legacy function name for backward compatibility
 * @param {Object} details - Product details
 * @returns {Object} Created product data
 */
async function createNewProduct(details) {
    // Map old parameter names to new function
    return await createProduct({
        name: details.name,
        price: details.price,
        categoryName: details.category,
        description: details.description
    }, { type: 'user', id: details.userId }); // Assume legacy calls are from users
}

/**
 * Update an existing product with permission checking
 * @param {Number} id - Product ID
 * @param {Object} updates - Updates to apply (name, price, categoryName, description)
 * @param {String} sessionId - User session ID for permission checking
 * @returns {Object} Updated product data or pending change creation result
 */
async function updateExistingProduct(id, updates, sessionId) {
    logger.info({ 
        service: 'ProductService', 
        function: 'updateExistingProduct', 
        productId: id, 
        updates,
        sessionId
    }, 'Processing product update request');

    try {
        return await db.transaction(async (trx) => {
            // Get current user session and permissions
            const userSession = await trx('user_sessions')
                .select([
                    'user_sessions.*',
                    'users.*',
                    'roles.role_name',
                    'roles.permissions',
                    'roles.can_approve_changes',
                    'roles.can_manage_users'
                ])
                .join('users', 'user_sessions.user_id', 'users.id')
                .join('roles', 'users.role_id', 'roles.id')
                .where('user_sessions.session_id', sessionId)
                .where('user_sessions.is_active', true)
                .where('user_sessions.expires_at', '>', new Date())
                .where('users.is_active', true)
                .first();

            if (!userSession) {
                throw new Error('Invalid session or user not authenticated');
            }

            // Get current product data
            const currentProduct = await trx('items').where('id', id).first();
            if (!currentProduct) {
                throw new Error('Product not found');
            }

            const permissions = JSON.parse(userSession.permissions);
            const canEditProducts = permissions.includes('products.edit') || 
                                   permissions.includes('system.admin') || 
                                   userSession.can_approve_changes;

            if (canEditProducts) {
                // Manager/Admin: Apply changes immediately
                return await applyProductUpdateDirectly(trx, id, updates, userSession, currentProduct);
            } else {
                // Cashier: Create pending change for approval
                return await createPendingProductUpdate(trx, id, updates, userSession, currentProduct);
            }
        });

    } catch (error) {
        logger.error({ 
            service: 'ProductService', 
            function: 'updateExistingProduct',
            productId: id,
            error: error.message 
        }, 'Failed to update product');
        
        return {
            success: false,
            message: 'Error updating product: ' + error.message,
            error: error.message
        };
    }
}

/**
 * Apply product update directly (for managers/admins)
 * @param {Object} trx - Database transaction
 * @param {Number} id - Product ID
 * @param {Object} updates - Updates to apply
 * @param {Object} userSession - User session data
 * @param {Object} currentProduct - Current product data
 * @returns {Object} Update result
 */
async function applyProductUpdateDirectly(trx, id, updates, userSession, currentProduct) {
    const updateData = {};
    
    // Handle name update
    if (updates.name && updates.name !== JSON.parse(currentProduct.display_names).menu.de) {
        updateData.display_names = JSON.stringify({
            menu: { de: updates.name },
            button: { de: updates.name },
            receipt: { de: updates.name }
        });
    }
    
    // Handle price update
    if (updates.price !== undefined && parseFloat(updates.price) !== parseFloat(currentProduct.item_price_value)) {
        updateData.item_price_value = parseFloat(updates.price);
    }
    
    // Handle category update
    if (updates.categoryName) {
        const newCategory = await trx('categories')
            .whereRaw("JSON_EXTRACT(category_names, '$.de') = ?", [updates.categoryName])
            .first();
        
        if (!newCategory) {
            throw new Error(`Category '${updates.categoryName}' not found`);
        }
        
        if (newCategory.id !== currentProduct.associated_category_unique_identifier) {
            updateData.associated_category_unique_identifier = newCategory.id;
        }
    }

    // Update audit trail
    updateData.audit_trail = JSON.stringify({
        last_modified_at: new Date().toISOString(),
        last_modified_by: userSession.username,
        version: Date.now(),
        change_log: [{
            timestamp: new Date().toISOString(),
            user: userSession.username,
            action: 'direct_update',
            changes: updates,
            user_role: userSession.role_name
        }]
    });

    // Apply updates if any
    if (Object.keys(updateData).length > 0) {
        await trx('items').where('id', id).update(updateData);
        
        // Log fiscal event for master data change
        await loggingService.logFiscalEvent('master_data_change_update', userSession.user_id, {
            entity: 'product',
            product_id: id,
            changes: updates,
            initiator: { type: 'user', id: userSession.user_id, username: userSession.username }
        });
        
        logger.info({ 
            productId: id,
            userId: userSession.user_id,
            username: userSession.username,
            role: userSession.role_name,
            updates: updateData
        }, 'Product updated directly by manager/admin');
    }

    return {
        success: true,
        type: 'direct_update',
        productId: id,
        updated: true,
        changes: updates,
        appliedBy: {
            username: userSession.username,
            role: userSession.role_name,
            timestamp: new Date().toISOString()
        },
        message: 'Product updated successfully'
    };
}

/**
 * Create pending change for product update (for cashiers)
 * @param {Object} trx - Database transaction
 * @param {Number} id - Product ID
 * @param {Object} updates - Updates to apply
 * @param {Object} userSession - User session data
 * @param {Object} currentProduct - Current product data
 * @returns {Object} Pending change creation result
 */
async function createPendingProductUpdate(trx, id, updates, userSession, currentProduct) {
    const changeId = require('crypto').randomUUID();
    
    // Prepare original data
    const originalData = {
        id: currentProduct.id,
        name: JSON.parse(currentProduct.display_names).menu.de,
        price: parseFloat(currentProduct.item_price_value),
        category_id: currentProduct.associated_category_unique_identifier
    };

    // Prepare proposed data
    const proposedData = { ...originalData, ...updates };
    
    // Determine priority based on type of change
    let priority = 'normal';
    if (updates.price !== undefined) {
        const priceDiff = Math.abs(parseFloat(updates.price) - parseFloat(currentProduct.item_price_value));
        if (priceDiff > 10) { // Price change > €10
            priority = 'high';
        }
    }

    // Create pending change record
    await trx('pending_changes').insert({
        change_id: changeId,
        requested_by_user_id: userSession.user_id,
        change_type: 'product_update',
        target_entity_type: 'product',
        target_entity_id: id,
        original_data: JSON.stringify(originalData),
        proposed_data: JSON.stringify(proposedData),
        reason: updates.reason || 'Product update requested',
        priority: priority,
        status: 'pending',
        requires_admin_approval: true,
        audit_trail: JSON.stringify({
            created_at: new Date().toISOString(),
            created_by: userSession.username,
            version: 1,
            action: 'pending_change_creation'
        })
    });

    logger.info({ 
        productId: id,
        changeId,
        userId: userSession.user_id,
        username: userSession.username,
        role: userSession.role_name,
        priority,
        updates
    }, 'Pending product update created for manager approval');

    return {
        success: true,
        type: 'pending_change',
        productId: id,
        changeId: changeId,
        status: 'pending_approval',
        changes: updates,
        priority: priority,
        requestedBy: {
            username: userSession.username,
            role: userSession.role_name,
            timestamp: new Date().toISOString()
        },
        message: 'Product update request submitted for manager approval',
        note: 'Changes will be applied after manager approval'
    };
}

/**
 * Get products by category ID
 * @param {string|number} categoryId - Category ID to filter products
 * @returns {Array} List of products in the category
 */
async function getProductsByCategoryId(categoryId) {
    logger.info({ service: 'ProductService', function: 'getProductsByCategoryId', categoryId }, 'Fetching products for category...');

    try {
        const products = await db('items')
            .where('associated_category_unique_identifier', categoryId)
            .select('*');

        logger.info({ service: 'ProductService', categoryId, count: products.length }, 'Products fetched successfully');
        
        return products;
    } catch (error) {
        logger.error({ service: 'ProductService', error: error.message, categoryId }, 'Failed to fetch products by category');
        throw error;
    }
}

/**
 * Create a price modifier for products
 * @param {Object} details - Modifier details (name, type, value, conditions)
 * @returns {Object} Created modifier data
 */
async function createPriceModifier(details) {
    console.log(`(SERVICE STUB) Creating price modifier: ${details.name} of type ${details.type}...`);
    return { 
        success: true, 
        modifierId: 'mod_mock_' + Date.now(),
        name: details.name,
        type: details.type,
        value: details.value
    };
}

module.exports = { 
    createProduct,
    createNewProduct, 
    updateExistingProduct, 
    createPriceModifier,
    getProductsByCategoryId
};

--- File: /packages/backend/src/services/reporting.service.js ---

// Real reporting service implementation

const db = require('../db/knex');
const logger = require('../config/logger');

/**
 * Generate a sales report for a specific period
 * @param {Object} options - Reporting options
 * @param {string} [options.period='today'] - The time period ('today', 'week', 'month')
 * @param {string} [options.groupBy='none'] - How to group the data ('category', 'hour', 'none')
 * @returns {Promise<Object>} Sales report data
 */
async function generateSalesReport({ period = 'today', groupBy = 'none' } = {}) {
    logger.info({ service: 'ReportingService', function: 'generateSalesReport', period, groupBy }, 'Generating sales report...');

    try {
        const now = new Date();
        let startDate;

        // Calculate start date based on period
        switch (period) {
            case 'week':
                startDate = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
                break;
            case 'month':
                startDate = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
                break;
            case 'today':
            default:
                startDate = new Date();
                startDate.setHours(0, 0, 0, 0);
                break;
        }

        // Build base query
        let query = db('items')
            .where('created_at', '>=', startDate.toISOString());

        // For now, we'll use items table as a proxy for transactions
        // In a real POS system, this would query an orders/transactions table
        const result = await query
            .sum('item_price_value as totalRevenue')
            .count('id as transactionCount')
            .first();

        const totalRevenue = parseFloat(result.totalRevenue || 0);
        const transactionCount = parseInt(result.transactionCount || 0);
        const averageSale = transactionCount > 0 ? (totalRevenue / transactionCount) : 0;

        const reportData = {
            period,
            totalRevenue: totalRevenue.toFixed(2),
            transactionCount,
            averageSale: averageSale.toFixed(2),
            groupBy,
            generatedAt: new Date().toISOString(),
            startDate: startDate.toISOString()
        };

        logger.info({ service: 'ReportingService', reportData }, 'Sales report generated successfully.');
        return { success: true, data: reportData };

    } catch (error) {
        logger.error({ service: 'ReportingService', error: error.message, stack: error.stack }, 'Failed to generate sales report.');
        return { 
            success: false, 
            message: 'Error generating sales report: ' + error.message,
            error: error.message 
        };
    }
}

/**
 * Get top selling items for a specific period
 * @param {string} period - The time period ('today', 'week', 'month')
 * @param {number} limit - Maximum number of items to return
 * @returns {Object} Top selling items data
 */
async function getTopSellingItems(period, limit = 10) {
    console.log(`(SERVICE STUB) Getting top ${limit} selling items for ${period}...`);
    return { 
        success: true, 
        items: [
            { name: 'Mock Coffee', sales: 45, revenue: 135.00 },
            { name: 'Mock Sandwich', sales: 32, revenue: 160.00 },
            { name: 'Mock Pastry', sales: 28, revenue: 84.00 }
        ]
    };
}

/**
 * Get slow moving items for a specific period
 * @param {string} period - The time period ('today', 'week', 'month')
 * @param {number} threshold - Sales threshold to consider an item slow moving
 * @returns {Object} Slow moving items data
 */
async function getSlowMovingItems(period, threshold = 5) {
    console.log(`(SERVICE STUB) Getting items with less than ${threshold} sales for ${period}...`);
    return { 
        success: true, 
        items: [
            { name: 'Mock Specialty Item', sales: 2, revenue: 10.00 },
            { name: 'Mock Seasonal Product', sales: 1, revenue: 8.50 }
        ]
    };
}

/**
 * Get recent finished transactions with their items
 * @param {number} limit - Maximum number of transactions to return
 * @returns {Promise<Object>} Recent transactions data
 */
async function getRecentTransactions(limit = 20) {
    logger.info({ service: 'ReportingService', function: 'getRecentTransactions', limit }, 'Fetching recent transactions...');

    try {
        // Get recent finished transactions
        const transactions = await db('active_transactions')
            .where('status', 'finished')
            .orderBy('updated_at', 'desc')
            .limit(limit)
            .select('*');

        // For each transaction, fetch its items
        const transactionsWithItems = await Promise.all(
            transactions.map(async (transaction) => {
                const items = await db('active_transaction_items')
                    .leftJoin('items', 'active_transaction_items.item_id', 'items.id')
                    .select(
                        'active_transaction_items.*',
                        'items.display_names',
                        'items.item_price_value'
                    )
                    .where('active_transaction_items.active_transaction_id', transaction.id);

                return {
                    ...transaction,
                    items: items.map(item => ({
                        ...item,
                        display_names: item.display_names ? JSON.parse(item.display_names) : null
                    }))
                };
            })
        );

        logger.info({ 
            service: 'ReportingService', 
            count: transactionsWithItems.length, 
            msg: 'Recent transactions fetched successfully'
        });

        return { 
            success: true, 
            transactions: transactionsWithItems 
        };

    } catch (error) {
        logger.error({ 
            service: 'ReportingService', 
            error: error.message, 
            stack: error.stack 
        }, 'Failed to fetch recent transactions.');
        
        return { 
            success: false, 
            message: 'Error fetching recent transactions: ' + error.message,
            error: error.message 
        };
    }
}

module.exports = { 
    generateSalesReport, 
    getTopSellingItems, 
    getSlowMovingItems,
    getRecentTransactions
};

--- File: /packages/backend/src/services/search.service.js ---

// File: /packages/backend/src/services/search.service.js

const db = require('../db/knex');
const { generateEmbedding, embeddingToBuffer } = require('./embedding.service');
const { calculateLevenshtein, isSimilar } = require('../utils/levenshtein');

/**
 * Generates a consistent, canonical cache key for a query and its filters.
 * @param {string} query - The base search query.
 * @param {object} filters - The filter object ({ excludeAllergens, dietaryFilter }).
 * @returns {string} A consistent string key.
 */
function generateCacheKey(query, filters) {
  const sortedFilters = {};
  // Sort keys to ensure consistency
  Object.keys(filters).sort().forEach(key => {
    // Only include non-empty/non-null filters in the key
    if (filters[key] && (!Array.isArray(filters[key]) || filters[key].length > 0)) {
      sortedFilters[key] = filters[key];
    }
  });
  return `${query}_${JSON.stringify(sortedFilters)}`;
}

/**
 * Hybrid search combining FTS, vector search, and Levenshtein distance
 * @param {string} query - Search query
 * @param {Object} options - Search options
 * @returns {Promise<Object>} - Search results with metadata
 */
async function hybridSearch(query, options = {}) {
  const {
    maxResults = 10,
    ftsOnly = false,
    vectorOnly = false,
    levenshteinThreshold = 2,
    vectorDistanceThreshold = 30.0  // Relaxed for mock embeddings
  } = options;

  console.log(`🔍 Hybrid search for: "${query}"`);
  const startTime = Date.now();
  let searchMethod = 'none';
  let results = [];

  try {
    // Step 1: FTS Search (fastest, exact word matches)
    if (!vectorOnly) {
      const ftsStart = Date.now();
      const ftsResults = await performFTSSearch(query, maxResults);
      const ftsTime = Date.now() - ftsStart;
      console.log(`⚡ FTS search: ${ftsResults.length} results in ${ftsTime}ms`);

      if (ftsResults.length > 0) {
        results = ftsResults;
        searchMethod = 'fts';
        console.log(`✅ FTS found results, returning early`);
      } else {
        console.log(`❌ FTS found no results, falling back to vector search`);
      }
    }

    // Step 2: Vector Search (semantic similarity)
    if (results.length === 0 && !ftsOnly) {
      const vectorStart = Date.now();
      const vectorResults = await performVectorSearch(query, maxResults, vectorDistanceThreshold);
      const vectorTime = Date.now() - vectorStart;
      console.log(`🧠 Vector search: ${vectorResults.length} results in ${vectorTime}ms`);

      if (vectorResults.length > 0) {
        searchMethod = 'vector';
        
        // Step 3: Levenshtein filtering (refine vector results)
        const levenshteinStart = Date.now();
        results = await applyLevenshteinFilter(vectorResults, query, levenshteinThreshold);
        const levenshteinTime = Date.now() - levenshteinStart;
        console.log(`📏 Levenshtein filtering: ${results.length} results in ${levenshteinTime}ms`);
        
        if (results.length > 0) {
          searchMethod = 'hybrid';
        }
      }
    }

    const totalTime = Date.now() - startTime;
    console.log(`🏁 Search completed in ${totalTime}ms using ${searchMethod} method`);

    return {
      results: results.slice(0, maxResults),
      metadata: {
        query,
        searchMethod,
        totalResults: results.length,
        executionTime: totalTime,
        options
      }
    };

  } catch (error) {
    console.error('Error in hybrid search:', error);
    throw error;
  }
}

/**
 * Perform Full-Text Search
 * @param {string} query - Search query
 * @param {number} limit - Maximum results
 * @returns {Promise<Array>} - FTS results
 */
async function performFTSSearch(query, limit = 10) {
  try {
    const ftsQuery = query.replace(/[^\w\s]/g, '').trim();
    if (!ftsQuery) return [];

    const ftsResults = await db.raw(`
      SELECT 
        items.id,
        items.display_names,
        items.item_price_value as price,
        items.associated_category_unique_identifier as category_id,
        'fts' as search_type,
        0 as distance,
        100 as similarity
      FROM items_fts 
      JOIN items ON items.id = items_fts.rowid 
      WHERE items_fts MATCH ?
      ORDER BY rank
      LIMIT ?
    `, [ftsQuery, limit]);

    return ftsResults.map(row => ({
      ...row,
      productName: JSON.parse(row.display_names).menu?.de || 'Unknown Product'
    }));

  } catch (error) {
    console.error('FTS search error:', error);
    return [];
  }
}

/**
 * Perform Vector Search
 * @param {string} query - Search query
 * @param {number} limit - Maximum results
 * @param {number} distanceThreshold - Maximum vector distance
 * @returns {Promise<Array>} - Vector search results
 */
async function performVectorSearch(query, limit = 10, distanceThreshold = 0.8) {
  try {
    // Generate embedding for query
    const queryEmbedding = await generateEmbedding(query);
    const queryEmbeddingBuffer = embeddingToBuffer(queryEmbedding);

    // Perform vector search using correct sqlite-vec KNN syntax
    const vectorResults = await db.raw(`
      SELECT 
        items.id,
        items.display_names,
        items.item_price_value as price,
        items.associated_category_unique_identifier as category_id,
        'vector' as search_type,
        distance
      FROM vec_items 
      JOIN items ON items.id = vec_items.rowid 
      WHERE item_embedding MATCH ? AND k = ?
        AND distance <= ?
      ORDER BY distance
    `, [queryEmbeddingBuffer, limit, distanceThreshold]);

    return vectorResults.map(row => ({
      ...row,
      productName: JSON.parse(row.display_names).menu?.de || 'Unknown Product',
      similarity: Math.round((1 - row.distance) * 100)
    }));

  } catch (error) {
    console.error('Vector search error:', error);
    return [];
  }
}

/**
 * Apply Levenshtein distance filtering to vector search results
 * @param {Array} vectorResults - Results from vector search
 * @param {string} query - Original search query
 * @param {number} threshold - Levenshtein distance threshold
 * @returns {Promise<Array>} - Filtered results with Levenshtein scores
 */
async function applyLevenshteinFilter(vectorResults, query, threshold = 2) {
  const filteredResults = vectorResults.map(result => {
    const levenshteinDistance = calculateLevenshtein(query, result.productName);
    const isCloseMatch = isSimilar(query, result.productName, threshold);

    return {
      ...result,
      levenshteinDistance,
      isCloseMatch,
      search_type: 'hybrid'
    };
  });

  // Sort by semantic distance first, then by Levenshtein distance
  filteredResults.sort((a, b) => {
    if (a.distance !== b.distance) {
      return a.distance - b.distance; // Lower semantic distance is better
    }
    return a.levenshteinDistance - b.levenshteinDistance; // Lower edit distance is better
  });

  return filteredResults;
}


/**
 * Search products by name with hybrid approach, caching, and filtering
 * @param {string} productName - Product name to search for
 * @param {Object} filters - Filter options (excludeAllergens, dietaryFilter)
 * @returns {Promise<Object>} - Search results with response message
 */
async function searchProducts(productName, filters = {}) {
  try {
    const { excludeAllergens = [], dietaryFilter = null } = filters;
    const cacheKey = generateCacheKey(productName, filters);
    const CACHE_TTL_MS = 3600 * 1000; // 1 hour

    // --- 1. Refined Cache Check ---
    const cached = await db('search_cache')
      .where({ query_text: cacheKey })
      .where('created_at', '>', new Date(Date.now() - CACHE_TTL_MS))
      .first();

    if (cached) {
      console.log(`✅ Cache hit for key: ${cacheKey}`);
      // The cached response is already what we need. Return it directly.
      return JSON.parse(cached.full_response_text);
    }
    
    console.log(`🔍 Cache miss for key: ${cacheKey}, performing search`);

    // --- 2. Perform Hybrid Search (if no cache hit) ---
    const searchResult = await hybridSearch(productName, {
      maxResults: 5,
      levenshteinThreshold: 3,
      vectorDistanceThreshold: 30.0  // Relaxed for mock embeddings
    });

    let { results, metadata } = searchResult;

    // --- 3. Apply Filters ---
    if ((excludeAllergens.length > 0 || dietaryFilter) && results.length > 0) {
      const itemIds = results.map(item => item.id);
      const fullItems = await db('items').whereIn('id', itemIds);

      const filteredItems = fullItems.filter(item => {
        let attributes = {};
        try {
          attributes = item.additional_item_attributes ? JSON.parse(item.additional_item_attributes) : {};
        } catch (e) {
          console.warn(`Failed to parse additional_item_attributes for item ${item.id}`);
        }

        // Check allergen exclusions
        if (excludeAllergens.length > 0 && attributes.allergens) {
          const hasExcludedAllergen = excludeAllergens.some(allergen => 
            attributes.allergens.includes(allergen)
          );
          if (hasExcludedAllergen) return false;
        }

        // Check dietary filter
        if (dietaryFilter && attributes.dietary_info) {
          if (!attributes.dietary_info.includes(dietaryFilter)) {
            return false;
          }
        }

        return true;
      });

      // Update results with filtered items, preserving search metadata
      results = results.filter(result => 
        filteredItems.some(item => item.id === result.id)
      );

      metadata = { ...metadata, filtersApplied: true };
    }

    // --- 4. Formulate Response ---
    let finalResponse;
    if (results.length === 0) {
      finalResponse = {
        success: false,
        message: `Товар "${productName}" не найден. Попробуйте поискать по другому названию.`,
        results: [],
        metadata
      };
    } else {
      // Check for exact or very close matches
      const exactMatch = results.find(r => 
        r.search_type === 'fts' || 
        (r.levenshteinDistance !== undefined && r.levenshteinDistance <= 1)
      );

      if (exactMatch) {
        finalResponse = {
          success: true,
          message: `Найден товар: "${exactMatch.productName}" - ${exactMatch.price}€`,
          results: [exactMatch],
          metadata
        };
      } else {
        // Check for close matches (including good vector matches)
        const closeMatches = results.filter(r => {
          const isClose = r.isCloseMatch;
          const isHighSimilarity = r.similarity > 80;
          const isGoodVector = (r.distance !== undefined && r.distance <= 0.35);
          
          return isClose || isHighSimilarity || isGoodVector;
        });

        if (closeMatches.length > 0) {
          const bestMatch = closeMatches[0];
          finalResponse = {
            success: true,
            message: `Точное совпадение не найдено, но есть похожий товар: "${bestMatch.productName}" - ${bestMatch.price}€`,
            results: closeMatches,
            metadata
          };
        } else {
          // Return semantic suggestions
          const suggestions = results.slice(0, 3).map(r => r.productName);
          finalResponse = {
            success: false,
            message: `Товар "${productName}" не найден. Возможно, вы имели в виду: ${suggestions.join(', ')}?`,
            results: results.slice(0, 3),
            metadata
          };
        }
      }
    }

    // --- 5. Save to Cache ---
    await db('search_cache').insert({
      query_text: cacheKey,
      full_response_text: JSON.stringify(finalResponse),
      result_item_ids: JSON.stringify(results.map(item => item.id)),
      model_used: 'hybrid-search-v1'
    });
    console.log(`💾 Saved search result to cache for key: ${cacheKey}`);

    // --- 6. Return a fresh result ---
    return finalResponse;

  } catch (error) {
    console.error('Error in product search:', error);
    return {
      success: false,
      message: `Ошибка поиска: ${error.message}`,
      results: [],
      metadata: { error: error.message }
    };
  }
}

module.exports = {
  hybridSearch,
  performFTSSearch,
  performVectorSearch,
  applyLevenshteinFilter,
  searchProducts,
  generateCacheKey
};

--- File: /packages/backend/src/services/system.service.js ---

// Placeholder for system health and diagnostics logic

/**
 * Check overall system health
 * @returns {Object} System health status
 */
async function checkSystemHealth() {
    console.log(`(SERVICE STUB) Performing system health check...`);
    return { 
        success: true, 
        status: {
            database: 'OK',
            tse: 'OK',
            version: '0.1.0',
            uptime: '2 hours 15 minutes',
            timestamp: new Date().toISOString()
        }
    };
}

/**
 * Check database connection
 * @returns {Object} Database connection status
 */
async function checkDatabaseConnection() {
    console.log(`(SERVICE STUB) Checking database connection...`);
    return { 
        success: true, 
        status: 'OK',
        responseTime: '12ms'
    };
}

/**
 * Check TSE (Technical Security Equipment) status
 * @returns {Object} TSE status
 */
async function checkTSEStatus() {
    console.log(`(SERVICE STUB) Checking TSE status...`);
    return { 
        success: true, 
        status: 'OK',
        serialNumber: 'TSE-MOCK-001',
        certificateValid: true
    };
}

module.exports = { 
    checkSystemHealth, 
    checkDatabaseConnection, 
    checkTSEStatus 
};

--- File: /packages/backend/src/services/transaction.service.js ---

// Transaction management service with storno credit system
const crypto = require('crypto');
const db = require('../db/knex');
const logger = require('../config/logger');
const loggingService = require('./logging.service');

/**
 * TransactionService handles financial operations, especially storno (void) operations
 * with credit limit management and approval workflows
 */
class TransactionService {
    
    /**
     * Perform a storno (void) operation with credit limit checking
     * @param {string} sessionId - User session ID
     * @param {string} transactionId - Original transaction ID to void
     * @param {number} amount - Amount to void
     * @param {string} reason - Reason for the storno
     * @param {boolean} isEmergency - Whether this is an emergency storno
     * @returns {Object} Storno operation result
     */
    async performStorno(sessionId, transactionId, amount, reason, isEmergency = false) {
        logger.info({ 
            service: 'TransactionService', 
            function: 'performStorno',
            sessionId,
            transactionId, 
            amount, 
            reason,
            isEmergency
        }, 'Processing storno request');

        try {
            return await db.transaction(async (trx) => {
                // Get current user with storno limits
                const user = await this.getCurrentUserWithLimits(sessionId, trx);
                if (!user) {
                    throw new Error('Invalid session or user not found');
                }

                // Determine which limit to use
                const applicableLimit = isEmergency ? 
                    user.storno_emergency_limit : 
                    user.storno_daily_limit;

                const availableCredit = applicableLimit - user.storno_used_today;
                const stornoId = crypto.randomUUID();

                // Check if amount is within credit limit
                if (amount <= availableCredit) {
                    // Automatic approval - within credit limit
                    return await this.executeAutomaticStorno(
                        trx, user, stornoId, transactionId, amount, reason, isEmergency
                    );
                } else {
                    // Requires manager approval - exceeds credit limit
                    return await this.createPendingStorno(
                        trx, user, stornoId, transactionId, amount, reason, isEmergency, availableCredit
                    );
                }
            });

        } catch (error) {
            logger.error({ 
                service: 'TransactionService', 
                function: 'performStorno',
                sessionId,
                error: error.message 
            }, 'Storno operation failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Execute automatic storno within credit limit
     * @param {Object} trx - Database transaction
     * @param {Object} user - User object
     * @param {string} stornoId - Unique storno ID
     * @param {string} transactionId - Original transaction ID
     * @param {number} amount - Storno amount
     * @param {string} reason - Reason for storno
     * @param {boolean} isEmergency - Emergency storno flag
     * @returns {Object} Storno result
     */
    async executeAutomaticStorno(trx, user, stornoId, transactionId, amount, reason, isEmergency) {
        // Update user's storno credit usage
        const newUsedAmount = parseFloat(user.storno_used_today) + amount;
        await trx('users')
            .where('id', user.id)
            .update({ storno_used_today: newUsedAmount });

        // Log the storno operation
        await trx('storno_log').insert({
            storno_id: stornoId,
            user_id: user.id,
            transaction_id: transactionId,
            storno_amount: amount,
            storno_type: isEmergency ? 'emergency' : 'automatic',
            reason: reason,
            within_credit_limit: true,
            credit_used: amount,
            remaining_credit_after: (isEmergency ? user.storno_emergency_limit : user.storno_daily_limit) - newUsedAmount,
            approval_status: 'automatic',
            approved_at: new Date(),
            additional_data: JSON.stringify({
                processed_automatically: true,
                credit_limit_used: isEmergency ? 'emergency' : 'daily'
            }),
            audit_trail: JSON.stringify({
                created_at: new Date().toISOString(),
                created_by: user.username,
                version: 1,
                action: 'automatic_storno_execution'
            })
        });

        // *** FISCAL LOG INTEGRATION ***
        await loggingService.logFiscalEvent('storno_automatic', user.id, {
            storno_id: stornoId,
            original_transaction_id: transactionId,
            amount: amount,
            reason: reason,
            type: isEmergency ? 'emergency' : 'daily_credit'
        });

        // Update trust score for successful automatic storno
        await this.updateTrustScore(trx, user.id, 1); // Small positive increase

        logger.info({ 
            userId: user.id,
            stornoId,
            amount,
            newUsedAmount,
            type: isEmergency ? 'emergency' : 'automatic'
        }, 'Automatic storno executed successfully');

        return {
            success: true,
            storno: {
                id: stornoId,
                amount: amount,
                type: 'automatic',
                status: 'approved',
                processed_at: new Date().toISOString(),
                remaining_credit: (isEmergency ? user.storno_emergency_limit : user.storno_daily_limit) - newUsedAmount
            },
            message: `Storno of €${amount.toFixed(2)} processed automatically. Remaining ${isEmergency ? 'emergency' : 'daily'} credit: €${((isEmergency ? user.storno_emergency_limit : user.storno_daily_limit) - newUsedAmount).toFixed(2)}`
        };
    }

    /**
     * Create pending storno that requires manager approval
     * @param {Object} trx - Database transaction
     * @param {Object} user - User object
     * @param {string} stornoId - Unique storno ID
     * @param {string} transactionId - Original transaction ID
     * @param {number} amount - Storno amount
     * @param {string} reason - Reason for storno
     * @param {boolean} isEmergency - Emergency storno flag
     * @param {number} availableCredit - Available credit amount
     * @returns {Object} Storno result
     */
    async createPendingStorno(trx, user, stornoId, transactionId, amount, reason, isEmergency, availableCredit) {
        const exceedsBy = amount - availableCredit;

        // Log the pending storno
        await trx('storno_log').insert({
            storno_id: stornoId,
            user_id: user.id,
            transaction_id: transactionId,
            storno_amount: amount,
            storno_type: isEmergency ? 'emergency' : 'admin_approved',
            reason: reason,
            within_credit_limit: false,
            credit_used: 0, // Not used yet, pending approval
            remaining_credit_after: availableCredit,
            approval_status: 'pending',
            additional_data: JSON.stringify({
                exceeds_credit_by: exceedsBy,
                available_credit: availableCredit,
                requires_manager_approval: true,
                credit_limit_type: isEmergency ? 'emergency' : 'daily'
            }),
            audit_trail: JSON.stringify({
                created_at: new Date().toISOString(),
                created_by: user.username,
                version: 1,
                action: 'pending_storno_creation'
            })
        });

        // Create pending change record for manager review
        const changeId = crypto.randomUUID();
        await trx('pending_changes').insert({
            change_id: changeId,
            requested_by_user_id: user.id,
            change_type: 'storno_approval',
            target_entity_type: 'transaction',
            target_entity_id: null, // No specific entity ID for storno
            original_data: JSON.stringify({
                transaction_id: transactionId,
                original_amount: amount
            }),
            proposed_data: JSON.stringify({
                storno_id: stornoId,
                storno_amount: amount,
                reason: reason,
                emergency: isEmergency,
                exceeds_credit_by: exceedsBy
            }),
            reason: `Storno exceeds credit limit by €${exceedsBy.toFixed(2)}. ${reason}`,
            priority: isEmergency ? 'urgent' : 'high',
            status: 'pending',
            requires_admin_approval: true,
            audit_trail: JSON.stringify({
                created_at: new Date().toISOString(),
                created_by: user.username,
                version: 1,
                action: 'storno_approval_request'
            })
        });

        logger.info({ 
            userId: user.id,
            stornoId,
            changeId,
            amount,
            exceedsBy,
            isEmergency
        }, 'Pending storno created for manager approval');

        return {
            success: true,
            storno: {
                id: stornoId,
                amount: amount,
                type: 'pending_approval',
                status: 'pending',
                change_id: changeId,
                exceeds_by: exceedsBy,
                available_credit: availableCredit
            },
            message: `Storno of €${amount.toFixed(2)} exceeds your ${isEmergency ? 'emergency' : 'daily'} credit limit by €${exceedsBy.toFixed(2)}. Request sent to manager for approval.`
        };
    }

    /**
     * Approve a pending storno (manager action)
     * @param {string} managerSessionId - Manager's session ID
     * @param {string} stornoId - Storno ID to approve
     * @param {string} approvalNotes - Manager's approval notes
     * @returns {Object} Approval result
     */
    async approveStorno(managerSessionId, stornoId, approvalNotes = '') {
        logger.info({ 
            service: 'TransactionService', 
            function: 'approveStorno',
            managerSessionId,
            stornoId,
            approvalNotes
        }, 'Processing storno approval');

        try {
            return await db.transaction(async (trx) => {
                // Get manager user
                const manager = await this.getCurrentUserWithLimits(managerSessionId, trx);
                if (!manager || !manager.can_approve_changes) {
                    throw new Error('Insufficient permissions to approve storno');
                }

                // Get the pending storno
                const storno = await trx('storno_log')
                    .where('storno_id', stornoId)
                    .where('approval_status', 'pending')
                    .first();

                if (!storno) {
                    throw new Error('Pending storno not found or already processed');
                }

                // Get the original user who requested the storno
                const originalUser = await trx('users').where('id', storno.user_id).first();
                if (!originalUser) {
                    throw new Error('Original user not found');
                }

                // Update storno log with approval
                await trx('storno_log')
                    .where('storno_id', stornoId)
                    .update({
                        approval_status: 'approved',
                        approved_by_user_id: manager.id,
                        approved_at: new Date(),
                        credit_used: parseFloat(storno.storno_amount),
                        remaining_credit_after: parseFloat(originalUser.storno_daily_limit) - (parseFloat(originalUser.storno_used_today) + parseFloat(storno.storno_amount))
                    });

                // Update user's storno credit usage
                const newUsedAmount = parseFloat(originalUser.storno_used_today) + parseFloat(storno.storno_amount);
                await trx('users')
                    .where('id', originalUser.id)
                    .update({ storno_used_today: newUsedAmount });

                // Update the related pending change
                await trx('pending_changes')
                    .where('requested_by_user_id', storno.user_id)
                    .where('change_type', 'storno_approval')
                    .whereRaw("JSON_EXTRACT(proposed_data, '$.storno_id') = ?", [stornoId])
                    .update({
                        status: 'approved',
                        reviewed_by_user_id: manager.id,
                        reviewed_at: new Date(),
                        review_notes: approvalNotes
                    });

                // *** FISCAL LOG INTEGRATION ***
                await loggingService.logFiscalEvent('storno_approved', manager.id, {
                    storno_id: stornoId,
                    original_transaction_id: storno.transaction_id,
                    amount: parseFloat(storno.storno_amount),
                    reason: storno.reason,
                    requested_by: originalUser.id,
                    approved_by: manager.id,
                    notes: approvalNotes
                });

                // Increase trust score for approved storno (smaller increase than automatic)
                await this.updateTrustScore(trx, originalUser.id, 0.5);

                logger.info({ 
                    managerId: manager.id,
                    originalUserId: originalUser.id,
                    stornoId,
                    amount: storno.storno_amount
                }, 'Storno approved by manager');

                return {
                    success: true,
                    message: `Storno of €${parseFloat(storno.storno_amount).toFixed(2)} approved successfully`,
                    storno: {
                        id: stornoId,
                        amount: parseFloat(storno.storno_amount),
                        status: 'approved',
                        approved_by: manager.full_name,
                        approved_at: new Date().toISOString()
                    }
                };
            });

        } catch (error) {
            logger.error({ 
                service: 'TransactionService', 
                function: 'approveStorno',
                stornoId,
                error: error.message 
            }, 'Storno approval failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Reject a pending storno (manager action)
     * @param {string} managerSessionId - Manager's session ID
     * @param {string} stornoId - Storno ID to reject
     * @param {string} rejectionReason - Reason for rejection
     * @returns {Object} Rejection result
     */
    async rejectStorno(managerSessionId, stornoId, rejectionReason = '') {
        logger.info({ 
            service: 'TransactionService', 
            function: 'rejectStorno',
            managerSessionId,
            stornoId,
            rejectionReason
        }, 'Processing storno rejection');

        try {
            return await db.transaction(async (trx) => {
                // Get manager user
                const manager = await this.getCurrentUserWithLimits(managerSessionId, trx);
                if (!manager || !manager.can_approve_changes) {
                    throw new Error('Insufficient permissions to reject storno');
                }

                // Get the pending storno
                const storno = await trx('storno_log')
                    .where('storno_id', stornoId)
                    .where('approval_status', 'pending')
                    .first();

                if (!storno) {
                    throw new Error('Pending storno not found or already processed');
                }

                // Update storno log with rejection
                await trx('storno_log')
                    .where('storno_id', stornoId)
                    .update({
                        approval_status: 'rejected',
                        approved_by_user_id: manager.id,
                        approved_at: new Date()
                    });

                // Update the related pending change
                await trx('pending_changes')
                    .where('requested_by_user_id', storno.user_id)
                    .where('change_type', 'storno_approval')
                    .whereRaw("JSON_EXTRACT(proposed_data, '$.storno_id') = ?", [stornoId])
                    .update({
                        status: 'rejected',
                        reviewed_by_user_id: manager.id,
                        reviewed_at: new Date(),
                        review_notes: rejectionReason
                    });

                // Slightly decrease trust score for rejected storno
                await this.updateTrustScore(trx, storno.user_id, -1);

                logger.info({ 
                    managerId: manager.id,
                    originalUserId: storno.user_id,
                    stornoId,
                    amount: storno.storno_amount,
                    reason: rejectionReason
                }, 'Storno rejected by manager');

                return {
                    success: true,
                    message: `Storno of €${parseFloat(storno.storno_amount).toFixed(2)} rejected`,
                    storno: {
                        id: stornoId,
                        amount: parseFloat(storno.storno_amount),
                        status: 'rejected',
                        rejected_by: manager.full_name,
                        rejected_at: new Date().toISOString(),
                        rejection_reason: rejectionReason
                    }
                };
            });

        } catch (error) {
            logger.error({ 
                service: 'TransactionService', 
                function: 'rejectStorno',
                stornoId,
                error: error.message 
            }, 'Storno rejection failed');
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Get pending stornos for manager review
     * @param {string} sessionId - Manager session ID
     * @returns {Array} List of pending stornos
     */
    async getPendingStornos(sessionId) {
        try {
            const user = await this.getCurrentUserWithLimits(sessionId);
            if (!user || !user.can_approve_changes) {
                throw new Error('Insufficient permissions to view pending stornos');
            }

            const pendingStornos = await db('storno_log')
                .select([
                    'storno_log.*',
                    'users.username',
                    'users.full_name'
                ])
                .join('users', 'storno_log.user_id', 'users.id')
                .where('storno_log.approval_status', 'pending')
                .orderBy('storno_log.created_at', 'desc');

            return {
                success: true,
                stornos: pendingStornos.map(storno => ({
                    id: storno.storno_id,
                    transaction_id: storno.transaction_id,
                    amount: parseFloat(storno.storno_amount),
                    reason: storno.reason,
                    type: storno.storno_type,
                    requested_by: {
                        username: storno.username,
                        full_name: storno.full_name
                    },
                    requested_at: storno.created_at,
                    additional_data: JSON.parse(storno.additional_data || '{}')
                }))
            };

        } catch (error) {
            logger.error({ 
                service: 'TransactionService', 
                function: 'getPendingStornos',
                error: error.message 
            }, 'Failed to get pending stornos');
            
            return {
                success: false,
                error: error.message,
                stornos: []
            };
        }
    }

    /**
     * Reset daily storno credit for all users (should be run daily)
     */
    async resetDailyStornoCredits() {
        try {
            const result = await db('users').update({ storno_used_today: 0 });
            
            logger.info({ 
                service: 'TransactionService',
                function: 'resetDailyStornoCredits',
                usersReset: result
            }, 'Daily storno credits reset for all users');

            return { success: true, usersReset: result };

        } catch (error) {
            logger.error({ 
                service: 'TransactionService', 
                function: 'resetDailyStornoCredits',
                error: error.message 
            }, 'Failed to reset daily storno credits');
            
            return { success: false, error: error.message };
        }
    }

    /**
     * Update user's trust score
     * @param {Object} trx - Database transaction
     * @param {number} userId - User ID
     * @param {number} change - Change amount (+/-)
     */
    async updateTrustScore(trx, userId, change) {
        const user = await trx('users').where('id', userId).first();
        if (!user) return;

        const newScore = Math.max(0, Math.min(100, user.trust_score + change));
        await trx('users').where('id', userId).update({ trust_score: newScore });

        // Adjust credit limits based on new trust score if significant change
        if (Math.abs(change) >= 5) {
            const baseLimit = 50; // Base daily limit
            const trustMultiplier = newScore / 50; // 1.0 at trust 50, 2.0 at trust 100
            const newDailyLimit = baseLimit * trustMultiplier;
            const newEmergencyLimit = newDailyLimit * 0.5;

            await trx('users')
                .where('id', userId)
                .update({
                    storno_daily_limit: newDailyLimit,
                    storno_emergency_limit: newEmergencyLimit
                });

            logger.info({ 
                userId,
                oldTrustScore: user.trust_score,
                newTrustScore: newScore,
                newDailyLimit,
                newEmergencyLimit
            }, 'User trust score and credit limits updated');
        }
    }

    /**
     * Get current user with storno limits from session
     * @param {string} sessionId - Session ID
     * @param {Object} trx - Optional database transaction
     * @returns {Object|null} User with limits or null
     */
    async getCurrentUserWithLimits(sessionId, trx = db) {
        // This would use the auth service to validate session
        // For now, let's get user data directly
        const session = await trx('user_sessions')
            .select([
                'user_sessions.*',
                'users.*',
                'roles.role_name',
                'roles.permissions',
                'roles.can_approve_changes',
                'roles.can_manage_users'
            ])
            .join('users', 'user_sessions.user_id', 'users.id')
            .join('roles', 'users.role_id', 'roles.id')
            .where('user_sessions.session_id', sessionId)
            .where('user_sessions.is_active', true)
            .where('user_sessions.expires_at', '>', new Date())
            .where('users.is_active', true)
            .first();

        if (!session) return null;

        return {
            id: session.user_id,
            username: session.username,
            full_name: session.full_name,
            email: session.email,
            role_name: session.role_name,
            permissions: JSON.parse(session.permissions),
            storno_daily_limit: parseFloat(session.storno_daily_limit),
            storno_emergency_limit: parseFloat(session.storno_emergency_limit),
            storno_used_today: parseFloat(session.storno_used_today),
            trust_score: session.trust_score,
            can_approve_changes: session.can_approve_changes,
            can_manage_users: session.can_manage_users
        };
    }
}

module.exports = new TransactionService();

--- File: /packages/backend/src/services/transaction_management.service.js ---

const db = require('../db/knex');
const logger = require('../config/logger');
const loggingService = require('./logging.service');
const crypto = require('crypto');

/**
 * Manages the lifecycle of active transactions (orders/receipts).
 * This service handles creating orders, adding items, and finalizing them for fiscal logging.
 */
class TransactionManagementService {

  /**
   * Finds an existing active transaction based on metadata (e.g., table number) or creates a new one.
   * @param {object} criteria - Criteria to find the transaction (e.g., { transactionId: 123 } or { metadata: { table: 5 } }).
   * @param {number} userId - The ID of the user creating the transaction.
   * @returns {Promise<object>} The active transaction object.
   */
  async findOrCreateActiveTransaction(criteria, userId) {
    logger.info({ service: 'TransactionManagementService', function: 'findOrCreateActiveTransaction', criteria, userId });

    let existingTransaction = null;

    // Only attempt to find an existing transaction if a specific transactionId is provided
    if (criteria.transactionId) {
      existingTransaction = await db('active_transactions')
        .where({ id: criteria.transactionId, status: 'active' })
        .first();

      if (existingTransaction) {
        logger.info({ msg: 'Found existing active transaction by ID', id: existingTransaction.id });
        return existingTransaction;
      } else {
        logger.warn({ msg: 'Specified transaction not found or not active', transactionId: criteria.transactionId });
      }
    }

    // No specific transaction ID provided or specified transaction not found - create a new one
    logger.info('Creating a new transaction (no specific transactionId provided or specified transaction not found).');
    const newTransactionUUID = crypto.randomUUID();

    // Create the transaction record first
    const nowUTC = new Date().toISOString();
    const [newTransaction] = await db('active_transactions').insert({
      uuid: newTransactionUUID,
      status: 'active',
      user_id: userId,
      business_date: nowUTC.split('T')[0],
      metadata: JSON.stringify(criteria.metadata || {}),
      created_at: nowUTC,
      updated_at: nowUTC
    }).returning('*');

    // *** FISCAL LOG INTEGRATION ***
    // Every new transaction MUST be logged with a 'startTransaction' event.
    const fiscalLogResult = await loggingService.logFiscalEvent('startTransaction', userId, {
      transaction_uuid: newTransactionUUID,
      metadata: criteria.metadata || {}
    });

    if (!fiscalLogResult.success) {
      // If fiscal logging fails, clean up the transaction record and throw error
      await db('active_transactions').where('id', newTransaction.id).del();
      throw new Error(`Failed to create fiscal log for new transaction: ${fiscalLogResult.error}`);
    }

    logger.info({ msg: 'New active transaction created successfully', id: newTransaction.id, uuid: newTransaction.uuid });
    return newTransaction;
  }

  /**
   * Adds an item to an active transaction.
   * @param {number} transactionId - The ID of the active transaction.
   * @param {number} itemId - The ID of the item to add.
   * @param {number} quantity - The quantity of the item.
   * @param {object} options - Optional parameters like notes or modifiers.
   * @returns {Promise<object>} The updated active transaction object.
   */
  async addItemToTransaction(transactionId, itemId, quantity, userId, options = {}) {
    logger.info({ service: 'TransactionManagementService', function: 'addItemToTransaction', transactionId, itemId, quantity });

    let updatedTransaction, item;

    // Execute database transaction first
    const result = await db.transaction(async (trx) => {
        // 1. Fetch the active transaction and lock it for update.
        const transaction = await trx('active_transactions').where({ id: transactionId, status: 'active' }).forUpdate().first();
        if (!transaction) {
            throw new Error(`Active transaction with ID ${transactionId} not found.`);
        }

        // 2. Fetch the product details.
        item = await trx('items').where({ id: itemId }).first();
        if (!item) {
            throw new Error(`Item with ID ${itemId} not found.`);
        }
        
        // Simplified tax calculation logic. A real implementation would be more robust.
        const category = await trx('categories').where({ id: item.associated_category_unique_identifier }).first();
        // Assuming 19% for 'drink' and 7% for everything else as a placeholder.
        const taxRate = category.category_type === 'drink' ? 19.00 : 7.00;

        // 3. Calculate amounts for the new item.
        const unit_price = parseFloat(item.item_price_value);
        const total_price = unit_price * quantity;
        const tax_amount = total_price - (total_price / (1 + taxRate / 100));

        // 4. Insert the new item into the transaction.
        const [newItem] = await trx('active_transaction_items').insert({
            active_transaction_id: transactionId,
            item_id: itemId,
            quantity: quantity,
            unit_price: unit_price,
            total_price: total_price,
            tax_rate: taxRate,
            tax_amount: tax_amount,
            notes: options.notes || null
        }).returning('*');

        // 5. Update the main transaction totals.
        const newTotalAmount = parseFloat(transaction.total_amount) + total_price;
        const newTaxAmount = parseFloat(transaction.tax_amount) + tax_amount;

        updatedTransaction = (await trx('active_transactions').where({ id: transactionId }).update({
            total_amount: newTotalAmount,
            tax_amount: newTaxAmount,
            updated_at: new Date().toISOString()
        }).returning('*'))[0];

        const updatedItems = await trx('active_transaction_items').where({ active_transaction_id: transactionId });
        return { 
            transaction: updatedTransaction, 
            newItem, 
            items: updatedItems,
            total_price 
        };
    });

    // 6. *** FISCAL LOG INTEGRATION *** (outside database transaction to avoid connection pool issues)
    const fiscalLogResult = await loggingService.logFiscalEvent('updateTransaction', userId, {
        transaction_uuid: updatedTransaction.uuid,
        item_added: {
            item_id: itemId,
            name: JSON.parse(item.display_names).menu.de,
            quantity,
            total_price: result.total_price
        },
        new_total: updatedTransaction.total_amount
    });

    if (!fiscalLogResult.success) {
        // Log the error but don't fail the transaction since it's already committed
        logger.error({ msg: 'Failed to create fiscal log for item update (transaction already committed)', error: fiscalLogResult.error });
    }

    logger.info({ msg: 'Item added to transaction successfully', transactionId, itemId, newItemId: result.newItem.id });

    return { ...result.transaction, items: result.items };
  }

  /**
   * Finishes an active transaction, processing payment and triggering final fiscalization.
   * @param {number} transactionId - The ID of the active transaction to finish.
   * @param {object} paymentData - Information about the payment (e.g., { type: 'CASH', amount: 55.00 }).
   * @returns {Promise<object>} The result including the complete finished transaction with items.
   */
  async finishTransaction(transactionId, paymentData, userId) {
    logger.info({ service: 'TransactionManagementService', function: 'finishTransaction', transactionId, paymentData });

    let transaction, processData, finishedTransaction;

    // First phase: Update transaction status and prepare fiscal data in database transaction
    const updateResult = await db.transaction(async (trx) => {
      // 1. Fetch the active transaction and lock it.
      transaction = await trx('active_transactions').where({ id: transactionId, status: 'active' }).forUpdate().first();
      if (!transaction) {
        throw new Error(`Active transaction with ID ${transactionId} not found.`);
      }

      // 2. Verify payment amount.
      const totalAmount = parseFloat(transaction.total_amount);
      const paymentAmount = parseFloat(paymentData.amount);
      if (Math.abs(totalAmount - paymentAmount) > 0.001) { // Use a tolerance for float comparison
        throw new Error(`Payment amount (${paymentAmount}) does not match transaction total (${totalAmount}).`);
      }

      // 3. Fetch tax breakdown for this transaction.
      const taxBreakdown = await trx('active_transaction_items')
        .where({ active_transaction_id: transactionId })
        .groupBy('tax_rate')
        .select('tax_rate')
        .sum('total_price as total');

      // 4. Format 'processData' for DSFinV-K compliance.
      // This is a simplified version. A full implementation would map tax rates to the official DSFinV-K indices.
      const taxRatesOrder = [19.00, 7.00, 10.70, 5.50, 0.00]; // Simplified DSFinV-K order
      const bruttoSteuerumsaetze = taxRatesOrder.map(rate => {
        const found = taxBreakdown.find(b => parseFloat(b.tax_rate) === rate);
        return found ? parseFloat(found.total).toFixed(2) : '0.00';
      }).join('_');

      const zahlungen = `${paymentAmount.toFixed(2)}:${paymentData.type}`;
      processData = `Beleg^${bruttoSteuerumsaetze}^${zahlungen}`;

      // 5. Update transaction status to 'finished'.
      const [updatedTransaction] = await trx('active_transactions').where({ id: transactionId }).update({ 
        status: 'finished',
        payment_type: paymentData.type,
        payment_amount: paymentAmount
      }).returning('*');

      // 6. Fetch the complete transaction with items for the response
      const items = await trx('active_transaction_items')
        .leftJoin('items', 'active_transaction_items.item_id', 'items.id')
        .select(
          'active_transaction_items.*',
          'items.display_names',
          'items.item_price_value'
        )
        .where('active_transaction_items.active_transaction_id', transactionId);

      finishedTransaction = {
        ...updatedTransaction,
        items: items.map(item => ({
          ...item,
          display_names: item.display_names ? JSON.parse(item.display_names) : null
        }))
      };

      return { totalAmount };
    });

    // Second phase: Create fiscal log outside of main transaction to avoid connection pool conflicts
    const fiscalLogResult = await loggingService.logFiscalEvent('finishTransaction', userId, {
      transaction_uuid: transaction.uuid,
      processType: 'Kassenbeleg-V1',
      processData: processData,
      payment_type: paymentData.type,
      final_amount: updateResult.totalAmount,
      metadata: transaction.metadata ? JSON.parse(transaction.metadata) : {}
    });

    if (!fiscalLogResult.success) {
      // If fiscal logging fails after transaction is finished, log error but don't revert transaction
      logger.error({ msg: 'Failed to create fiscal log for finished transaction (transaction already committed)', error: fiscalLogResult.error, transactionId });
      return { 
        success: true, 
        warning: 'Transaction finished but fiscal logging failed', 
        fiscal_log_error: fiscalLogResult.error,
        transaction: finishedTransaction
      };
    }

    logger.info({ msg: 'Transaction finished successfully', transactionId });
    return { 
      success: true, 
      fiscal_log: fiscalLogResult.log,
      transaction: finishedTransaction
    };
  }

  /**
   * Retrieves all transactions that require manual recovery (resolution_status = 'pending').
   * Includes associated transaction items with display names for frontend display.
   * @returns {Promise<Array>} Array of pending recovery transactions with their items.
   */
  async getPendingTransactions() {
    logger.info({ service: 'TransactionManagementService', function: 'getPendingTransactions' });

    try {
      // Find all transactions with resolution_status = 'pending'
      const pendingTransactions = await db('active_transactions')
        .where('resolution_status', 'pending')
        .select('*')
        .orderBy('created_at', 'asc');

      if (pendingTransactions.length === 0) {
        logger.info('No pending recovery transactions found');
        return [];
      }

      // For each pending transaction, fetch its associated items
      const transactionsWithItems = await Promise.all(
        pendingTransactions.map(async (transaction) => {
          const items = await db('active_transaction_items')
            .leftJoin('items', 'active_transaction_items.item_id', 'items.id')
            .select(
              'active_transaction_items.*',
              'items.display_names',
              'items.item_price_value'
            )
            .where('active_transaction_items.active_transaction_id', transaction.id);

          return {
            ...transaction,
            items: items.map(item => ({
              ...item,
              display_names: item.display_names ? JSON.parse(item.display_names) : null
            }))
          };
        })
      );

      logger.info({ 
        count: transactionsWithItems.length,
        msg: 'Retrieved pending recovery transactions with items'
      });

      return transactionsWithItems;
    } catch (error) {
      logger.error({ 
        msg: 'Failed to retrieve pending recovery transactions', 
        error: error.message 
      });
      throw error;
    }
  }

  /**
   * Resolves a pending transaction with the specified resolution type.
   * @param {number} transactionId - The ID of the transaction to resolve.
   * @param {string} resolution - The resolution type: 'postpone', 'cancel', or 'fiscalize'.
   * @param {number} userId - The ID of the user performing the resolution.
   * @returns {Promise<object>} The result of the resolution operation.
   */
  async resolvePendingTransaction(transactionId, resolution, userId) {
    logger.info({ 
      service: 'TransactionManagementService', 
      function: 'resolvePendingTransaction', 
      transactionId, 
      resolution, 
      userId 
    });

    try {
      // First, verify the transaction exists and is in pending status
      const transaction = await db('active_transactions')
        .where({ id: transactionId, resolution_status: 'pending' })
        .first();

      if (!transaction) {
        throw new Error(`Transaction with ID ${transactionId} not found or not in pending status`);
      }

      let result;

      switch (resolution) {
        case 'postpone':
          // Update the transaction's resolution_status to 'postponed'
          await db('active_transactions')
            .where({ id: transactionId })
            .update({ 
              resolution_status: 'postponed',
              updated_at: new Date().toISOString()
            });

          // Log the fiscal event for postponement
          const fiscalLogResult = await loggingService.logFiscalEvent('postponeTransaction', userId, {
            transaction_uuid: transaction.uuid,
            original_status: 'pending',
            new_status: 'postponed'
          });

          if (!fiscalLogResult.success) {
            logger.error({ 
              msg: 'Failed to create fiscal log for transaction postponement', 
              error: fiscalLogResult.error,
              transactionId 
            });
          }

          result = { 
            success: true, 
            action: 'postponed',
            transactionId,
            fiscal_log: fiscalLogResult.success ? fiscalLogResult.log : null
          };
          break;

        case 'cancel':
          // TODO: Implement transaction cancellation logic
          // This should update status to 'cancelled' and create appropriate fiscal logs
          throw new Error('Transaction cancellation not yet implemented');

        case 'fiscalize':
          // TODO: Implement transaction fiscalization logic
          // This should complete the fiscal process and update status accordingly
          throw new Error('Transaction fiscalization not yet implemented');

        default:
          throw new Error(`Unknown resolution type: ${resolution}`);
      }

      logger.info({ 
        msg: `Transaction ${resolution} completed successfully`, 
        transactionId, 
        resolution 
      });

      return result;
    } catch (error) {
      logger.error({ 
        msg: 'Failed to resolve pending transaction', 
        error: error.message,
        transactionId,
        resolution
      });
      throw error;
    }
  }

  /**
   * Parks an active transaction with a table identifier.
   * @param {number} transactionId - The ID of the transaction to park.
   * @param {string} tableIdentifier - The table identifier (e.g., "5", "Table A").
   * @param {number} userId - The ID of the user performing the operation.
   * @returns {Promise<object>} The parked transaction object.
   */
  async parkTransaction(transactionId, tableIdentifier, userId, updateTimestamp = true) {
    logger.info({ 
      service: 'TransactionManagementService', 
      function: 'parkTransaction', 
      transactionId, 
      tableIdentifier, 
      userId,
      updateTimestamp
    });

    try {
      // First, verify the transaction exists and is active
      const transaction = await db('active_transactions')
        .where({ id: transactionId, status: 'active' })
        .first();

      if (!transaction) {
        throw new Error(`Active transaction with ID ${transactionId} not found`);
      }

      // Parse existing metadata
      const metadata = transaction.metadata ? JSON.parse(transaction.metadata) : {};
      metadata.table = tableIdentifier;

      // Update transaction status to 'parked' and add table info
      const updateData = { 
        status: 'parked',
        metadata: JSON.stringify(metadata)
      };
      if (updateTimestamp) {
        updateData.updated_at = new Date().toISOString();
      }
      
      const [parkedTransaction] = await db('active_transactions')
        .where({ id: transactionId })
        .update(updateData)
        .returning('*');

      // Log the fiscal event for parking
      const fiscalLogResult = await loggingService.logFiscalEvent('parkTransaction', userId, {
        transaction_uuid: transaction.uuid,
        table_identifier: tableIdentifier,
        original_status: 'active',
        new_status: 'parked'
      });

      if (!fiscalLogResult.success) {
        logger.error({ 
          msg: 'Failed to create fiscal log for transaction parking', 
          error: fiscalLogResult.error,
          transactionId 
        });
      }

      logger.info({ 
        msg: 'Transaction parked successfully', 
        transactionId, 
        tableIdentifier 
      });

      return parkedTransaction;
    } catch (error) {
      logger.error({ 
        msg: 'Failed to park transaction', 
        error: error.message,
        transactionId,
        tableIdentifier
      });
      throw error;
    }
  }

  /**
   * Activates a parked transaction.
   * @param {number} transactionId - The ID of the transaction to activate.
   * @param {number} userId - The ID of the user performing the operation.
   * @param {boolean} updateTimestamp - Whether to update the updated_at timestamp (default: false).
   * @returns {Promise<object>} The activated transaction object with items.
   */
  async activateTransaction(transactionId, userId, updateTimestamp = false) {
    logger.info({ 
      service: 'TransactionManagementService', 
      function: 'activateTransaction', 
      transactionId, 
      userId,
      updateTimestamp
    });

    try {
      // First, verify the transaction exists and is parked
      const transaction = await db('active_transactions')
        .where({ id: transactionId, status: 'parked' })
        .first();

      if (!transaction) {
        throw new Error(`Parked transaction with ID ${transactionId} not found`);
      }

      // Prepare update data
      const updateData = { status: 'active' };
      if (updateTimestamp) {
        updateData.updated_at = new Date().toISOString();
      }

      // Update transaction status to 'active'
      const [activatedTransaction] = await db('active_transactions')
        .where({ id: transactionId })
        .update(updateData)
        .returning('*');

      // Fetch the complete transaction with items
      const items = await db('active_transaction_items')
        .leftJoin('items', 'active_transaction_items.item_id', 'items.id')
        .select(
          'active_transaction_items.*',
          'items.display_names',
          'items.item_price_value'
        )
        .where('active_transaction_items.active_transaction_id', transactionId);

      const completeTransaction = {
        ...activatedTransaction,
        items: items.map(item => ({
          ...item,
          display_names: item.display_names ? JSON.parse(item.display_names) : null
        }))
      };

      // Log the fiscal event for activation
      const fiscalLogResult = await loggingService.logFiscalEvent('activateTransaction', userId, {
        transaction_uuid: transaction.uuid,
        original_status: 'parked',
        new_status: 'active'
      });

      if (!fiscalLogResult.success) {
        logger.error({ 
          msg: 'Failed to create fiscal log for transaction activation', 
          error: fiscalLogResult.error,
          transactionId 
        });
      }

      logger.info({ 
        msg: 'Transaction activated successfully', 
        transactionId 
      });

      return completeTransaction;
    } catch (error) {
      logger.error({ 
        msg: 'Failed to activate transaction', 
        error: error.message,
        transactionId
      });
      throw error;
    }
  }

  /**
   * Retrieves all parked transactions.
   * @returns {Promise<Array>} Array of parked transactions with their metadata.
   */
  async getParkedTransactions() {
    logger.info({ service: 'TransactionManagementService', function: 'getParkedTransactions' });

    try {
      const parkedTransactions = await db('active_transactions')
        .where('status', 'parked')
        .select('*')
        .orderBy('updated_at', 'asc');

      // Parse metadata for each transaction and normalize timestamps
      const transactionsWithParsedMetadata = parkedTransactions.map(transaction => ({
        ...transaction,
        metadata: transaction.metadata ? JSON.parse(transaction.metadata) : {},
        // Normalize timestamps to ISO format for consistent parsing on frontend
        created_at: new Date(transaction.created_at).toISOString(),
        updated_at: new Date(transaction.updated_at).toISOString()
      }));

      logger.info({ 
        count: transactionsWithParsedMetadata.length,
        msg: 'Retrieved parked transactions'
      });

      return transactionsWithParsedMetadata;
    } catch (error) {
      logger.error({ 
        msg: 'Failed to retrieve parked transactions', 
        error: error.message 
      });
      throw error;
    }
  }

  /**
   * Updates the metadata of an active transaction.
   * @param {number} transactionId - The ID of the transaction to update.
   * @param {object} metadata - The new metadata object.
   * @param {number} userId - The ID of the user performing the update.
   * @param {boolean} updateTimestamp - Whether to update the updated_at timestamp (default: false).
   * @returns {Promise<object>} The updated transaction object.
   */
  async updateTransactionMetadata(transactionId, metadata, userId, updateTimestamp = false) {
    logger.info({ 
      service: 'TransactionManagementService', 
      function: 'updateTransactionMetadata', 
      transactionId, 
      metadata, 
      userId,
      updateTimestamp
    });

    try {
      // Find the existing transaction
      const existingTransaction = await db('active_transactions')
        .where({ id: transactionId, status: 'active' })
        .first();

      if (!existingTransaction) {
        throw new Error(`Active transaction with ID ${transactionId} not found`);
      }

      // Update the transaction metadata
      // Note: Table availability is already checked in assignTableNumber before calling this function
      const updateData = { metadata: JSON.stringify(metadata) };
      if (updateTimestamp) {
        updateData.updated_at = new Date().toISOString();
      }
      
      const [updatedTransaction] = await db('active_transactions')
        .where({ id: transactionId })
        .update(updateData)
        .returning('*');

      // Log the fiscal event for metadata update
      const fiscalLogResult = await loggingService.logFiscalEvent('updateTransactionMetadata', userId, {
        transaction_uuid: existingTransaction.uuid,
        old_metadata: existingTransaction.metadata,
        new_metadata: JSON.stringify(metadata)
      });

      if (!fiscalLogResult.success) {
        logger.error({ 
          msg: 'Failed to create fiscal log for metadata update', 
          error: fiscalLogResult.error,
          transactionId 
        });
      }

      logger.info({ 
        msg: 'Transaction metadata updated successfully', 
        transactionId 
      });

      return {
        ...updatedTransaction,
        metadata: JSON.parse(updatedTransaction.metadata)
      };
    } catch (error) {
      logger.error({ 
        msg: 'Failed to update transaction metadata', 
        error: error.message,
        transactionId
      });
      throw error;
    }
  }

  /**
   * Checks if a table number is already in use by a parked transaction.
   * @param {string} tableNumber - The table number to check.
   * @param {number} excludeTransactionId - Optional transaction ID to exclude from check.
   * @returns {Promise<boolean>} True if table number is already in use.
   */
  async checkTableNumberInUse(tableNumber, excludeTransactionId = null) {
    logger.info({ 
      service: 'TransactionManagementService', 
      function: 'checkTableNumberInUse', 
      tableNumber,
      excludeTransactionId
    });

    try {
      let query = db('active_transactions')
        .where('status', 'parked')
        .whereRaw("JSON_EXTRACT(metadata, '$.table') = ?", [tableNumber]);
      
      if (excludeTransactionId) {
        query = query.whereNot('id', excludeTransactionId);
      }
      
      const existingTransaction = await query.first();
      const isInUse = !!existingTransaction;
      
      logger.info({ 
        msg: 'Table number availability checked', 
        tableNumber,
        isInUse,
        existingTransactionId: existingTransaction ? existingTransaction.id : null
      });

      return isInUse;
    } catch (error) {
      logger.error({ 
        msg: 'Failed to check table number availability', 
        error: error.message,
        tableNumber
      });
      throw error;
    }
  }

}

// Export a singleton instance of the service
module.exports = new TransactionManagementService();

--- File: /packages/backend/src/utils/FileCallbackHandler.js ---

// File: packages/backend/src/utils/FileCallbackHandler.js
const fs = require('fs');
const { BaseCallbackHandler } = require("@langchain/core/callbacks");

class FileCallbackHandler extends BaseCallbackHandler {
  name = "FileCallbackHandler";

  constructor(logPath = 'logs/langchain_trace.log') {
    super();
    // Ensure log directory exists
    const logDir = logPath.substring(0, logPath.lastIndexOf('/'));
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    this.logStream = fs.createWriteStream(logPath, { flags: 'a' });
    this.log(`--- New Session: ${new Date().toISOString()} ---`);
  }

  log(message) {
    this.logStream.write(message + '\n');
  }

  async handleChainStart(chain, inputs) {
    this.log(`[CHAIN_START] Name: ${chain.name} | Inputs: ${JSON.stringify(inputs)}`);
  }

  async handleChainEnd(outputs) {
    this.log(`[CHAIN_END] Outputs: ${JSON.stringify(outputs)}`);
  }

  async handleLLMStart(llm, prompts) {
    this.log(`[LLM_START] Model: ${JSON.stringify(llm.name)} | Prompts: ${JSON.stringify(prompts)}`);
  }

  async handleLLMEnd(output) {
    this.log(`[LLM_END] Output: ${JSON.stringify(output)}`);
  }
  
  async handleLLMError(err) {
    this.log(`[LLM_ERROR] Error: ${JSON.stringify(err)}`);
  }

  async handleToolStart(tool, input) {
    this.log(`[TOOL_START] Name: ${tool.name} | Input: ${input}`);
  }

  async handleToolEnd(output) {
    this.log(`[TOOL_END] Output: ${output}`);
  }
  
  async handleToolError(err) {
    this.log(`[TOOL_ERROR] Error: ${JSON.stringify(err)}`);
  }

  async handleAgentAction(action) {
    this.log(`[AGENT_ACTION] Action: ${JSON.stringify(action)}`);
  }
}

module.exports = { FileCallbackHandler };

--- File: /packages/backend/src/utils/geminiErrorHandler.js ---

// File: /packages/backend/src/utils/geminiErrorHandler.js

/**
 * Утилита для обработки и классификации ошибок Gemini API
 * Совместима с новым SDK @google/genai
 */

/**
 * Типы ошибок Gemini API (обновлено согласно официальной документации)
 */
const GEMINI_ERROR_TYPES = {
  RATE_LIMIT: 'RATE_LIMIT',              // Превышен лимит запросов (429)
  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',       // Превышена квота API
  INVALID_API_KEY: 'INVALID_API_KEY',     // Неверный API ключ (401)
  PERMISSION_DENIED: 'PERMISSION_DENIED', // Доступ запрещен (403)
  INVALID_ARGUMENT: 'INVALID_ARGUMENT',   // Неверные параметры запроса (400)
  NETWORK_ERROR: 'NETWORK_ERROR',         // Сетевая ошибка
  SERVICE_ERROR: 'SERVICE_ERROR',         // Ошибка сервиса Google (5xx)
  CONTENT_FILTER: 'CONTENT_FILTER',       // Контент заблокирован фильтром
  TIMEOUT_ERROR: 'TIMEOUT_ERROR',         // Превышен таймаут (504)
  CANCELLED: 'CANCELLED',                 // Запрос отменен (499)
  RECITATION: 'RECITATION',               // Остановка из-за сходства с данными
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'          // Неизвестная ошибка
};

/**
 * Официальные статус коды Google Cloud API для Gemini
 */
const OFFICIAL_ERROR_CODES = {
  400: 'INVALID_ARGUMENT',
  401: 'UNAUTHENTICATED', 
  403: 'PERMISSION_DENIED',
  429: 'RESOURCE_EXHAUSTED',
  499: 'CANCELLED',
  500: 'INTERNAL',
  503: 'UNAVAILABLE', 
  504: 'DEADLINE_EXCEEDED'
};

/**
 * Паттерны для идентификации ошибок по сообщению (обновлено)
 */
const ERROR_PATTERNS = {
  [GEMINI_ERROR_TYPES.RATE_LIMIT]: [
    /rate limit exceeded/i,
    /too many requests/i,
    /resource exhausted/i,
    /quota.*exceeded.*requests/i,
    /RESOURCE_EXHAUSTED/i
  ],
  [GEMINI_ERROR_TYPES.QUOTA_EXCEEDED]: [
    /quota exceeded/i,
    /billing account/i,
    /usage limit/i,
    /free tier.*exceeded/i,
    /quota.*exceeded(?!.*requests)/i
  ],
  [GEMINI_ERROR_TYPES.INVALID_API_KEY]: [
    /invalid api key/i,
    /authentication failed/i,
    /UNAUTHENTICATED/i,
    /api key not valid/i,
    /unauthorized/i
  ],
  [GEMINI_ERROR_TYPES.PERMISSION_DENIED]: [
    /permission denied/i,
    /PERMISSION_DENIED/i,
    /access denied/i,
    /forbidden/i,
    /organization.*policy/i,
    /allowlisting/i
  ],
  [GEMINI_ERROR_TYPES.INVALID_ARGUMENT]: [
    /invalid argument/i,
    /INVALID_ARGUMENT/i,
    /malformed/i,
    /FAILED_PRECONDITION/i,
    /missing required field/i
  ],
  [GEMINI_ERROR_TYPES.NETWORK_ERROR]: [
    /network error/i,
    /connection.*failed/i,
    /timeout/i,
    /econnreset/i,
    /enotfound/i
  ],
  [GEMINI_ERROR_TYPES.SERVICE_ERROR]: [
    /internal server error/i,
    /service unavailable/i,
    /bad gateway/i,
    /temporarily unavailable/i,
    /INTERNAL/i,
    /UNAVAILABLE/i,
    /server error/i
  ],
  [GEMINI_ERROR_TYPES.CONTENT_FILTER]: [
    /content filter/i,
    /safety filter/i,
    /inappropriate content/i,
    /blocked.*policy/i,
    /safety.*setting/i,
    /BlockedReason/i
  ],
  [GEMINI_ERROR_TYPES.TIMEOUT_ERROR]: [
    /deadline exceeded/i,
    /DEADLINE_EXCEEDED/i,
    /request timeout/i
  ],
  [GEMINI_ERROR_TYPES.CANCELLED]: [
    /cancelled/i,
    /CANCELLED/i,
    /request.*cancelled/i
  ],
  [GEMINI_ERROR_TYPES.RECITATION]: [
    /recitation/i,
    /RECITATION/i,
    /resembles.*data/i
  ]
};

/**
 * Пользовательские сообщения для каждого типа ошибки (обновлено)
 */
const USER_MESSAGES = {
  [GEMINI_ERROR_TYPES.RATE_LIMIT]: {
    ru: "⚠️ Превышен лимит запросов к AI. Пожалуйста, подождите немного и попробуйте снова.",
    en: "⚠️ AI request limit exceeded. Please wait a moment and try again."
  },
  [GEMINI_ERROR_TYPES.QUOTA_EXCEEDED]: {
    ru: "⚠️ Исчерпана бесплатная квота AI на сегодня. Для продолжения работы рассмотрите возможность приобретения платного тарифа.",
    en: "⚠️ Daily AI quota exhausted. Consider upgrading to a paid plan to continue."
  },
  [GEMINI_ERROR_TYPES.INVALID_API_KEY]: {
    ru: "❌ Проблема с API ключом. Обратитесь к администратору системы.",
    en: "❌ API key issue. Contact system administrator."
  },
  [GEMINI_ERROR_TYPES.PERMISSION_DENIED]: {
    ru: "🚫 Доступ запрещен. Проверьте права доступа к модели или обратитесь к администратору.",
    en: "🚫 Access denied. Check model permissions or contact administrator."
  },
  [GEMINI_ERROR_TYPES.INVALID_ARGUMENT]: {
    ru: "⚠️ Некорректный запрос. Проверьте параметры и попробуйте снова.",
    en: "⚠️ Invalid request. Check parameters and try again."
  },
  [GEMINI_ERROR_TYPES.NETWORK_ERROR]: {
    ru: "🌐 Проблема с сетевым подключением. Проверьте интернет-соединение.",
    en: "🌐 Network connection issue. Check your internet connection."
  },
  [GEMINI_ERROR_TYPES.SERVICE_ERROR]: {
    ru: "🔧 Временная проблема с сервисом AI. Попробуйте позже.",
    en: "🔧 Temporary AI service issue. Try again later."
  },
  [GEMINI_ERROR_TYPES.CONTENT_FILTER]: {
    ru: "🛡️ Запрос заблокирован системой безопасности AI. Попробуйте перефразировать.",
    en: "🛡️ Request blocked by AI safety system. Try rephrasing."
  },
  [GEMINI_ERROR_TYPES.TIMEOUT_ERROR]: {
    ru: "⏱️ Превышено время ожидания. Попробуйте упростить запрос.",
    en: "⏱️ Request timeout. Try simplifying your request."
  },
  [GEMINI_ERROR_TYPES.CANCELLED]: {
    ru: "🚫 Запрос был отменен. Попробуйте снова.",
    en: "🚫 Request was cancelled. Try again."
  },
  [GEMINI_ERROR_TYPES.RECITATION]: {
    ru: "📝 Генерация остановлена из-за сходства с существующими данными. Измените запрос.",
    en: "📝 Generation stopped due to similarity with existing data. Modify your request."
  },
  [GEMINI_ERROR_TYPES.UNKNOWN_ERROR]: {
    ru: "❓ Неизвестная ошибка AI. Попробуйте снова или обратитесь к поддержке.",
    en: "❓ Unknown AI error. Try again or contact support."
  }
};

/**
 * Определяет тип ошибки по объекту ошибки (обновлено для @google/genai)
 * @param {Error} error - Объект ошибки
 * @returns {string} - Тип ошибки из GEMINI_ERROR_TYPES
 */
function classifyGeminiError(error) {
  if (!error) return GEMINI_ERROR_TYPES.UNKNOWN_ERROR;

  const errorMessage = error.message || '';
  const errorCode = error.code || error.status || error.statusCode || '';
  
  // Проверяем по HTTP статус коду (согласно официальной документации)
  const numericCode = parseInt(errorCode);
  
  if (numericCode === 429) {
    return GEMINI_ERROR_TYPES.RATE_LIMIT;
  }
  if (numericCode === 401) {
    return GEMINI_ERROR_TYPES.INVALID_API_KEY;
  }
  if (numericCode === 403) {
    return GEMINI_ERROR_TYPES.PERMISSION_DENIED;
  }
  if (numericCode === 400) {
    return GEMINI_ERROR_TYPES.INVALID_ARGUMENT;
  }
  if (numericCode === 499) {
    return GEMINI_ERROR_TYPES.CANCELLED;
  }
  if (numericCode === 504) {
    return GEMINI_ERROR_TYPES.TIMEOUT_ERROR;
  }
  if (numericCode >= 500 && numericCode < 600) {
    return GEMINI_ERROR_TYPES.SERVICE_ERROR;
  }

  // Проверяем по паттернам в сообщении об ошибке
  for (const [errorType, patterns] of Object.entries(ERROR_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(errorMessage)) {
        return errorType;
      }
    }
  }

  // Проверяем специфичные свойства error объекта для @google/genai
  if (error.name === 'GoogleGenerativeAIError') {
    // Это специфичная ошибка от нового SDK
    if (errorMessage.includes('content filtering')) {
      return GEMINI_ERROR_TYPES.CONTENT_FILTER;
    }
  }

  return GEMINI_ERROR_TYPES.UNKNOWN_ERROR;
}

/**
 * Проверяет, является ли ошибка временной (требует повтора)
 * @param {string} errorType - Тип ошибки
 * @returns {boolean} - true если ошибка временная
 */
function isTemporaryError(errorType) {
  return [
    GEMINI_ERROR_TYPES.RATE_LIMIT,
    GEMINI_ERROR_TYPES.NETWORK_ERROR,
    GEMINI_ERROR_TYPES.SERVICE_ERROR,
    GEMINI_ERROR_TYPES.TIMEOUT_ERROR
  ].includes(errorType);
}

/**
 * Получает рекомендуемую задержку для повтора запроса
 * @param {string} errorType - Тип ошибки
 * @returns {number} - Задержка в секундах
 */
function getRetryDelay(errorType) {
  const delays = {
    [GEMINI_ERROR_TYPES.RATE_LIMIT]: 60,        // 1 минута для rate limit
    [GEMINI_ERROR_TYPES.NETWORK_ERROR]: 5,      // 5 секунд для сети
    [GEMINI_ERROR_TYPES.SERVICE_ERROR]: 30,     // 30 секунд для сервера
    [GEMINI_ERROR_TYPES.TIMEOUT_ERROR]: 10      // 10 секунд для таймаута
  };
  
  return delays[errorType] || 5;
}

/**
 * Получает пользовательское сообщение для типа ошибки
 * @param {string} errorType - Тип ошибки
 * @param {string} language - Язык ('ru' или 'en')
 * @returns {string} - Сообщение для пользователя
 */
function getUserMessage(errorType, language = 'ru') {
  const messages = USER_MESSAGES[errorType];
  if (!messages) {
    return USER_MESSAGES[GEMINI_ERROR_TYPES.UNKNOWN_ERROR][language];
  }
  return messages[language] || messages.ru;
}

/**
 * Основная функция обработки ошибок Gemini API
 * @param {Error} error - Объект ошибки
 * @param {Object} options - Опции обработки
 * @returns {Object} - Результат обработки ошибки
 */
function handleGeminiError(error, options = {}) {
  const { language = 'ru', includeRetryInfo = false } = options;
  
  const errorType = classifyGeminiError(error);
  const userMessage = getUserMessage(errorType, language);
  const isTemporary = isTemporaryError(errorType);
  const retryDelay = getRetryDelay(errorType);

  const result = {
    errorType,
    isTemporary,
    userMessage,
    originalError: error.message || 'Unknown error',
    httpStatus: error.code || error.status || error.statusCode
  };

  if (includeRetryInfo && isTemporary) {
    result.retryDelay = retryDelay;
    result.retryMessage = language === 'ru' 
      ? `Попробуйте снова через ${retryDelay} секунд.`
      : `Try again in ${retryDelay} seconds.`;
  }

  return result;
}

/**
 * Создает структурированный лог для ошибки Gemini API
 * @param {Error} error - Объект ошибки
 * @param {Object} context - Контекст (operation, userId и т.д.)
 * @returns {Object} - Объект для логирования
 */
function createGeminiErrorLog(error, context = {}) {
  const errorType = classifyGeminiError(error);
  const isTemporary = isTemporaryError(errorType);

  return {
    level: isTemporary ? 'warn' : 'error',
    msg: isTemporary 
      ? '🚦 Gemini API временная ошибка'
      : '❌ Gemini API критическая ошибка',
    geminiErrorType: errorType,
    isTemporary,
    userMessage: getUserMessage(errorType, 'ru'),
    originalError: error.message,
    httpStatus: error.code || error.status || error.statusCode,
    retryDelay: getRetryDelay(errorType),
    sdkVersion: '@google/genai', // Указываем используемый SDK
    ...context
  };
}

module.exports = {
  GEMINI_ERROR_TYPES,
  classifyGeminiError,
  isTemporaryError,
  getRetryDelay,
  getUserMessage,
  handleGeminiError,
  createGeminiErrorLog
};

--- File: /packages/backend/src/utils/levenshtein.js ---

// File: /packages/backend/src/utils/levenshtein.js

/**
 * Calculate Levenshtein distance between two strings
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} - Edit distance between the strings
 */
function calculateLevenshtein(str1, str2) {
  // Convert to lowercase for case-insensitive comparison
  const a = str1.toLowerCase();
  const b = str2.toLowerCase();
  
  const len1 = a.length;
  const len2 = b.length;
  
  // Create matrix
  const matrix = [];
  
  // Initialize first row and column
  for (let i = 0; i <= len2; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= len1; j++) {
    matrix[0][j] = j;
  }
  
  // Fill the matrix
  for (let i = 1; i <= len2; i++) {
    for (let j = 1; j <= len1; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          matrix[i][j - 1] + 1,     // insertion
          matrix[i - 1][j] + 1      // deletion
        );
      }
    }
  }
  
  return matrix[len2][len1];
}

/**
 * Calculate normalized Levenshtein distance (0-1 scale)
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} - Normalized distance between 0 (identical) and 1 (completely different)
 */
function normalizedLevenshtein(str1, str2) {
  const maxLength = Math.max(str1.length, str2.length);
  if (maxLength === 0) return 0;
  
  const distance = calculateLevenshtein(str1, str2);
  return distance / maxLength;
}

/**
 * Calculate similarity percentage based on Levenshtein distance
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} - Similarity percentage (0-100)
 */
function levenshteinSimilarity(str1, str2) {
  const normalized = normalizedLevenshtein(str1, str2);
  return Math.round((1 - normalized) * 100);
}

/**
 * Check if two strings are similar based on Levenshtein distance threshold
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @param {number} threshold - Maximum allowed edit distance (default: 2)
 * @returns {boolean} - True if strings are similar
 */
function isSimilar(str1, str2, threshold = 2) {
  return calculateLevenshtein(str1, str2) <= threshold;
}

module.exports = {
  calculateLevenshtein,
  normalizedLevenshtein,
  levenshteinSimilarity,
  isSimilar
};

--- File: /packages/backend/test-sample-enhanced-mdf.json ---

{
  "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
  "company_details": {
    "company_unique_identifier": 1,
    "company_full_name": "Test Store for Phase 3",
    "meta_information": {
      "format_version": "2.0.0",
      "date_generated": "2025-07-06T14:30:00.000Z",
      "generated_by": "phase3-test-script",
      "default_currency_symbol": "€",
      "default_language": "de"
    },
    "global_configurations": {
      "tax_rates_definitions": [
        {
          "tax_rate_unique_identifier": 1,
          "tax_rate_names": { "de": "Standard (19%)" },
          "rate_percentage": 19.0,
          "fiscal_mapping_type": "NORMAL"
        }
      ],
      "main_groups_definitions": [],
      "payment_methods_definitions": [],
      "promotions_definitions": [],
      "workflows": [],
      "integrations": {},
      "security_settings": {}
    },
    "branches": [
      {
        "branch_unique_identifier": 1,
        "branch_names": { "de": "Hauptfiliale" },
        "branch_address": "Test Street 1",
        "point_of_sale_devices": [
          {
            "pos_device_unique_identifier": 1,
            "pos_device_names": { "de": "Kasse 1" },
            "pos_device_type": "DESKTOP",
            "pos_device_external_number": 1,
            "pos_device_settings": {},
            "categories_for_this_pos": [
              {
                "category_unique_identifier": 1,
                "category_names": { "de": "Gadgets" },
                "category_type": "other",
                "audit_trail": {}
              },
              {
                "category_unique_identifier": 2,
                "category_names": { "de": "Drinkware" },
                "category_type": "other",
                "audit_trail": {}
              },
              {
                "category_unique_identifier": 3,
                "category_names": { "de": "Getränke" },
                "category_type": "drink",
                "audit_trail": {}
              }
            ],
            "items_for_this_pos": [
              {
                "item_unique_identifier": 1001,
                "display_names": {
                  "menu": { "de": "Super Widget" },
                  "button": { "de": "Super Widget" },
                  "receipt": { "de": "Super Widget" }
                },
                "item_price_value": 19.99,
                "pricing_schedules": [],
                "availability_schedule": { "always_available": true },
                "associated_category_unique_identifier": 1,
                "additional_item_attributes": {
                  "description": "Ein hochmodernes Super Widget mit erweiterten Funktionen für den täglichen Gebrauch",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": { "is_sellable": true },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1002,
                "display_names": {
                  "menu": { "de": "Eco Mug" },
                  "button": { "de": "Eco Mug" },
                  "receipt": { "de": "Eco Mug" }
                },
                "item_price_value": 12.50,
                "pricing_schedules": [],
                "availability_schedule": { "always_available": true },
                "associated_category_unique_identifier": 2,
                "additional_item_attributes": {
                  "description": "Umweltfreundliche Tasse aus recyceltem Material, perfekt für heiße Getränke wie Kaffee",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": { "is_sellable": true },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1003,
                "display_names": {
                  "menu": { "de": "Kaffee Espresso" },
                  "button": { "de": "Espresso" },
                  "receipt": { "de": "Kaffee Espresso" }
                },
                "item_price_value": 2.20,
                "pricing_schedules": [],
                "availability_schedule": { "always_available": true },
                "associated_category_unique_identifier": 3,
                "additional_item_attributes": {
                  "description": "Authentischer italienischer Espresso aus hochwertigen Arabica-Bohnen",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": { "is_sellable": true },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1004,
                "display_names": {
                  "menu": { "de": "Premium Coffee Cup" },
                  "button": { "de": "Coffee Cup" },
                  "receipt": { "de": "Premium Coffee Cup" }
                },
                "item_price_value": 8.75,
                "pricing_schedules": [],
                "availability_schedule": { "always_available": true },
                "associated_category_unique_identifier": 2,
                "additional_item_attributes": {
                  "description": "Hochwertige Kaffeetasse aus Keramik, ideal für heißen Kaffee und andere warme Getränke",
                  "allergens": [],
                  "dietary_info": []
                },
                "item_flags": { "is_sellable": true },
                "audit_trail": {}
              }
            ]
          }
        ]
      }
    ]
  }
}

--- File: /packages/backend/test-sample-mdf.json ---

{
  "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
  "company_details": {
    "company_unique_identifier": 1,
    "company_full_name": "Test Restaurant",
    "meta_information": {
      "format_version": "2.0.0",
      "date_generated": "2025-07-06T14:00:27.526Z",
      "generated_by": "test-script",
      "default_currency_symbol": "€",
      "default_language": "de"
    },
    "global_configurations": {
      "tax_rates_definitions": [
        {
          "tax_rate_unique_identifier": 1,
          "tax_rate_names": {
            "de": "Standard (19%)"
          },
          "rate_percentage": 19,
          "fiscal_mapping_type": "NORMAL"
        }
      ],
      "main_groups_definitions": [],
      "payment_methods_definitions": [],
      "promotions_definitions": [],
      "workflows": [],
      "integrations": {},
      "security_settings": {}
    },
    "branches": [
      {
        "branch_unique_identifier": 1,
        "branch_names": {
          "de": "Hauptfiliale"
        },
        "branch_address": "Test Street 1",
        "point_of_sale_devices": [
          {
            "pos_device_unique_identifier": 1,
            "pos_device_names": {
              "de": "Kasse 1"
            },
            "pos_device_type": "DESKTOP",
            "pos_device_external_number": 1,
            "pos_device_settings": {},
            "categories_for_this_pos": [
              {
                "category_unique_identifier": 1,
                "category_names": {
                  "de": "Vorspeisen"
                },
                "category_type": "food",
                "audit_trail": {}
              },
              {
                "category_unique_identifier": 2,
                "category_names": {
                  "de": "Hauptgerichte"
                },
                "category_type": "food",
                "audit_trail": {}
              }
            ],
            "items_for_this_pos": [
              {
                "item_unique_identifier": 1001,
                "display_names": {
                  "menu": {
                    "de": "Bruschetta della Casa"
                  },
                  "button": {
                    "de": "Bruschetta"
                  },
                  "receipt": {
                    "de": "Bruschetta della Casa"
                  }
                },
                "item_price_value": 6.5,
                "pricing_schedules": [],
                "availability_schedule": {
                  "always_available": true
                },
                "associated_category_unique_identifier": 1,
                "additional_item_attributes": {
                  "description": "Geröstetes Ciabatta-Brot mit frischen Tomaten, Knoblauch, Basilikum und nativem Olivenöl extra",
                  "allergens": [
                    "gluten"
                  ],
                  "dietary_info": [
                    "vegetarian"
                  ]
                },
                "item_flags": {
                  "is_sellable": true
                },
                "audit_trail": {}
              },
              {
                "item_unique_identifier": 1002,
                "display_names": {
                  "menu": {
                    "de": "Pizza Margherita"
                  },
                  "button": {
                    "de": "Margherita"
                  },
                  "receipt": {
                    "de": "Pizza Margherita"
                  }
                },
                "item_price_value": 9,
                "pricing_schedules": [
                  {
                    "schedule_id": "variant_klein",
                    "price": 7
                  },
                  {
                    "schedule_id": "variant_gross",
                    "price": 11
                  }
                ],
                "availability_schedule": {
                  "always_available": true
                },
                "associated_category_unique_identifier": 2,
                "additional_item_attributes": {
                  "description": "Hausgemachter Teig mit San Marzano Tomaten, Mozzarella di Bufala und frischem Basilikum",
                  "allergens": [
                    "gluten",
                    "dairy"
                  ],
                  "dietary_info": [
                    "vegetarian"
                  ]
                },
                "item_flags": {
                  "is_sellable": true
                },
                "audit_trail": {}
              }
            ]
          }
        ]
      }
    ]
  }
}

--- File: /packages/backend/test_agent_search_e2e.js ---

#!/usr/bin/env node

// Load environment variables
require('dotenv').config({ path: '../../.env' });

/**
 * End-to-End Test for Phase 3: LLM Agent + Hybrid Search Integration
 * 
 * This test validates the complete workflow from natural language queries
 * to the agent's final response using the integrated hybrid search system.
 * 
 * Test scenarios:
 * - Exact match tests
 * - Typo/Levenshtein correction tests  
 * - Semantic search tests
 * - No match handling tests
 * - Contextual follow-up conversation tests
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

const { sendMessage } = require('./src/services/llm.service.js');
const fs = require('fs').promises;
const path = require('path');

class AgentSearchE2ETest {
  constructor() {
    this.testsPassed = 0;
    this.testsFailed = 0;
    this.results = [];
    this.chatHistory = []; // Shared conversation history
  }

  async runTests() {
    console.log('🧪 Starting Phase 3 End-to-End Agent Search Tests\n');
    console.log('⚠️  Note: These tests require:');
    console.log('   • Working GEMINI_API_KEY in environment');
    console.log('   • Database imported with: node src/lib/cli.js import-mdf test-sample-enhanced-mdf.json --force');
    console.log('   • The test data includes: Super Widget (€19.99), Eco Mug (€12.50), Coffee Cup (€8.75)\n');
    
    try {
      // Test 1: Exact match test
      console.log('📝 Test 1: Exact Match Test');
      await this.testExactMatch();

      // Test 2: Typo/Levenshtein correction test
      console.log('\n📝 Test 2: Typo/Levenshtein Correction Test');
      await this.testTypoCorrection();

      // Test 3: Semantic search test
      console.log('\n📝 Test 3: Semantic Search Test');
      await this.testSemanticSearch();

      // Test 4: No match test
      console.log('\n📝 Test 4: No Match Test');
      await this.testNoMatch();

      // Test 5: Contextual follow-up test
      console.log('\n📝 Test 5: Contextual Follow-up Test');
      await this.testContextualFollowup();

      // Test 6: Native search functionality test
      console.log('\n📝 Test 6: Native Search Functionality Test');
      await this.testNativeSearch();

      // Summary
      this.printSummary();

    } catch (error) {
      console.error('❌ Test execution failed:', error.message);
      if (error.message.includes('API key') || error.message.includes('GEMINI_API_KEY')) {
        console.log('\n💡 Hint: Make sure GEMINI_API_KEY is set in your environment or .env file');
      }
      process.exit(1);
    }
  }

  async testExactMatch() {
    try {
      const query = "Найди Super Widget";
      const expectedKeywords = ["Super Widget", "19.99"];
      
      console.log(`   User: "${query}"`);
      
      const response = await sendMessage(query, this.chatHistory);
      this.chatHistory = response.history || [];
      
      console.log(`   Agent: "${response.text}"`);
      
      // Check if response contains expected keywords
      const containsProductName = expectedKeywords.some(keyword => 
        response.text.toLowerCase().includes(keyword.toLowerCase())
      );
      
      this.assert(
        containsProductName,
        `Response should contain 'Super Widget' and price information. Got: "${response.text}"`
      );

      this.assert(
        !response.isTemporary && !response.errorType,
        'Response should not contain API errors'
      );

      console.log('✅ Exact match test passed');
      
    } catch (error) {
      console.log('❌ Exact match test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testTypoCorrection() {
    try {
      const query = "supr widge";
      const expectedSuggestion = "Super Widget";
      
      console.log(`   User: "${query}"`);
      
      const response = await sendMessage(query, this.chatHistory);
      this.chatHistory = response.history || [];
      
      console.log(`   Agent: "${response.text}"`);
      
      // Check if response suggests the correct product despite typo
      const containsSuggestion = response.text.toLowerCase().includes(expectedSuggestion.toLowerCase());
      
      this.assert(
        containsSuggestion,
        `Response should suggest 'Super Widget' for typo. Got: "${response.text}"`
      );

      console.log('✅ Typo correction test passed');
      
    } catch (error) {
      console.log('❌ Typo correction test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testSemanticSearch() {
    try {
      const query = "a container for hot coffee";
      const expectedSuggestion = "Eco Mug";
      
      console.log(`   User: "${query}"`);
      
      const response = await sendMessage(query, this.chatHistory);
      this.chatHistory = response.history || [];
      
      console.log(`   Agent: "${response.text}"`);
      
      // Check if response suggests semantically relevant product
      const containsSemanticMatch = response.text.toLowerCase().includes(expectedSuggestion.toLowerCase()) ||
                                   response.text.toLowerCase().includes("mug") ||
                                   response.text.toLowerCase().includes("cup");
      
      this.assert(
        containsSemanticMatch,
        `Response should suggest semantically relevant products for 'container for hot coffee'. Got: "${response.text}"`
      );

      console.log('✅ Semantic search test passed');
      
    } catch (error) {
      console.log('❌ Semantic search test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testNoMatch() {
    try {
      const query = "find a flying car";
      const expectedResponses = ["не найден", "not found", "couldn't find", "no results"];
      
      console.log(`   User: "${query}"`);
      
      const response = await sendMessage(query, this.chatHistory);
      this.chatHistory = response.history || [];
      
      console.log(`   Agent: "${response.text}"`);
      
      // Check if response appropriately handles no match
      const containsNoMatchResponse = expectedResponses.some(phrase => 
        response.text.toLowerCase().includes(phrase)
      );
      
      this.assert(
        containsNoMatchResponse,
        `Response should indicate no match found for 'flying car'. Got: "${response.text}"`
      );

      console.log('✅ No match test passed');
      
    } catch (error) {
      console.log('❌ No match test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testContextualFollowup() {
    try {
      // Step 1: Search for a product
      const step1Query = "ищи кружку";
      
      console.log(`   Step 1 User: "${step1Query}"`);
      
      const step1Response = await sendMessage(step1Query, this.chatHistory);
      this.chatHistory = step1Response.history || [];
      
      console.log(`   Step 1 Agent: "${step1Response.text}"`);
      
      // Step 2: Ask about price in context
      const step2Query = "сколько она стоит?";
      
      console.log(`   Step 2 User: "${step2Query}"`);
      
      const step2Response = await sendMessage(step2Query, this.chatHistory);
      this.chatHistory = step2Response.history || [];
      
      console.log(`   Step 2 Agent: "${step2Response.text}"`);
      
      // Check if the agent understood the context and provided price
      const containsPriceInfo = /\d+[.,]\d+/.test(step2Response.text) || 
                               step2Response.text.includes('€') ||
                               step2Response.text.includes('цена') ||
                               step2Response.text.includes('стоит') ||
                               step2Response.text.includes('price');
      
      this.assert(
        containsPriceInfo,
        `Step 2 response should contain price information based on context. Got: "${step2Response.text}"`
      );

      console.log('✅ Contextual follow-up test passed');
      
    } catch (error) {
      console.log('❌ Contextual follow-up test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testNativeSearch() {
    try {
      // Test native search functionality with a query that should trigger web search
      const query = "Tell me about the latest trends in coffee brewing methods";
      
      console.log(`   User: "${query}"`);
      
      const response = await sendMessage(query, this.chatHistory);
      this.chatHistory = response.history || [];
      
      console.log(`   Agent: "${response.text}"`);
      
      // Check if response contains information that would likely come from web search
      const containsWebSearchInfo = response.text.toLowerCase().includes('coffee') ||
                                    response.text.toLowerCase().includes('brew') ||
                                    response.text.toLowerCase().includes('method') ||
                                    response.text.toLowerCase().includes('trend') ||
                                    response.text.length > 100; // Detailed response suggests web search
      
      this.assert(
        containsWebSearchInfo,
        `Response should contain detailed information about coffee brewing methods from web search. Got: "${response.text}"`
      );

      this.assert(
        !response.isTemporary && !response.errorType,
        'Response should not contain API errors'
      );

      console.log('✅ Native search test passed');
      
    } catch (error) {
      console.log('❌ Native search test failed:', error.message);
      this.testsFailed++;
    }
  }

  assert(condition, message) {
    if (condition) {
      this.testsPassed++;
      this.results.push({ status: 'PASS', message });
    } else {
      this.testsFailed++;
      this.results.push({ status: 'FAIL', message });
      throw new Error(message);
    }
  }

  printSummary() {
    console.log('\n' + '='.repeat(70));
    console.log('📊 PHASE 3 END-TO-END TEST SUMMARY');
    console.log('='.repeat(70));
    console.log(`✅ Tests Passed: ${this.testsPassed}`);
    console.log(`❌ Tests Failed: ${this.testsFailed}`);
    console.log(`📈 Success Rate: ${(this.testsPassed / (this.testsPassed + this.testsFailed) * 100).toFixed(1)}%`);
    
    if (this.testsFailed === 0) {
      console.log('\n🎉 Phase 3 End-to-End Test: SUCCESS');
      console.log('The LLM Agent + Hybrid Search integration is working perfectly!');
      console.log('\n🚀 Ready for Production Features:');
      console.log('• Natural language product searches');
      console.log('• Typo correction and semantic understanding');
      console.log('• Contextual conversations');
      console.log('• Multi-layered search fallbacks (FTS → Vector → Levenshtein)');
    } else {
      console.log('\n💥 Phase 3 End-to-End Test: PARTIAL SUCCESS');
      console.log('Some integration issues detected. Check the detailed output above.');
      console.log('\nPossible Issues:');
      console.log('• Missing test data in database');
      console.log('• GEMINI_API_KEY not configured');
      console.log('• Vector embeddings not generated');
    }
    
    console.log('\n📋 Detailed Results:');
    this.results.forEach((result, index) => {
      const icon = result.status === 'PASS' ? '✅' : '❌';
      console.log(`${icon} ${index + 1}. ${result.message}`);
    });

    console.log('\n📚 Test Conversation History:');
    this.chatHistory.forEach((msg, index) => {
      const role = msg.role === 'user' ? '👤 User' : '🤖 Agent';
      const content = Array.isArray(msg.parts) ? msg.parts.map(p => p.text).join('') : msg.parts;
      console.log(`${index + 1}. ${role}: "${content}"`);
    });
  }
}

// Run tests if called directly
if (require.main === module) {
  const test = new AgentSearchE2ETest();
  test.runTests().catch(error => {
    console.error('Test execution failed:', error);
    process.exit(1);
  });
}

module.exports = AgentSearchE2ETest;

--- File: /packages/backend/test_all_tools_stub.js ---

#!/usr/bin/env node

/**
 * Verification script for all scaffolded agent tools
 * This script tests that all new tools are properly registered and responding with mock data
 */

require('dotenv').config({ path: '../../.env' });
const { sendMessage } = require('./src/services/llm.service.js');

async function runStubTests() {
    console.log('🧪 Testing all scaffolded agent tools (stubs)...');
    console.log('='.repeat(60));
    
    const tests = [
        { 
            name: 'Create Product', 
            query: "create a product called 'Test Coffee' for 5.99 in 'Drinks'" 
        },
        { 
            name: 'Update Product', 
            query: "update the price of 'Test Coffee' to 6.49" 
        },
        { 
            name: 'Create Category', 
            query: "create a food category named 'Desserts'" 
        },
        { 
            name: 'Create Modifier', 
            query: "create a happy hour discount modifier of 20% for drinks" 
        },
        { 
            name: 'Sales Report', 
            query: "покажи отчет о продажах за сегодня" 
        },
        { 
            name: 'Top Items', 
            query: "what are the top 3 selling items this week?" 
        },
        { 
            name: 'Slow Moving Items', 
            query: "show me items that sold less than 5 times this month" 
        },
        { 
            name: 'System Health', 
            query: "check system status" 
        }
    ];

    let passedTests = 0;
    let failedTests = 0;

    for (const test of tests) {
        console.log(`\n--- Running test: ${test.name} ---`);
        console.log(`   Query: "${test.query}"`);
        
        try {
            const startTime = Date.now();
            const response = await sendMessage(test.query, []);
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            console.log(`   Agent Response: ${response.text}`);
            console.log(`   Duration: ${duration}ms`);
            
            let testPassed = false;
            
            // Special handling for Sales Report test (now uses real data)
            if (test.name === 'Sales Report') {
                const responseText = response.text.toLowerCase();
                // Check for real data indicators like revenue, transactions, etc.
                testPassed = responseText.includes('revenue') || 
                           responseText.includes('доход') || 
                           responseText.includes('transaction') ||
                           responseText.includes('транзакци') ||
                           responseText.includes('отчет') ||
                           responseText.includes('report') ||
                           responseText.includes('totalrevenue') ||
                           responseText.includes('transactioncount');
            } else {
                // For other tests, check if response contains mock data indicators
                testPassed = response.text.includes('(MOCK)') || 
                           response.text.includes('mock') || 
                           response.text.includes('Mock') ||
                           response.text.includes('успешно') ||
                           response.text.includes('successfully');
            }
            
            if (testPassed) {
                console.log(`   Result: ✅ PASS`);
                passedTests++;
            } else {
                console.log(`   Result: ❌ FAIL - Expected data not detected`);
                failedTests++;
            }
        } catch (error) {
            console.log(`   Result: ❌ FAIL - Error: ${error.message}`);
            failedTests++;
        }
    }

    console.log('\n' + '='.repeat(60));
    console.log(`🧪 Test Results Summary:`);
    console.log(`   ✅ Passed: ${passedTests}`);
    console.log(`   ❌ Failed: ${failedTests}`);
    console.log(`   📊 Total: ${passedTests + failedTests}`);
    
    if (failedTests === 0) {
        console.log(`\n🎉 All tests passed! The agent tool scaffolding is working correctly.`);
    } else {
        console.log(`\n⚠️  Some tests failed. Please check the tool implementations.`);
    }
    
    console.log('\nImplementation Status:');
    console.log('✅ getSalesReport - IMPLEMENTED with real database logic');
    console.log('⏳ Other tools - Still using stub implementations');
    console.log('\nNext steps:');
    console.log('1. Replace remaining stub implementations with real business logic');
    console.log('2. Connect remaining tools to actual database operations');
    console.log('3. Add proper error handling and validation');
    console.log('4. Update tool descriptions based on actual functionality');
    
    process.exit(failedTests === 0 ? 0 : 1);
}

// Handle graceful shutdown
process.on('SIGINT', () => {
    console.log('\n\n🛑 Test interrupted by user');
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});

// Run the tests
runStubTests().catch(error => {
    console.error('💥 Test runner failed:', error);
    process.exit(1);
});

--- File: /packages/backend/test_context_dialog.js ---

// Test file for improved dialog context handling
require('dotenv').config({ path: '../../.env' });

const { sendMessage } = require('./src/services/llm.service');

/**
 * Test dialog context with follow-up questions
 */
async function testDialogContext() {
  console.log('🧪 TESTING IMPROVED DIALOG CONTEXT\n');

  try {
    let chatHistory = [];
    
    // First message: Search for a product
    console.log('👤 User: "such mug"');
    const response1 = await sendMessage('such mug', chatHistory);
    chatHistory = response1.history;
    console.log('🤖 AI:', response1.text);
    console.log();

    // Second message: Ask about its price (should use context)
    console.log('👤 User: "zeig sein preis" (show its price)');
    const response2 = await sendMessage('zeig sein preis', chatHistory);
    chatHistory = response2.history;
    console.log('🤖 AI:', response2.text);
    console.log();

    // Third message: Ask about its category (should use context)
    console.log('👤 User: "what category is it?"');
    const response3 = await sendMessage('what category is it?', chatHistory);
    chatHistory = response3.history;
    console.log('🤖 AI:', response3.text);
    console.log();

    // Fourth message: Different product search
    console.log('👤 User: "find widget"');
    const response4 = await sendMessage('find widget', chatHistory);
    chatHistory = response4.history;
    console.log('🤖 AI:', response4.text);
    console.log();

    // Fifth message: Ask about the new product (should refer to widget, not mug)
    console.log('👤 User: "how much does it cost?"');
    const response5 = await sendMessage('how much does it cost?', chatHistory);
    chatHistory = response5.history;
    console.log('🤖 AI:', response5.text);
    console.log();

    console.log('✅ Context dialog test completed!');
    console.log('\n📊 Test Summary:');
    console.log('- Searched for "mug" and found product');
    console.log('- Asked about price using context (German)');
    console.log('- Asked about category using context (English)');
    console.log('- Searched for different product "widget"');
    console.log('- Asked about price of widget (should refer to widget, not mug)');

  } catch (error) {
    console.error('❌ Test failed:', error.message);
  }
}

/**
 * Test multilingual conversation
 */
async function testMultilingualConversation() {
  console.log('\n\n🌍 TESTING MULTILINGUAL CONVERSATION\n');

  try {
    let chatHistory = [];
    
    // Russian request
    console.log('👤 User (Russian): "Найди товар кружка"');
    const response1 = await sendMessage('Найди товар кружка', chatHistory);
    chatHistory = response1.history;
    console.log('🤖 AI:', response1.text);
    console.log();

    // German follow-up
    console.log('👤 User (German): "wie viel kostet es?"');
    const response2 = await sendMessage('wie viel kostet es?', chatHistory);
    chatHistory = response2.history;
    console.log('🤖 AI:', response2.text);
    console.log();

    // English follow-up
    console.log('👤 User (English): "what is the category?"');
    const response3 = await sendMessage('what is the category?', chatHistory);
    chatHistory = response3.history;
    console.log('🤖 AI:', response3.text);
    console.log();

    console.log('✅ Multilingual test completed!');

  } catch (error) {
    console.error('❌ Multilingual test failed:', error.message);
  }
}

/**
 * Test JSON interpretation
 */
async function testJSONInterpretation() {
  console.log('\n\n📋 TESTING JSON INTERPRETATION\n');

  try {
    // Test what happens when we get structured data
    console.log('👤 User: "show me all products"');
    const response = await sendMessage('show me all products');
    console.log('🤖 AI:', response.text);
    console.log();

    console.log('✅ JSON interpretation test completed!');

  } catch (error) {
    console.error('❌ JSON interpretation test failed:', error.message);
  }
}

/**
 * Run all tests
 */
async function runAllTests() {
  console.log('🚀 STARTING CONTEXT AND CONVERSATION TESTS\n');
  console.log('=' .repeat(60));

  try {
    await testDialogContext();
    await testMultilingualConversation();
    await testJSONInterpretation();
    
    console.log('\n🎉 ALL TESTS COMPLETED SUCCESSFULLY!');
    console.log('\n📈 Improvements tested:');
    console.log('✓ Context awareness for follow-up questions');
    console.log('✓ Multilingual conversation handling');
    console.log('✓ JSON data interpretation and presentation');
    console.log('✓ Conversation history management');
    
  } catch (error) {
    console.error('\n💥 Test suite failed:', error);
  } finally {
    setTimeout(() => process.exit(0), 1000);
  }
}

// Run tests if called directly
if (require.main === module) {
  runAllTests();
}

module.exports = {
  testDialogContext,
  testMultilingualConversation,
  testJSONInterpretation,
  runAllTests
};

--- File: /packages/backend/test_create_product.js ---

#!/usr/bin/env node

/**
 * Test script for createProduct functionality
 */

require('dotenv').config({ path: '../../.env' });

async function testCreateProduct() {
    console.log('🧪 Testing createProduct functionality...');
    
    // Test 1: Direct service test
    console.log('\n1. Testing product service directly...');
    const { createProduct } = require('./src/services/product.service.js');
    
    try {
        const productData = {
            name: 'Test Latte',
            price: 3.50,
            categoryName: 'Getränke', // Using test category we just created
            description: 'A delicious test latte created by AI agent'
        };
        
        console.log(`   Creating product: ${JSON.stringify(productData)}`);
        const result = await createProduct(productData);
        
        console.log(`   ✅ Service test: ${result.success ? 'PASS' : 'FAIL'}`);
        
        if (result.success) {
            console.log(`   📦 Product ID: ${result.data.id}`);
            console.log(`   🏷️ Name: ${result.data.name}`);
            console.log(`   💰 Price: ${result.data.price}`);
            console.log(`   📂 Category: ${result.data.categoryName}`);
        } else {
            console.log(`   ❌ Error: ${result.message}`);
        }
        
        // Test 2: Verify we can find the product with search
        if (result.success) {
            console.log('\n2. Testing that new product can be found...');
            const { searchProducts } = require('./src/services/search.service.js');
            
            setTimeout(async () => {
                try {
                    const searchResult = await searchProducts('Test Latte');
                    console.log(`   🔍 Search test: ${searchResult.success ? 'PASS' : 'FAIL'}`);
                    
                    if (searchResult.success && searchResult.results.length > 0) {
                        const foundProduct = searchResult.results.find(p => p.name.includes('Test Latte'));
                        if (foundProduct) {
                            console.log(`   ✅ Found created product: ${foundProduct.name} - ${foundProduct.price}`);
                        } else {
                            console.log(`   ⚠️ Product created but not found in search results yet`);
                        }
                    }
                } catch (searchError) {
                    console.log(`   ❌ Search test failed: ${searchError.message}`);
                }
            }, 1000); // Give it a moment for indexing
        }
        
    } catch (error) {
        console.log(`   ❌ Service test failed: ${error.message}`);
        console.error('Stack:', error.stack);
    }
    
    // Test 3: LLM integration test (optional, commented out for now due to timeout issues)
    /*
    console.log('\n3. Testing LLM service integration...');
    const { sendMessage } = require('./src/services/llm.service.js');
    
    try {
        const query = "создай товар 'Капучино Тест' цена 4.00 категория 'Getränke'";
        console.log(`   Query: "${query}"`);
        
        const timeout = setTimeout(() => {
            console.log('   ⏱️  LLM test timed out (30s)');
        }, 30000);
        
        const response = await sendMessage(query, []);
        clearTimeout(timeout);
        
        const responseText = response.text.toLowerCase();
        const hasSuccessIndicators = responseText.includes('создан') || 
                                   responseText.includes('добавлен') ||
                                   responseText.includes('успешно') ||
                                   responseText.includes('капучино');
        
        console.log(`   ✅ LLM integration test: ${hasSuccessIndicators ? 'PASS' : 'FAIL'}`);
        console.log(`   📝 Response: ${response.text.substring(0, 100)}...`);
        
    } catch (error) {
        console.log(`   ❌ LLM test failed: ${error.message}`);
    }
    */
    
    console.log('\n🎉 Testing complete!');
}

testCreateProduct().catch(console.error);

--- File: /packages/backend/test_enrichment.js ---

#!/usr/bin/env node

/**
 * Test script for the enrichment service
 */

require('dotenv').config({ path: '../../.env' });
const { enrichMdfData } = require('./src/services/enrichment.service.js');
const fs = require('fs').promises;

async function testEnrichment() {
    console.log('🧪 Testing enrichment service...');
    
    try {
        // Read sample MDF file
        console.log('📖 Reading sample MDF file...');
        const sampleData = await fs.readFile('./test_sample_mdf.json', 'utf8');
        const mdfData = JSON.parse(sampleData);
        
        console.log('✅ Sample data loaded successfully');
        console.log(`   Items: ${countItems(mdfData)}`);
        console.log(`   Categories: ${countCategories(mdfData)}`);
        
        // Test enrichment with web search disabled (faster test)
        console.log('\n🔬 Testing enrichment with web search disabled...');
        
        const enrichmentOptions = {
            skipWebSearch: true,  // Skip for faster testing
            skipMainGroups: false // Test main groups generation
        };
        
        const enrichedData = await enrichMdfData(mdfData, enrichmentOptions);
        
        console.log('✅ Enrichment completed successfully!');
        
        // Verify enrichment results
        console.log('\n📊 Verifying enrichment results...');
        
        // Check if main groups were created
        const mainGroups = enrichedData.company_details?.global_configurations?.main_groups_definitions || [];
        console.log(`   Main groups created: ${mainGroups.length}`);
        if (mainGroups.length > 0) {
            console.log('   Main groups:');
            mainGroups.forEach((group, index) => {
                console.log(`     ${index + 1}. ${group.main_group_names?.de || 'Unknown'} (ID: ${group.main_group_unique_identifier})`);
            });
        }
        
        // Check if categories were assigned to main groups
        let categoriesAssigned = 0;
        for (const branch of enrichedData.company_details.branches || []) {
            for (const pos of branch.point_of_sale_devices || []) {
                for (const category of pos.categories_for_this_pos || []) {
                    if (category.default_linked_main_group_unique_identifier) {
                        categoriesAssigned++;
                        console.log(`     Category "${category.category_names?.de}" assigned to main group ID ${category.default_linked_main_group_unique_identifier}`);
                    }
                }
            }
        }
        console.log(`   Categories assigned to main groups: ${categoriesAssigned}`);
        
        // Check metadata
        const metadata = enrichedData.company_details.meta_information || {};
        console.log(`   Enriched at: ${metadata.enriched_at || 'Not set'}`);
        console.log(`   Enriched by: ${metadata.enriched_by || 'Not set'}`);
        
        // Save enriched data
        const outputPath = './test_sample_mdf.enriched.json';
        await fs.writeFile(outputPath, JSON.stringify(enrichedData, null, 2));
        console.log(`\n💾 Enriched data saved to: ${outputPath}`);
        
        console.log('\n✅ Test completed successfully!');
        
        // Test with full enrichment (if user wants to test with real API calls)
        const testFullEnrichment = process.argv.includes('--full');
        if (testFullEnrichment) {
            console.log('\n🌐 Testing full enrichment with web search...');
            
            const fullOptions = {
                skipWebSearch: false,
                skipMainGroups: false
            };
            
            const fullyEnrichedData = await enrichMdfData(mdfData, fullOptions);
            
            // Check if items were enriched with web data
            let itemsEnriched = 0;
            for (const branch of fullyEnrichedData.company_details.branches || []) {
                for (const pos of branch.point_of_sale_devices || []) {
                    for (const item of pos.items_for_this_pos || []) {
                        if (item.additional_item_attributes?.ai_enrichment) {
                            itemsEnriched++;
                            console.log(`     Item "${item.display_names?.menu?.de}" enriched with cuisine: ${item.additional_item_attributes.ai_enrichment.cuisine}`);
                        }
                    }
                }
            }
            console.log(`   Items enriched with web data: ${itemsEnriched}`);
            
            // Save fully enriched data
            const fullOutputPath = './test_sample_mdf.fully_enriched.json';
            await fs.writeFile(fullOutputPath, JSON.stringify(fullyEnrichedData, null, 2));
            console.log(`💾 Fully enriched data saved to: ${fullOutputPath}`);
        }
        
    } catch (error) {
        console.error('❌ Test failed:', error.message);
        console.error('Stack:', error.stack);
        process.exit(1);
    }
}

// Helper functions
function countItems(mdfData) {
    let count = 0;
    for (const branch of mdfData.company_details?.branches || []) {
        for (const pos of branch.point_of_sale_devices || []) {
            count += pos.items_for_this_pos?.length || 0;
        }
    }
    return count;
}

function countCategories(mdfData) {
    let count = 0;
    for (const branch of mdfData.company_details?.branches || []) {
        for (const pos of branch.point_of_sale_devices || []) {
            count += pos.categories_for_this_pos?.length || 0;
        }
    }
    return count;
}

// Run the test
testEnrichment();

--- File: /packages/backend/test_enrichment_optimization.js ---

#!/usr/bin/env node

// Load environment variables
require('dotenv').config({ path: '../../.env' });

/**
 * Test for Enrichment Service Optimization
 * This test verifies that the enrichment service now uses the optimized
 * invokeSimpleQuery function instead of the heavy conversational agent
 */

const { invokeSimpleQuery } = require('./src/services/llm.service.js');

async function testEnrichmentOptimization() {
    console.log('🧪 Testing Enrichment Service Optimization\n');
    
    const startTime = Date.now();
    
    try {
        // Test the optimized query function directly
        const testQuery = 'Based on the dish "Espresso", identify its cuisine type, typical ingredients, and meal type (appetizer, main course, dessert). Respond only with a JSON object containing keys: cuisine, ingredients, mealType.';
        
        console.log('📝 Testing optimized query function...');
        console.log(`Query: ${testQuery.substring(0, 100)}...`);
        
        const response = await invokeSimpleQuery(testQuery);
        const executionTime = Date.now() - startTime;
        
        console.log(`\n✅ Response received in ${executionTime}ms:`);
        console.log(response);
        
        // Check if response is valid JSON
        try {
            const parsed = JSON.parse(response);
            console.log('\n✅ Response is valid JSON');
            console.log('Parsed data:', parsed);
            
            // Check for expected keys
            if (parsed.cuisine && parsed.ingredients && parsed.mealType) {
                console.log('✅ Response contains expected keys (cuisine, ingredients, mealType)');
            } else {
                console.log('⚠️  Response missing some expected keys');
            }
            
        } catch (parseError) {
            console.log('⚠️  Response is not valid JSON, but this is acceptable for enrichment');
        }
        
        console.log('\n🎉 Enrichment optimization test completed successfully!');
        console.log(`📊 Performance: Query executed in ${executionTime}ms (should be much faster than before)`);
        
    } catch (error) {
        console.error('❌ Enrichment optimization test failed:', error.message);
        process.exit(1);
    }
}

// Run test if called directly
if (require.main === module) {
    testEnrichmentOptimization().catch(error => {
        console.error('Test execution failed:', error);
        process.exit(1);
    });
}

module.exports = testEnrichmentOptimization;

--- File: /packages/backend/test_gemini_limits.js ---

// Test file for Gemini API limit handling
require('dotenv').config({ path: '../../.env' });

const { handleGeminiError, createGeminiErrorLog, GEMINI_ERROR_TYPES } = require('./src/utils/geminiErrorHandler');
const { sendMessage } = require('./src/services/llm.service');

/**
 * Симулирует различные типы ошибок Gemini API для тестирования
 */
function createMockGeminiError(type) {
  const errors = {
    [GEMINI_ERROR_TYPES.RATE_LIMIT]: new Error('Rate limit exceeded. Too many requests per minute.'),
    [GEMINI_ERROR_TYPES.QUOTA_EXCEEDED]: new Error('Quota exceeded for free tier usage.'),
    [GEMINI_ERROR_TYPES.INVALID_API_KEY]: new Error('Invalid API key provided.'),
    [GEMINI_ERROR_TYPES.NETWORK_ERROR]: new Error('Network connection failed: ECONNRESET'),
    [GEMINI_ERROR_TYPES.SERVICE_ERROR]: new Error('Internal server error: Service temporarily unavailable'),
    [GEMINI_ERROR_TYPES.CONTENT_FILTER]: new Error('Content blocked by safety filter policy')
  };

  const error = errors[type] || new Error('Unknown test error');
  
  // Добавляем специфические свойства для разных типов ошибок
  switch (type) {
    case GEMINI_ERROR_TYPES.RATE_LIMIT:
      error.code = 429;
      break;
    case GEMINI_ERROR_TYPES.INVALID_API_KEY:
      error.code = 401;
      break;
    case GEMINI_ERROR_TYPES.SERVICE_ERROR:
      error.code = 503;
      break;
  }

  return error;
}

/**
 * Тестирует обработку различных типов ошибок
 */
function testErrorHandling() {
  console.log('🧪 ТЕСТИРОВАНИЕ ОБРАБОТКИ ОШИБОК GEMINI API\n');

  Object.values(GEMINI_ERROR_TYPES).forEach(errorType => {
    console.log(`\n📋 Тестируем: ${errorType}`);
    console.log('=' .repeat(50));

    const mockError = createMockGeminiError(errorType);
    const errorInfo = handleGeminiError(mockError, { 
      language: 'ru', 
      includeRetryInfo: true 
    });

    console.log('✅ Результат обработки:');
    console.log(`   Тип ошибки: ${errorInfo.errorType}`);
    console.log(`   Временная: ${errorInfo.isTemporary}`);
    console.log(`   Сообщение: ${errorInfo.userMessage}`);
    
    if (errorInfo.retryMessage) {
      console.log(`   Повтор: ${errorInfo.retryMessage}`);
    }

    // Тест логирования
    const logEntry = createGeminiErrorLog(mockError, {
      operation: 'test_operation',
      userId: 'test_user'
    });

    console.log(`\n📝 Лог (${logEntry.level.toUpperCase()}):`);
    console.log(`   ${logEntry.msg}`);
    console.log(`   Пользователю: ${logEntry.userMessage}`);
    
    if (logEntry.retryDelay > 0) {
      console.log(`   Задержка повтора: ${logEntry.retryDelay}с`);
    }
  });
}

/**
 * Тестирует реальную обработку в LLM сервисе с симуляцией ошибки
 */
async function testLLMServiceWithMockError() {
  console.log('\n\n🔧 ТЕСТИРОВАНИЕ LLM СЕРВИСА С СИМУЛЯЦИЕЙ ОШИБКИ\n');

  // Временно перезаписываем API ключ чтобы вызвать ошибку аутентификации
  const originalApiKey = process.env.GEMINI_API_KEY;
  process.env.GEMINI_API_KEY = 'invalid_test_key_12345';

  try {
    console.log('📤 Отправляем сообщение с неверным API ключом...');
    const response = await sendMessage('Привет! Как дела?');
    
    console.log('📥 Ответ LLM сервиса:');
    console.log(`   Текст: ${response.text}`);
    console.log(`   Временная ошибка: ${response.isTemporary || 'false'}`);
    console.log(`   Тип ошибки: ${response.errorType || 'не указан'}`);
    
  } catch (error) {
    console.log('❌ Неожиданная ошибка:', error.message);
  } finally {
    // Восстанавливаем оригинальный API ключ
    process.env.GEMINI_API_KEY = originalApiKey;
  }
}

/**
 * Тестирует реальную работу с валидным API ключом
 */
async function testLLMServiceNormal() {
  console.log('\n\n✅ ТЕСТИРОВАНИЕ НОРМАЛЬНОЙ РАБОТЫ LLM СЕРВИСА\n');

  try {
    console.log('📤 Отправляем обычное сообщение...');
    const response = await sendMessage('Найди товар кружка');
    
    console.log('📥 Ответ LLM сервиса:');
    console.log(`   Текст: ${response.text}`);
    console.log(`   Временная ошибка: ${response.isTemporary || 'false'}`);
    console.log(`   Тип ошибки: ${response.errorType || 'не указан'}`);
    
  } catch (error) {
    console.log('❌ Ошибка:', error.message);
  }
}

/**
 * Главная функция тестирования
 */
async function runTests() {
  try {
    // Тест 1: Обработка различных типов ошибок
    testErrorHandling();
    
    // Тест 2: Симуляция ошибки в LLM сервисе
    await testLLMServiceWithMockError();
    
    // Тест 3: Нормальная работа (если есть валидный API ключ)
    if (process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY !== 'your_api_key_here') {
      await testLLMServiceNormal();
    } else {
      console.log('\n⚠️  Пропускаем тест нормальной работы - нет валидного API ключа');
    }
    
    console.log('\n🎉 ВСЕ ТЕСТЫ ЗАВЕРШЕНЫ!');
    
  } catch (error) {
    console.error('\n💥 Критическая ошибка в тестах:', error);
  }
}

// Запускаем тесты
if (require.main === module) {
  runTests().finally(() => {
    setTimeout(() => process.exit(0), 1000); // Даем время завершиться логам
  });
}

module.exports = {
  createMockGeminiError,
  testErrorHandling,
  runTests
};

--- File: /packages/backend/test_google_env.js ---

// Test environment variable setup for Google search
require('dotenv').config({ path: '../../.env' });

console.log('🔍 Environment Variable Debug Test\n');

console.log('=== Current Environment Variables ===');
console.log('GEMINI_API_KEY:', process.env.GEMINI_API_KEY ? 'SET' : 'NOT SET');
console.log('GCS_API_KEY:', process.env.GCS_API_KEY ? 'SET' : 'NOT SET');
console.log('GCS_CX:', process.env.GCS_CX ? 'SET' : 'NOT SET');
console.log('GOOGLE_API_KEY:', process.env.GOOGLE_API_KEY ? 'SET' : 'NOT SET');
console.log('GOOGLE_CSE_ID:', process.env.GOOGLE_CSE_ID ? 'SET' : 'NOT SET');

console.log('\n=== Setting up Google Search Environment ===');

// Simulate what the research service does
if (!process.env.GOOGLE_API_KEY && process.env.GEMINI_API_KEY) {
    process.env.GOOGLE_API_KEY = process.env.GEMINI_API_KEY;
    console.log('✅ Set GOOGLE_API_KEY from GEMINI_API_KEY');
}

if (!process.env.GOOGLE_CSE_ID && process.env.GCS_CX) {
    process.env.GOOGLE_CSE_ID = process.env.GCS_CX;
    console.log('✅ Set GOOGLE_CSE_ID from GCS_CX');
}

console.log('\n=== Final Environment Variables ===');
console.log('GOOGLE_API_KEY:', process.env.GOOGLE_API_KEY ? 'SET' : 'NOT SET');
console.log('GOOGLE_CSE_ID:', process.env.GOOGLE_CSE_ID ? 'SET' : 'NOT SET');

console.log('\n=== Testing GoogleCustomSearch Import ===');
try {
    const { GoogleCustomSearch } = require("@langchain/community/tools/google_custom_search");
    console.log('✅ GoogleCustomSearch imported successfully');
    
    if (process.env.GOOGLE_API_KEY && process.env.GOOGLE_CSE_ID) {
        console.log('🔧 Attempting to create GoogleCustomSearch instance...');
        const searchTool = new GoogleCustomSearch({});
        console.log('✅ GoogleCustomSearch instance created successfully');
        console.log('Tool name:', searchTool.name);
        console.log('Tool description:', searchTool.description);
    } else {
        console.log('❌ Cannot create GoogleCustomSearch - missing required env vars');
    }
} catch (error) {
    console.error('❌ Error with GoogleCustomSearch:', error.message);
}

console.log('\n🎯 Environment test completed!');

--- File: /packages/backend/test_google_research.js ---

// Test script for Google-only research implementation
// Run with: node test_google_research.js

require('dotenv').config({ path: '../../.env' });
const { runResearch } = require('./src/services/research.service');
const logger = require('./src/config/logger');

async function testGoogleResearch() {
    console.log('🧪 Testing Google-only Research Implementation...\n');
    
    // Check required environment variables
    const requiredVars = ['GEMINI_API_KEY', 'GCS_CX'];
    const missingVars = requiredVars.filter(varName => !process.env[varName] || process.env[varName] === 'YOUR_SEARCH_ENGINE_ID');
    
    if (missingVars.length > 0) {
        console.error(`❌ Missing required environment variables: ${missingVars.join(', ')}`);
        console.log('\n📋 Setup instructions:');
        console.log('1. Go to https://programmablesearchengine.google.com/');
        console.log('2. Create a new search engine for "Search the entire web"');
        console.log('3. Copy the Search Engine ID to GCS_CX in your .env file');
        console.log('4. Your GEMINI_API_KEY will be used for search functionality');
        console.log('5. Ensure Custom Search API is enabled in Google Cloud Console');
        return;
    }
    
    console.log('✅ Environment variables are configured');
    console.log(`📊 Using Search Engine ID: ${process.env.GCS_CX}`);
    console.log(`🔑 Using API Key: ${process.env.GEMINI_API_KEY ? 'SET' : 'NOT SET'}`);
    
    // Test queries for different scenarios
    const testQueries = [
        "What are the main ingredients in Tiramisu?",
        "German VAT rates for restaurants 2025",
        "Pad Thai cuisine type and ingredients"
    ];
    
    for (const [index, query] of testQueries.entries()) {
        console.log(`\n📝 Test ${index + 1}: "${query}"`);
        console.log('=' .repeat(60));
        
        try {
            const result = await runResearch(query);
            
            if (result.success) {
                console.log('✅ Google research successful!');
                console.log(`📊 Summary length: ${result.summary?.length || 0} characters`);
                console.log(`📖 Sources: ${result.sources}`);
                console.log(`📝 Preview: ${result.summary?.substring(0, 300)}...`);
            } else {
                console.log('❌ Google research failed');
                console.log(`🔍 Error: ${result.error}`);
                console.log(`💡 Fallback: ${result.fallback}`);
            }
        } catch (error) {
            console.error(`💥 Test failed with exception: ${error.message}`);
            console.error(`📍 Stack: ${error.stack}`);
        }
        
        // Wait between tests to avoid rate limits
        if (index < testQueries.length - 1) {
            console.log('⏳ Waiting 3 seconds before next test...');
            await new Promise(resolve => setTimeout(resolve, 3000));
        }
    }
    
    console.log('\n🎯 Google research testing completed!');
    console.log('\n📋 Next steps:');
    console.log('1. If tests passed, the system is ready for production use');
    console.log('2. If tests failed, check your Google Custom Search Engine configuration');
    console.log('3. You can now use web search through the main application');
}

// Run the test
testGoogleResearch().catch(error => {
    console.error('💥 Test runner failed:', error);
    process.exit(1);
});

--- File: /packages/backend/test_google_setup.js ---

// Test Google Search setup validation
// Run with: node test_google_setup.js

require('dotenv').config({ path: '../../.env' });

async function validateGoogleSetup() {
    console.log('🔍 Google Search Setup Validation\n');
    
    let isValid = true;
    
    // Check 1: Basic environment variables
    console.log('=== Environment Variables Check ===');
    
    if (!process.env.GEMINI_API_KEY) {
        console.log('❌ GEMINI_API_KEY is not set');
        isValid = false;
    } else if (process.env.GEMINI_API_KEY === 'YOUR_GOOGLE_GEMINI_API_KEY') {
        console.log('❌ GEMINI_API_KEY is set to placeholder value');
        isValid = false;
    } else {
        console.log('✅ GEMINI_API_KEY is configured');
    }
    
    if (!process.env.GCS_CX) {
        console.log('❌ GCS_CX is not set');
        isValid = false;
    } else if (process.env.GCS_CX === 'YOUR_SEARCH_ENGINE_ID') {
        console.log('❌ GCS_CX is set to placeholder value');
        isValid = false;
    } else {
        console.log('✅ GCS_CX is configured');
    }
    
    if (!isValid) {
        console.log('\n❌ Environment setup is incomplete');
        console.log('\n📋 Please follow the setup instructions:');
        console.log('1. Read GOOGLE_SEARCH_SETUP.md for detailed instructions');
        console.log('2. Set up your Google Custom Search Engine');
        console.log('3. Update your .env file with the correct values');
        return false;
    }
    
    // Check 2: Test Google Custom Search Tool
    console.log('\n=== Google Custom Search Tool Check ===');
    
    try {
        // Set up environment for LangChain
        process.env.GOOGLE_API_KEY = process.env.GEMINI_API_KEY;
        process.env.GOOGLE_CSE_ID = process.env.GCS_CX;
        
        const { GoogleCustomSearch } = require("@langchain/community/tools/google_custom_search");
        const searchTool = new GoogleCustomSearch({});
        
        console.log('✅ Google Custom Search tool initialized successfully');
        console.log(`📊 Tool name: ${searchTool.name}`);
        console.log(`📖 Tool description: ${searchTool.description}`);
        
        // Test a simple search
        console.log('\n=== Test Search ===');
        console.log('🔍 Testing with query: "hello world"');
        
        const result = await searchTool.call("hello world");
        console.log('✅ Search completed successfully');
        console.log(`📊 Result length: ${result.length} characters`);
        console.log(`📝 First 200 chars: ${result.substring(0, 200)}...`);
        
        return true;
        
    } catch (error) {
        console.log('❌ Google Custom Search tool failed');
        console.log(`🔍 Error: ${error.message}`);
        
        if (error.message.includes('API key not set')) {
            console.log('💡 Solution: Check your GEMINI_API_KEY is valid');
        } else if (error.message.includes('API key not valid')) {
            console.log('💡 Solution: Enable Custom Search API in Google Cloud Console');
        } else if (error.message.includes('not found')) {
            console.log('💡 Solution: Check your Search Engine ID (GCS_CX)');
        }
        
        return false;
    }
}

// Run validation
validateGoogleSetup().then(success => {
    if (success) {
        console.log('\n🎉 Google Search setup is complete and working!');
        console.log('🚀 You can now use web search functionality in ecKasse');
    } else {
        console.log('\n❌ Google Search setup needs attention');
        console.log('📖 Please check GOOGLE_SEARCH_SETUP.md for instructions');
    }
}).catch(error => {
    console.error('💥 Setup validation failed:', error);
    process.exit(1);
});

--- File: /packages/backend/test_import_service_phase2.js ---

#!/usr/bin/env node

/**
 * Test Script for Phase 2: OOP-POS-MDF Import with Integrated Vectorization
 * 
 * This test validates the import service functionality:
 * - Service structure and API validation
 * - CLI integration testing
 * - Database schema compatibility check
 * - Mock data import simulation
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

const fs = require('fs').promises;
const path = require('path');

class ImportServicePhase2Test {
  constructor() {
    this.testsPassed = 0;
    this.testsFailed = 0;
    this.results = [];
  }

  async runTests() {
    console.log('🧪 Starting Phase 2 Import Service Tests\n');
    
    try {
      // Test 1: Import service structure validation
      console.log('📝 Test 1: Import Service Structure Validation');
      await this.testImportServiceStructure();

      // Test 2: CLI integration validation
      console.log('\n📝 Test 2: CLI Integration Validation');
      await this.testCLIIntegration();

      // Test 3: Database dependencies validation
      console.log('\n📝 Test 3: Database Dependencies Validation');
      await this.testDatabaseDependencies();

      // Test 4: Mock data structure validation
      console.log('\n📝 Test 4: Sample OOP-POS-MDF Structure Validation');
      await this.testSampleDataStructure();

      // Summary
      this.printSummary();

    } catch (error) {
      console.error('❌ Test execution failed:', error.message);
      process.exit(1);
    }
  }

  async testImportServiceStructure() {
    try {
      // Check if the import service file exists and has the expected structure
      const servicePath = path.join(__dirname, 'src', 'services', 'import.service.js');
      const serviceExists = await fs.access(servicePath).then(() => true).catch(() => false);
      
      this.assert(
        serviceExists,
        'Import service file should exist'
      );

      if (serviceExists) {
        const serviceContent = await fs.readFile(servicePath, 'utf8');
        
        this.assert(
          serviceContent.includes('importFromOopMdf'),
          'Should have importFromOopMdf function'
        );

        this.assert(
          serviceContent.includes('cleanExistingData'),
          'Should have cleanExistingData function'
        );

        this.assert(
          serviceContent.includes('importHierarchicalData'),
          'Should have importHierarchicalData function'
        );

        this.assert(
          serviceContent.includes('importItemsWithVectorization'),
          'Should have importItemsWithVectorization function'
        );

        this.assert(
          serviceContent.includes('generateEmbedding'),
          'Should use embedding service'
        );

        this.assert(
          serviceContent.includes('embeddingToBuffer'),
          'Should convert embeddings to buffer format'
        );

        this.assert(
          serviceContent.includes('vec_items'),
          'Should insert into vec_items table'
        );

        this.assert(
          serviceContent.includes('categoryIdMap'),
          'Should use categoryIdMap for linking'
        );

        this.assert(
          serviceContent.includes('semanticString'),
          'Should construct semantic strings'
        );

        console.log('✅ Import service structure validation passed');
      }
      
    } catch (error) {
      console.log('❌ Import service structure test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testCLIIntegration() {
    try {
      // Check CLI integration
      const cliPath = path.join(__dirname, 'src', 'lib', 'cli.js');
      const cliExists = await fs.access(cliPath).then(() => true).catch(() => false);
      
      this.assert(
        cliExists,
        'CLI file should exist'
      );

      if (cliExists) {
        const cliContent = await fs.readFile(cliPath, 'utf8');
        
        this.assert(
          cliContent.includes('import-mdf'),
          'Should have import-mdf command'
        );

        this.assert(
          cliContent.includes('importFromOopMdf'),
          'Should import the import service'
        );

        this.assert(
          cliContent.includes('importMdfCommand'),
          'Should have importMdfCommand method'
        );

        this.assert(
          cliContent.includes('--force'),
          'Should have --force option'
        );

        this.assert(
          cliContent.includes('--dry-run'),
          'Should have --dry-run option'
        );

        this.assert(
          cliContent.includes('--validate'),
          'Should have --validate option'
        );

        this.assert(
          cliContent.includes('inquirer.prompt'),
          'Should have confirmation prompt'
        );

        console.log('✅ CLI integration validation passed');
      }
      
    } catch (error) {
      console.log('❌ CLI integration test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testDatabaseDependencies() {
    try {
      // Check database migration files exist
      const migrationsDir = path.join(__dirname, 'src', 'db', 'migrations');
      const migrationsExist = await fs.access(migrationsDir).then(() => true).catch(() => false);
      
      this.assert(
        migrationsExist,
        'Migrations directory should exist'
      );

      if (migrationsExist) {
        const migrationFiles = await fs.readdir(migrationsDir);
        
        this.assert(
          migrationFiles.some(file => file.includes('create_oop_pos_mdf_tables')),
          'Should have OOP-POS-MDF tables migration'
        );

        this.assert(
          migrationFiles.some(file => file.includes('create_vec_items_table')),
          'Should have vec_items table migration'
        );

        // Check database connection file
        const dbPath = path.join(__dirname, 'src', 'db', 'knex.js');
        const dbExists = await fs.access(dbPath).then(() => true).catch(() => false);
        
        this.assert(
          dbExists,
          'Database connection file should exist'
        );

        if (dbExists) {
          const dbContent = await fs.readFile(dbPath, 'utf8');
          
          this.assert(
            dbContent.includes('sqlite-vec'),
            'Should load sqlite-vec extension'
          );
        }

        // Check embedding service exists
        const embeddingPath = path.join(__dirname, 'src', 'services', 'embedding.service.js');
        const embeddingExists = await fs.access(embeddingPath).then(() => true).catch(() => false);
        
        this.assert(
          embeddingExists,
          'Embedding service should exist'
        );

        console.log('✅ Database dependencies validation passed');
      }
      
    } catch (error) {
      console.log('❌ Database dependencies test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testSampleDataStructure() {
    try {
      // Create a sample OOP-POS-MDF structure to validate our import logic
      const sampleMdf = {
        "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
        company_details: {
          company_unique_identifier: 1,
          company_full_name: "Test Restaurant",
          meta_information: {
            format_version: "2.0.0",
            date_generated: new Date().toISOString(),
            generated_by: "test-script",
            default_currency_symbol: "€",
            default_language: "de"
          },
          global_configurations: {
            tax_rates_definitions: [
              {
                tax_rate_unique_identifier: 1,
                tax_rate_names: { "de": "Standard (19%)" },
                rate_percentage: 19.0,
                fiscal_mapping_type: "NORMAL"
              }
            ],
            main_groups_definitions: [],
            payment_methods_definitions: [],
            promotions_definitions: [],
            workflows: [],
            integrations: {},
            security_settings: {}
          },
          branches: [
            {
              branch_unique_identifier: 1,
              branch_names: { "de": "Hauptfiliale" },
              branch_address: "Test Street 1",
              point_of_sale_devices: [
                {
                  pos_device_unique_identifier: 1,
                  pos_device_names: { "de": "Kasse 1" },
                  pos_device_type: "DESKTOP",
                  pos_device_external_number: 1,
                  pos_device_settings: {},
                  categories_for_this_pos: [
                    {
                      category_unique_identifier: 1,
                      category_names: { "de": "Vorspeisen" },
                      category_type: "food",
                      audit_trail: {}
                    },
                    {
                      category_unique_identifier: 2,
                      category_names: { "de": "Hauptgerichte" },
                      category_type: "food",
                      audit_trail: {}
                    }
                  ],
                  items_for_this_pos: [
                    {
                      item_unique_identifier: 1001,
                      display_names: {
                        menu: { "de": "Bruschetta della Casa" },
                        button: { "de": "Bruschetta" },
                        receipt: { "de": "Bruschetta della Casa" }
                      },
                      item_price_value: 6.50,
                      pricing_schedules: [],
                      availability_schedule: { always_available: true },
                      associated_category_unique_identifier: 1,
                      additional_item_attributes: {
                        description: "Geröstetes Ciabatta-Brot mit frischen Tomaten, Knoblauch, Basilikum und nativem Olivenöl extra",
                        allergens: ["gluten"],
                        dietary_info: ["vegetarian"]
                      },
                      item_flags: { is_sellable: true },
                      audit_trail: {}
                    },
                    {
                      item_unique_identifier: 1002,
                      display_names: {
                        menu: { "de": "Pizza Margherita" },
                        button: { "de": "Margherita" },
                        receipt: { "de": "Pizza Margherita" }
                      },
                      item_price_value: 9.00,
                      pricing_schedules: [
                        { schedule_id: "variant_klein", price: 7.00 },
                        { schedule_id: "variant_gross", price: 11.00 }
                      ],
                      availability_schedule: { always_available: true },
                      associated_category_unique_identifier: 2,
                      additional_item_attributes: {
                        description: "Hausgemachter Teig mit San Marzano Tomaten, Mozzarella di Bufala und frischem Basilikum",
                        allergens: ["gluten", "dairy"],
                        dietary_info: ["vegetarian"]
                      },
                      item_flags: { is_sellable: true },
                      audit_trail: {}
                    }
                  ]
                }
              ]
            }
          ]
        }
      };

      // Validate structure
      this.assert(
        sampleMdf.company_details !== undefined,
        'Sample should have company_details'
      );

      this.assert(
        sampleMdf.company_details.branches.length > 0,
        'Sample should have branches'
      );

      this.assert(
        sampleMdf.company_details.branches[0].point_of_sale_devices.length > 0,
        'Sample should have POS devices'
      );

      this.assert(
        sampleMdf.company_details.branches[0].point_of_sale_devices[0].categories_for_this_pos.length > 0,
        'Sample should have categories'
      );

      this.assert(
        sampleMdf.company_details.branches[0].point_of_sale_devices[0].items_for_this_pos.length > 0,
        'Sample should have items'
      );

      // Validate item with rich description for vectorization
      const firstItem = sampleMdf.company_details.branches[0].point_of_sale_devices[0].items_for_this_pos[0];
      
      this.assert(
        firstItem.additional_item_attributes.description.length > 50,
        'Sample item should have detailed description for vectorization'
      );

      this.assert(
        firstItem.associated_category_unique_identifier !== undefined,
        'Sample item should have category reference'
      );

      // Write sample file for testing
      const samplePath = path.join(__dirname, 'test-sample-mdf.json');
      await fs.writeFile(samplePath, JSON.stringify(sampleMdf, null, 2));

      console.log('✅ Sample OOP-POS-MDF structure validation passed');
      console.log(`   - Created test file: ${samplePath}`);
      console.log(`   - Items: ${sampleMdf.company_details.branches[0].point_of_sale_devices[0].items_for_this_pos.length}`);
      console.log(`   - Categories: ${sampleMdf.company_details.branches[0].point_of_sale_devices[0].categories_for_this_pos.length}`);
      
    } catch (error) {
      console.log('❌ Sample data structure test failed:', error.message);
      this.testsFailed++;
    }
  }

  assert(condition, message) {
    if (condition) {
      this.testsPassed++;
      this.results.push({ status: 'PASS', message });
    } else {
      this.testsFailed++;
      this.results.push({ status: 'FAIL', message });
      throw new Error(message);
    }
  }

  printSummary() {
    console.log('\n' + '='.repeat(60));
    console.log('📊 PHASE 2 TEST SUMMARY');
    console.log('='.repeat(60));
    console.log(`✅ Tests Passed: ${this.testsPassed}`);
    console.log(`❌ Tests Failed: ${this.testsFailed}`);
    console.log(`📈 Success Rate: ${(this.testsPassed / (this.testsPassed + this.testsFailed) * 100).toFixed(1)}%`);
    
    if (this.testsFailed === 0) {
      console.log('\n🎉 Phase 2 Import Service Test: SUCCESS');
      console.log('All import and vectorization features are properly implemented!');
      console.log('\n📋 Next Steps:');
      console.log('1. Test with actual data: node src/lib/cli.js import-mdf test-sample-mdf.json --dry-run');
      console.log('2. Run actual import: node src/lib/cli.js import-mdf test-sample-mdf.json --force');
      console.log('3. Proceed to Phase 3: Hybrid Search Integration');
    } else {
      console.log('\n💥 Phase 2 Import Service Test: FAILED');
      console.log('Some implementation issues detected. Check the detailed output above.');
    }
    
    console.log('\n📋 Detailed Results:');
    this.results.forEach((result, index) => {
      const icon = result.status === 'PASS' ? '✅' : '❌';
      console.log(`${icon} ${index + 1}. ${result.message}`);
    });
  }
}

// Run tests if called directly
if (require.main === module) {
  const test = new ImportServicePhase2Test();
  test.runTests().catch(error => {
    console.error('Test execution failed:', error);
    process.exit(1);
  });
}

module.exports = ImportServicePhase2Test;

--- File: /packages/backend/test_llm_create_product.js ---

#!/usr/bin/env node

/**
 * Test LLM createProduct integration
 */

require('dotenv').config({ path: '../../.env' });

async function testLLMCreateProduct() {
    console.log('🧪 Testing LLM createProduct integration...');
    
    try {
        const { sendMessage } = require('./src/services/llm.service.js');
        
        // Test Russian command
        const query = "создай товар 'Капучино Тест' цена 4.50 категория 'Getränke'";
        console.log(`Query: "${query}"`);
        
        console.log('⏱️ Sending request to LLM agent (timeout: 45s)...');
        
        const timeout = setTimeout(() => {
            console.log('⏱️ Request timed out after 45 seconds');
            process.exit(1);
        }, 45000);
        
        const response = await sendMessage(query, []);
        clearTimeout(timeout);
        
        console.log(`\n📝 Agent Response: ${response.text}`);
        
        // Check for success indicators
        const responseText = response.text.toLowerCase();
        const hasSuccessIndicators = responseText.includes('создан') || 
                                   responseText.includes('добавлен') ||
                                   responseText.includes('успешно') ||
                                   responseText.includes('капучино') ||
                                   responseText.includes('successfully') ||
                                   responseText.includes('created');
        
        console.log(`\n✅ Test Result: ${hasSuccessIndicators ? 'PASS - Product creation detected' : 'FAIL - No success indicators'}`);
        
        if (hasSuccessIndicators) {
            console.log('🎉 LLM agent successfully created a product using real database logic!');
        } else {
            console.log('❌ LLM agent response does not indicate successful product creation');
        }
        
    } catch (error) {
        console.error('❌ LLM test failed:', error.message);
        process.exit(1);
    }
}

testLLMCreateProduct();

--- File: /packages/backend/test_menu_parser_detailed.js ---

#!/usr/bin/env node

/**
 * Comprehensive Test for Phase 1 Detailed Menu Parsing
 * 
 * This test validates the enhanced menu parsing functionality:
 * - Detailed description extraction
 * - Multiple price variants handling
 * - Category linking via categoryName
 * - Rich semantic context for embeddings
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

// For testing, we'll validate the structure without actually running the parser
// const MenuParserLLM = require('./src/lib/menu_parser_llm.js');
const fs = require('fs').promises;
const path = require('path');

// Test data
const menuPageSimple = `
RESTAURANT BELLA VISTA

VORSPEISEN
Bruschetta - Geröstetes Brot mit Tomaten - 6.50€
Antipasti Misti - Gemischte italienische Vorspeisen - 8.50€

HAUPTGERICHTE  
Pizza Margherita - Tomaten, Mozzarella, Basilikum - 9.00€
Pasta Carbonara - Spaghetti mit Speck und Parmesan - 11.50€

GETRÄNKE
Wasser - Still oder sprudelnd - 2.50€
Wein - Rotwein oder Weißwein - 4.50€
`;

const menuPageComplex = `
RISTORANTE BELLA VISTA
Authentische italienische Küche

ANTIPASTI (Vorspeisen)
Bruschetta della Casa - Geröstetes Ciabatta-Brot mit frischen Tomaten, Knoblauch, Basilikum und nativem Olivenöl extra, garniert mit Parmesan und Rucola - 6.50€

Antipasti Misti della Tradizione - Auswahl traditioneller italienischer Vorspeisen: Prosciutto di Parma, Salami Milano, Mozzarella di Bufala, gegrillte Zucchini und Auberginen, marinierte Oliven und Kapern, serviert mit hausgemachtem Focaccia - 12.50€

Vitello Tonnato - Zarte Kalbsscheiben in cremiger Thunfischsauce mit Kapern, klassisch zubereitet nach piemontesischem Rezept - 14.50€

PRIMI PIATTI (Hauptgerichte)
Pizza Margherita - Hausgemachter Teig mit San Marzano Tomaten, Mozzarella di Bufala und frischem Basilikum aus eigenem Anbau
  Klein (26cm) - 9.00€
  Groß (32cm) - 13.00€

Pizza Quattro Stagioni - Vier Jahreszeiten Pizza mit Artischocken, Champignons, Prosciutto cotto und schwarzen Oliven, aufgeteilt in vier Quadranten
  Klein (26cm) - 12.00€
  Groß (32cm) - 16.50€

Pasta Carbonara - Hausgemachte Spaghetti mit Guanciale (Schweinebacke), Pecorino Romano, Eigelb und schwarzem Pfeffer, traditionell ohne Sahne zubereitet - 11.50€

Risotto ai Funghi Porcini - Cremiger Carnaroli-Reis mit frischen Steinpilzen, Parmesan und Weißwein, verfeinert mit Petersilie (vegetarisch) - 13.50€

DOLCI (Desserts)
Tiramisu della Casa - Hausgemachtes Tiramisu mit Mascarpone, Savoiardi, Espresso und Kakao (enthält Ei, Milch) - 5.50€

BEVANDE (Getränke)
Acqua - Natürliches Mineralwasser
  Piccola (0.25L) - 2.50€
  Grande (0.75L) - 4.50€

Vino della Casa - Hauswein aus der Toskana
  Rosso (Rotwein) - 4.50€/Glas, 18.00€/Flasche
  Bianco (Weißwein) - 4.50€/Glas, 18.00€/Flasche

Espresso - Authentischer italienischer Espresso aus hochwertigen Arabica-Bohnen - 2.20€

Allergen-Hinweise: (1) Gluten, (2) Eier, (3) Milch, (4) Nüsse
Bio-Produkte sind entsprechend gekennzeichnet
`;

class MenuParserDetailedTest {
  constructor() {
    this.testsPassed = 0;
    this.testsFailed = 0;
    this.results = [];
  }

  async runTests() {
    console.log('🧪 Starting Phase 1 Detailed Menu Parsing Tests\n');
    
    try {
      // Test 1: Validate menu parser structure
      console.log('📝 Test 1: Menu Parser Structure Validation');
      await this.testMenuParserStructure();

      // Test 2: Validate test data format
      console.log('\n📝 Test 2: Test Data Format Validation');
      await this.testDataFormat();

      // Test 3: Validate CLI integration
      console.log('\n📝 Test 3: CLI Integration Validation');
      await this.testCLIIntegration();

      // Summary
      this.printSummary();

    } catch (error) {
      console.error('❌ Test execution failed:', error.message);
      process.exit(1);
    }
  }

  async testMenuParserStructure() {
    try {
      // Check if the menu parser file exists and has the expected structure
      const parserPath = path.join(__dirname, 'src', 'lib', 'menu_parser_llm.js');
      const parserExists = await fs.access(parserPath).then(() => true).catch(() => false);
      
      this.assert(
        parserExists,
        'Menu parser file should exist'
      );

      if (parserExists) {
        const parserContent = await fs.readFile(parserPath, 'utf8');
        
        this.assert(
          parserContent.includes('createSystemPrompt'),
          'Should have createSystemPrompt method'
        );

        this.assert(
          parserContent.includes('convertToOOPPOSMDF'),
          'Should have convertToOOPPOSMDF method'
        );

        this.assert(
          parserContent.includes('categoryName'),
          'Should support new categoryName linking format'
        );

        this.assert(
          parserContent.includes('VOLLSTÄNDIGE Beschreibung'),
          'Should emphasize complete description extraction'
        );

        console.log('✅ Menu parser structure validation passed');
      }
      
    } catch (error) {
      console.log('❌ Menu parser structure test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testDataFormat() {
    try {
      // Validate test data format
      this.assert(
        menuPageSimple.includes('VORSPEISEN'),
        'Simple menu should contain categories'
      );

      this.assert(
        menuPageComplex.includes('Geröstetes Ciabatta-Brot'),
        'Complex menu should contain detailed descriptions'
      );

      this.assert(
        menuPageComplex.includes('Klein (26cm)'),
        'Complex menu should contain variant pricing'
      );

      this.assert(
        menuPageComplex.includes('Allergen-Hinweise'),
        'Complex menu should contain allergen information'
      );

      console.log('✅ Test data format validation passed');
      
    } catch (error) {
      console.log('❌ Test data format validation failed:', error.message);
      this.testsFailed++;
    }
  }

  async testCLIIntegration() {
    try {
      // Check CLI integration
      const cliPath = path.join(__dirname, 'src', 'lib', 'cli.js');
      const cliExists = await fs.access(cliPath).then(() => true).catch(() => false);
      
      this.assert(
        cliExists,
        'CLI file should exist'
      );

      if (cliExists) {
        const cliContent = await fs.readFile(cliPath, 'utf8');
        
        this.assert(
          cliContent.includes('--raw-json-output'),
          'Should have --raw-json-output flag'
        );

        this.assert(
          cliContent.includes('rawJsonOutput'),
          'Should handle raw JSON output option'
        );

        this.assert(
          cliContent.includes('result.rawData.parsedData'),
          'Should save raw parsed data for debugging'
        );

        console.log('✅ CLI integration validation passed');
      }
      
    } catch (error) {
      console.log('❌ CLI integration test failed:', error.message);
      this.testsFailed++;
    }
  }

  assert(condition, message) {
    if (condition) {
      this.testsPassed++;
      this.results.push({ status: 'PASS', message });
    } else {
      this.testsFailed++;
      this.results.push({ status: 'FAIL', message });
      throw new Error(message);
    }
  }

  printSummary() {
    console.log('\n' + '='.repeat(60));
    console.log('📊 TEST SUMMARY');
    console.log('='.repeat(60));
    console.log(`✅ Tests Passed: ${this.testsPassed}`);
    console.log(`❌ Tests Failed: ${this.testsFailed}`);
    console.log(`📈 Success Rate: ${(this.testsPassed / (this.testsPassed + this.testsFailed) * 100).toFixed(1)}%`);
    
    if (this.testsFailed === 0) {
      console.log('\n🎉 Phase 1 Detailed Parsing Test: SUCCESS');
      console.log('All enhanced menu parsing features are working correctly!');
    } else {
      console.log('\n💥 Phase 1 Detailed Parsing Test: FAILED');
      console.log('Some tests failed. Check the detailed output above.');
    }
    
    console.log('\n📋 Detailed Results:');
    this.results.forEach((result, index) => {
      const icon = result.status === 'PASS' ? '✅' : '❌';
      console.log(`${icon} ${index + 1}. ${result.message}`);
    });
  }
}

// Run tests if called directly
if (require.main === module) {
  const test = new MenuParserDetailedTest();
  test.runTests().catch(error => {
    console.error('Test execution failed:', error);
    process.exit(1);
  });
}

module.exports = MenuParserDetailedTest;

--- File: /packages/backend/test_next_gen_search.js ---

#!/usr/bin/env node

/**
 * Test script for Next-Gen Hybrid Search system
 */

require('dotenv').config({ path: '../../.env' });
const { searchProducts } = require('./src/services/search.service');
const { generateEmbedding } = require('./src/services/embedding.service');

async function testNextGenSearch() {
    console.log('🧪 Testing Next-Gen Hybrid Search System...\n');
    
    try {
        // Test 1: New embedding model
        console.log('📊 Test 1: New Embedding Model');
        const testEmbedding = await generateEmbedding('Test product');
        console.log(`✅ Generated embedding with ${testEmbedding.length} dimensions`);
        console.log(`✅ Model: gemini-embedding-exp-03-07`);
        console.log(`✅ Task Type: RETRIEVAL_DOCUMENT`);
        console.log();
        
        // Test 2: Hybrid search
        console.log('🔍 Test 2: Hybrid Search Pipeline');
        
        const testQueries = [
            'coffee',
            'latte',
            'pizza',
            'drink',
            'food'
        ];
        
        for (const query of testQueries) {
            console.log(`\n🔍 Searching for: "${query}"`);
            const searchResult = await searchProducts(query);
            
            console.log(`   Success: ${searchResult.success}`);
            console.log(`   Results: ${searchResult.results.length}`);
            console.log(`   Method: ${searchResult.metadata?.searchMethod || 'unknown'}`);
            console.log(`   Time: ${searchResult.metadata?.executionTime || 0}ms`);
            
            if (searchResult.results.length > 0) {
                const topResult = searchResult.results[0];
                console.log(`   Top result: "${topResult.productName}" (${topResult.price}€)`);
                console.log(`   Search type: ${topResult.search_type}`);
                
                if (topResult.similarity !== undefined) {
                    console.log(`   Similarity: ${topResult.similarity}%`);
                }
                if (topResult.levenshteinDistance !== undefined) {
                    console.log(`   Levenshtein: ${topResult.levenshteinDistance}`);
                }
            }
        }
        
        console.log('\n🎉 Next-Gen Hybrid Search System Tests Completed!');
        
        // Test 3: System specifications
        console.log('\n📋 System Specifications:');
        console.log('   • Embedding Model: gemini-embedding-exp-03-07');
        console.log('   • Vector Dimensions: 768');
        console.log('   • Task Type: RETRIEVAL_DOCUMENT');
        console.log('   • Search Pipeline: FTS → Vector → Levenshtein');
        console.log('   • Web Search Tool: Available');
        console.log('   • Database: SQLite with sqlite-vec extension');
        
    } catch (error) {
        console.error('❌ Test failed:', error.message);
        console.error('Stack:', error.stack);
        process.exit(1);
    }
}

// Run the test
testNextGenSearch().then(() => {
    console.log('\n✅ All tests completed successfully!');
    process.exit(0);
}).catch(error => {
    console.error('❌ Test suite failed:', error.message);
    process.exit(1);
});

--- File: /packages/backend/test_phase3_structure.js ---

#!/usr/bin/env node

/**
 * Structure Validation Test for Phase 3: Hybrid Search Integration
 * 
 * This test validates the implementation structure and integration points
 * without requiring API keys or database data.
 * 
 * @author eckasse Development Team
 * @version 2.0.0
 */

const fs = require('fs').promises;
const path = require('path');

class Phase3StructureTest {
  constructor() {
    this.testsPassed = 0;
    this.testsFailed = 0;
    this.results = [];
  }

  async runTests() {
    console.log('🧪 Starting Phase 3 Structure Validation Tests\n');
    
    try {
      // Test 1: LLM service integration validation
      console.log('📝 Test 1: LLM Service Integration Validation');
      await this.testLLMServiceIntegration();

      // Test 2: Search service compatibility validation
      console.log('\n📝 Test 2: Search Service Compatibility Validation');
      await this.testSearchServiceCompatibility();

      // Test 3: E2E test script validation
      console.log('\n📝 Test 3: E2E Test Script Validation');
      await this.testE2EScriptStructure();

      // Test 4: Integration points validation
      console.log('\n📝 Test 4: Integration Points Validation');
      await this.testIntegrationPoints();

      // Summary
      this.printSummary();

    } catch (error) {
      console.error('❌ Test execution failed:', error.message);
      process.exit(1);
    }
  }

  async testLLMServiceIntegration() {
    try {
      // Check LLM service file
      const llmServicePath = path.join(__dirname, 'src', 'services', 'llm.service.js');
      const llmServiceExists = await fs.access(llmServicePath).then(() => true).catch(() => false);
      
      this.assert(
        llmServiceExists,
        'LLM service file should exist'
      );

      if (llmServiceExists) {
        const llmServiceContent = await fs.readFile(llmServicePath, 'utf8');
        
        // Test enhanced findProduct tool
        this.assert(
          llmServiceContent.includes('findProduct'),
          'Should have findProduct tool'
        );

        this.assert(
          llmServiceContent.includes('advanced hybrid search'),
          'findProduct description should mention advanced hybrid search'
        );

        this.assert(
          llmServiceContent.includes('corrects typos'),
          'findProduct description should mention typo correction'
        );

        this.assert(
          llmServiceContent.includes('searchProducts'),
          'Should import and use searchProducts from search service'
        );

        // Test enhanced system prompt
        this.assert(
          llmServiceContent.includes('Search Result Interpretation Rules'),
          'Should have detailed search result interpretation rules'
        );

        this.assert(
          llmServiceContent.includes('success: true'),
          'Should have rules for handling successful search results'
        );

        this.assert(
          llmServiceContent.includes('success: false'),
          'Should have rules for handling unsuccessful search results'
        );

        this.assert(
          llmServiceContent.includes('Context Rule'),
          'Should have context handling rules'
        );

        this.assert(
          llmServiceContent.includes('Language Rule'),
          'Should have language matching rules'
        );

        console.log('✅ LLM service integration validation passed');
      }
      
    } catch (error) {
      console.log('❌ LLM service integration test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testSearchServiceCompatibility() {
    try {
      // Check search service file
      const searchServicePath = path.join(__dirname, 'src', 'services', 'search.service.js');
      const searchServiceExists = await fs.access(searchServicePath).then(() => true).catch(() => false);
      
      this.assert(
        searchServiceExists,
        'Search service file should exist'
      );

      if (searchServiceExists) {
        const searchServiceContent = await fs.readFile(searchServicePath, 'utf8');
        
        this.assert(
          searchServiceContent.includes('searchProducts'),
          'Should export searchProducts function'
        );

        this.assert(
          searchServiceContent.includes('hybridSearch'),
          'Should have hybridSearch function'
        );

        this.assert(
          searchServiceContent.includes('success'),
          'searchProducts should return success field'
        );

        this.assert(
          searchServiceContent.includes('results'),
          'searchProducts should return results array'
        );

        this.assert(
          searchServiceContent.includes('metadata'),
          'searchProducts should return metadata'
        );

        this.assert(
          searchServiceContent.includes('performFTSSearch'),
          'Should have FTS search capability'
        );

        this.assert(
          searchServiceContent.includes('performVectorSearch'),
          'Should have vector search capability'
        );

        this.assert(
          searchServiceContent.includes('applyLevenshteinFilter'),
          'Should have Levenshtein filtering capability'
        );

        console.log('✅ Search service compatibility validation passed');
      }
      
    } catch (error) {
      console.log('❌ Search service compatibility test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testE2EScriptStructure() {
    try {
      // Check E2E test script
      const e2eTestPath = path.join(__dirname, 'test_agent_search_e2e.js');
      const e2eTestExists = await fs.access(e2eTestPath).then(() => true).catch(() => false);
      
      this.assert(
        e2eTestExists,
        'E2E test script should exist'
      );

      if (e2eTestExists) {
        const e2eTestContent = await fs.readFile(e2eTestPath, 'utf8');
        
        this.assert(
          e2eTestContent.includes('sendMessage'),
          'Should import sendMessage from LLM service'
        );

        // Test scenario coverage
        this.assert(
          e2eTestContent.includes('testExactMatch'),
          'Should have exact match test scenario'
        );

        this.assert(
          e2eTestContent.includes('testTypoCorrection'),
          'Should have typo correction test scenario'
        );

        this.assert(
          e2eTestContent.includes('testSemanticSearch'),
          'Should have semantic search test scenario'
        );

        this.assert(
          e2eTestContent.includes('testNoMatch'),
          'Should have no match test scenario'
        );

        this.assert(
          e2eTestContent.includes('testContextualFollowup'),
          'Should have contextual follow-up test scenario'
        );

        // Test specific query examples
        this.assert(
          e2eTestContent.includes('Super Widget'),
          'Should test for Super Widget exact match'
        );

        this.assert(
          e2eTestContent.includes('supr widge'),
          'Should test typo correction with "supr widge"'
        );

        this.assert(
          e2eTestContent.includes('container for hot coffee'),
          'Should test semantic search with coffee container query'
        );

        this.assert(
          e2eTestContent.includes('flying car'),
          'Should test no match with "flying car"'
        );

        this.assert(
          e2eTestContent.includes('chatHistory'),
          'Should maintain conversation history'
        );

        console.log('✅ E2E test script structure validation passed');
      }
      
    } catch (error) {
      console.log('❌ E2E test script structure test failed:', error.message);
      this.testsFailed++;
    }
  }

  async testIntegrationPoints() {
    try {
      // Check that all necessary services and utilities exist
      const requiredFiles = [
        'src/services/search.service.js',
        'src/services/llm.service.js',
        'src/services/embedding.service.js',
        'src/utils/levenshtein.js'
      ];

      for (const filePath of requiredFiles) {
        const fullPath = path.join(__dirname, filePath);
        const exists = await fs.access(fullPath).then(() => true).catch(() => false);
        
        this.assert(
          exists,
          `Required file should exist: ${filePath}`
        );
      }

      // Check levenshtein utility specifically
      const levenshteinPath = path.join(__dirname, 'src', 'utils', 'levenshtein.js');
      const levenshteinExists = await fs.access(levenshteinPath).then(() => true).catch(() => false);
      
      if (levenshteinExists) {
        const levenshteinContent = await fs.readFile(levenshteinPath, 'utf8');
        
        this.assert(
          levenshteinContent.includes('calculateLevenshtein'),
          'Levenshtein utility should export calculateLevenshtein'
        );

        this.assert(
          levenshteinContent.includes('isSimilar'),
          'Levenshtein utility should export isSimilar'
        );
      }

      console.log('✅ Integration points validation passed');
      
    } catch (error) {
      console.log('❌ Integration points test failed:', error.message);
      this.testsFailed++;
    }
  }

  assert(condition, message) {
    if (condition) {
      this.testsPassed++;
      this.results.push({ status: 'PASS', message });
    } else {
      this.testsFailed++;
      this.results.push({ status: 'FAIL', message });
      throw new Error(message);
    }
  }

  printSummary() {
    console.log('\n' + '='.repeat(60));
    console.log('📊 PHASE 3 STRUCTURE TEST SUMMARY');
    console.log('='.repeat(60));
    console.log(`✅ Tests Passed: ${this.testsPassed}`);
    console.log(`❌ Tests Failed: ${this.testsFailed}`);
    console.log(`📈 Success Rate: ${(this.testsPassed / (this.testsPassed + this.testsFailed) * 100).toFixed(1)}%`);
    
    if (this.testsFailed === 0) {
      console.log('\n🎉 Phase 3 Structure Validation: SUCCESS');
      console.log('All hybrid search integration components are properly implemented!');
      console.log('\n📋 Ready Components:');
      console.log('• Enhanced findProduct LangChain tool');
      console.log('• Detailed search result interpretation rules');
      console.log('• Comprehensive E2E test scenarios');
      console.log('• Complete integration with existing search service');
      console.log('\n🧪 Next Steps:');
      console.log('1. Ensure GEMINI_API_KEY is configured');
      console.log('2. Run database import: node src/lib/cli.js import-mdf test-sample-mdf.json --force');
      console.log('3. Run E2E tests: node test_agent_search_e2e.js');
    } else {
      console.log('\n💥 Phase 3 Structure Validation: FAILED');
      console.log('Some implementation issues detected. Check the detailed output above.');
    }
    
    console.log('\n📋 Detailed Results:');
    this.results.forEach((result, index) => {
      const icon = result.status === 'PASS' ? '✅' : '❌';
      console.log(`${icon} ${index + 1}. ${result.message}`);
    });
  }
}

// Run tests if called directly
if (require.main === module) {
  const test = new Phase3StructureTest();
  test.runTests().catch(error => {
    console.error('Test execution failed:', error);
    process.exit(1);
  });
}

module.exports = Phase3StructureTest;

--- File: /packages/backend/test_real_search.js ---

require('dotenv').config({ path: '../../.env' });
const { searchProducts } = require('./src/services/search.service');

console.log('Testing with REAL Gemini embeddings...');

searchProducts('кружка').then(result => {
  console.log('\n=== REAL GEMINI SEARCH RESULTS ===');
  console.log('Success:', result.success);
  console.log('Message:', result.message);
  console.log('Search Method:', result.metadata?.searchMethod);
  console.log('Execution Time:', result.metadata?.executionTime + 'ms');
  
  if (result.results && result.results.length > 0) {
    console.log('\nFound Products:');
    result.results.forEach((item, i) => {
      console.log(`${i+1}. ${item.productName} - ${item.price}€`);
      if (item.similarity) console.log(`   Similarity: ${item.similarity}%`);
      if (item.levenshteinDistance !== undefined) console.log(`   Edit Distance: ${item.levenshteinDistance}`);
    });
  }
}).catch(err => {
  console.error('Error:', err);
}).finally(() => {
  process.exit(0);
});

--- File: /packages/backend/test_reporting_direct.js ---

#!/usr/bin/env node

/**
 * Direct test of the reporting service
 */

require('dotenv').config({ path: '../../.env' });
const { generateSalesReport } = require('./src/services/reporting.service.js');

async function testReportingService() {
    console.log('🧪 Testing reporting service directly...');
    
    try {
        const report = await generateSalesReport({ period: 'today' });
        console.log('\n📊 Report Result:');
        console.log(JSON.stringify(report, null, 2));
        
        if (report.success) {
            console.log('\n✅ Reporting service is working correctly!');
            console.log(`📈 Total Revenue: ${report.data.totalRevenue}`);
            console.log(`📊 Transaction Count: ${report.data.transactionCount}`);
            console.log(`💰 Average Sale: ${report.data.averageSale}`);
        } else {
            console.log('\n❌ Reporting service returned an error:');
            console.log(report.message);
        }
        
    } catch (error) {
        console.error('❌ Test failed with error:', error.message);
        console.error('Stack:', error.stack);
        process.exit(1);
    }
}

testReportingService();

--- File: /packages/backend/test_research_agent.js ---

// Test script for the Research Agent implementation
// Run with: node test_research_agent.js

require('dotenv').config({ path: '../../.env' });
const { runResearch } = require('./src/services/research.service');
const logger = require('./src/config/logger');

async function testResearchAgent() {
    console.log('🧪 Testing Research Agent implementation...\n');
    
    // Check if required environment variables are set
    if (!process.env.TAVILY_API_KEY) {
        console.error('❌ TAVILY_API_KEY is not set in .env file');
        console.log('Please add your Tavily API key to the .env file');
        console.log('Get one at: https://tavily.com/');
        return;
    }
    
    if (!process.env.GEMINI_API_KEY) {
        console.error('❌ GEMINI_API_KEY is not set in .env file');
        console.log('Please add your Gemini API key to the .env file');
        return;
    }
    
    console.log('✅ Environment variables are set');
    
    // Test queries for different scenarios
    const testQueries = [
        "What are the main ingredients in Tiramisu?",
        "Find information about German VAT rates for restaurants in 2025",
        "What cuisine type is Pad Thai and what are its main ingredients?"
    ];
    
    for (const [index, query] of testQueries.entries()) {
        console.log(`\n📝 Test ${index + 1}: "${query}"`);
        console.log('=' .repeat(50));
        
        try {
            const result = await runResearch(query);
            
            if (result.success) {
                console.log('✅ Research successful!');
                console.log(`📊 Summary length: ${result.summary?.length || 0} characters`);
                console.log(`📖 Sources: ${result.sources}`);
                console.log(`📝 Preview: ${result.summary?.substring(0, 200)}...`);
            } else {
                console.log('❌ Research failed');
                console.log(`🔍 Error: ${result.error}`);
                console.log(`💡 Fallback: ${result.fallback}`);
            }
        } catch (error) {
            console.error(`💥 Test failed with exception: ${error.message}`);
        }
        
        // Wait between tests to avoid rate limits
        if (index < testQueries.length - 1) {
            console.log('⏳ Waiting 2 seconds before next test...');
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
    
    console.log('\n🎯 Research Agent testing completed!');
}

// Run the test
testResearchAgent().catch(error => {
    console.error('💥 Test runner failed:', error);
    process.exit(1);
});

--- File: /packages/backend/test_research_basic.js ---

// Test basic research functionality without Tavily API
// Run with: node test_research_basic.js

require('dotenv').config({ path: '../../.env' });
const { runResearch } = require('./src/services/research.service');

async function testBasicResearch() {
    console.log('🧪 Testing Basic Research Functionality...\n');
    
    // Test a simple query
    const query = "What are the main ingredients in Tiramisu?";
    console.log(`📝 Testing query: "${query}"`);
    console.log('=' .repeat(50));
    
    try {
        const result = await runResearch(query);
        
        console.log('📊 Result:', JSON.stringify(result, null, 2));
        
        if (result.success) {
            console.log('✅ Research completed successfully!');
        } else {
            console.log('⚠️ Research failed as expected (no Tavily API key)');
            console.log('💡 This is normal behavior when API key is not configured');
        }
        
    } catch (error) {
        console.error('💥 Test failed with exception:', error.message);
        console.error('Stack:', error.stack);
    }
    
    console.log('\n🎯 Basic research test completed!');
}

testBasicResearch().catch(error => {
    console.error('💥 Test runner failed:', error);
    process.exit(1);
});

--- File: /packages/backend/test_research_structure.js ---

// Test script to validate the research service structure
// Run with: node test_research_structure.js

require('dotenv').config({ path: '../../.env' });
console.log('🧪 Testing Research Service Structure...\n');

try {
    // Test basic imports
    console.log('📦 Testing imports...');
    const { runResearch } = require('./src/services/research.service');
    console.log('✅ research.service.js imports successfully');
    
    // Test LLM service integration
    const { sendMessage } = require('./src/services/llm.service');
    console.log('✅ llm.service.js imports successfully');
    
    // Test function signatures
    console.log('\n🔍 Testing function signatures...');
    console.log('runResearch type:', typeof runResearch);
    console.log('sendMessage type:', typeof sendMessage);
    
    if (typeof runResearch === 'function') {
        console.log('✅ runResearch is a function');
    } else {
        console.log('❌ runResearch is not a function');
    }
    
    if (typeof sendMessage === 'function') {
        console.log('✅ sendMessage is a function');
    } else {
        console.log('❌ sendMessage is not a function');
    }
    
    console.log('\n🎯 Structure validation completed successfully!');
    console.log('\n📋 Next steps:');
    console.log('1. Add your Tavily API key to .env file');
    console.log('2. Test with: node test_research_agent.js');
    console.log('3. Or test through the main application');
    
} catch (error) {
    console.error('💥 Structure validation failed:', error.message);
    console.error('Stack:', error.stack);
    process.exit(1);
}

--- File: /packages/backend/test_sales_report_only.js ---

#!/usr/bin/env node

/**
 * Quick test for getSalesReport functionality
 */

require('dotenv').config({ path: '../../.env' });
const { sendMessage } = require('./src/services/llm.service.js');

async function testSalesReport() {
    console.log('🧪 Testing getSalesReport tool...');
    
    try {
        const query = "покажи отчет о продажах за сегодня";
        console.log(`Query: "${query}"`);
        
        const startTime = Date.now();
        const response = await sendMessage(query, []);
        const endTime = Date.now();
        
        console.log(`\n📊 Response: ${response.text}`);
        console.log(`⏱️ Duration: ${endTime - startTime}ms`);
        
        // Check if response contains real data indicators
        const responseText = response.text.toLowerCase();
        const hasRealData = responseText.includes('revenue') || 
                           responseText.includes('доход') || 
                           responseText.includes('transaction') ||
                           responseText.includes('транзакци') ||
                           responseText.includes('отчет') ||
                           responseText.includes('report');
        
        console.log(`\n✅ Test Result: ${hasRealData ? 'PASS - Real data detected' : 'FAIL - No real data detected'}`);
        
        if (hasRealData) {
            console.log('🎉 getSalesReport tool is working with real database data!');
        } else {
            console.log('❌ getSalesReport tool may still be using stub data');
        }
        
    } catch (error) {
        console.error('❌ Test failed with error:', error.message);
        process.exit(1);
    }
}

testSalesReport();

--- File: /packages/backend/test_sample_mdf.json ---

{
  "$schema": "https://schemas.eckasse.com/oop-pos-mdf/v2.0.0/schema.json",
  "company_details": {
    "company_unique_identifier": 1,
    "company_full_name": "Test Restaurant für Enrichment",
    "meta_information": {
      "format_version": "2.0.0",
      "date_generated": "2025-01-08T15:30:00.000Z",
      "generated_by": "eckasse-test",
      "default_currency_symbol": "€",
      "default_language": "de",
      "supported_languages": ["de", "en"],
      "audit_trail": {
        "created_at": "2025-01-08T15:30:00.000Z",
        "created_by": "test@eckasse.com",
        "last_modified_at": "2025-01-08T15:30:00.000Z",
        "last_modified_by": "test@eckasse.com",
        "version": 1,
        "change_log": []
      }
    },
    "global_configurations": {
      "tax_rates_definitions": [
        {
          "tax_rate_unique_identifier": 1,
          "tax_rate_names": { "de": "Standard (19%)", "en": "Standard (19%)" },
          "rate_percentage": 19.0,
          "fiscal_mapping_type": "NORMAL"
        }
      ],
      "main_groups_definitions": [],
      "payment_methods_definitions": [
        {
          "payment_method_unique_identifier": 1,
          "payment_method_names": { "de": "Bar", "en": "Cash" },
          "payment_method_type": "CASH"
        }
      ],
      "promotions_definitions": [],
      "workflows": [],
      "integrations": {},
      "security_settings": {
        "encryption": { "at_rest": true, "in_transit": true, "algorithm": "AES-256" },
        "access_control": { "session_timeout": 3600, "max_failed_attempts": 3, "lockout_duration": 900, "require_2fa": false },
        "data_privacy": { "gdpr_compliance": true, "data_retention_days": 2555, "anonymization_rules": [] }
      }
    },
    "branches": [
      {
        "branch_unique_identifier": 1,
        "branch_names": { "de": "Hauptfiliale", "en": "Main Branch" },
        "branch_address": "Teststraße 123, 12345 Teststadt",
        "point_of_sale_devices": [
          {
            "pos_device_unique_identifier": 1,
            "pos_device_names": { "de": "Kasse 1", "en": "POS 1" },
            "pos_device_type": "DESKTOP",
            "pos_device_external_number": 1,
            "pos_device_settings": {
              "default_currency_identifier": "€",
              "default_linked_drink_tax_rate_unique_identifier": 1,
              "default_linked_food_tax_rate_unique_identifier": 1
            },
            "categories_for_this_pos": [
              {
                "category_unique_identifier": 1,
                "category_names": { "de": "Vorspeisen" },
                "category_type": "food",
                "linked_tax_rate_unique_identifier": 1,
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              },
              {
                "category_unique_identifier": 2,
                "category_names": { "de": "Hauptgerichte" },
                "category_type": "food",
                "linked_tax_rate_unique_identifier": 1,
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              },
              {
                "category_unique_identifier": 3,
                "category_names": { "de": "Getränke" },
                "category_type": "drink",
                "linked_tax_rate_unique_identifier": 1,
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              }
            ],
            "items_for_this_pos": [
              {
                "item_unique_identifier": 1,
                "display_names": {
                  "menu": { "de": "Bruschetta al Pomodoro" },
                  "button": { "de": "Bruschetta" },
                  "receipt": { "de": "Bruschetta al Pomodoro" }
                },
                "item_price_value": 8.50,
                "linked_category_unique_identifier": 1,
                "linked_tax_rate_unique_identifier": 1,
                "item_flags": {
                  "is_sellable": true,
                  "has_negative_price": false,
                  "requires_age_verification": false,
                  "is_scale_item": false
                },
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              },
              {
                "item_unique_identifier": 2,
                "display_names": {
                  "menu": { "de": "Spaghetti Carbonara" },
                  "button": { "de": "Carbonara" },
                  "receipt": { "de": "Spaghetti Carbonara" }
                },
                "item_price_value": 14.90,
                "linked_category_unique_identifier": 2,
                "linked_tax_rate_unique_identifier": 1,
                "item_flags": {
                  "is_sellable": true,
                  "has_negative_price": false,
                  "requires_age_verification": false,
                  "is_scale_item": false
                },
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              },
              {
                "item_unique_identifier": 3,
                "display_names": {
                  "menu": { "de": "Pizza Margherita" },
                  "button": { "de": "Pizza Marg" },
                  "receipt": { "de": "Pizza Margherita" }
                },
                "item_price_value": 12.50,
                "linked_category_unique_identifier": 2,
                "linked_tax_rate_unique_identifier": 1,
                "item_flags": {
                  "is_sellable": true,
                  "has_negative_price": false,
                  "requires_age_verification": false,
                  "is_scale_item": false
                },
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              },
              {
                "item_unique_identifier": 4,
                "display_names": {
                  "menu": { "de": "Chianti Classico DOCG" },
                  "button": { "de": "Chianti" },
                  "receipt": { "de": "Chianti Classico DOCG" }
                },
                "item_price_value": 28.00,
                "linked_category_unique_identifier": 3,
                "linked_tax_rate_unique_identifier": 1,
                "item_flags": {
                  "is_sellable": true,
                  "has_negative_price": false,
                  "requires_age_verification": true,
                  "is_scale_item": false
                },
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              },
              {
                "item_unique_identifier": 5,
                "display_names": {
                  "menu": { "de": "Tiramisù della Casa" },
                  "button": { "de": "Tiramisu" },
                  "receipt": { "de": "Tiramisù della Casa" }
                },
                "item_price_value": 6.90,
                "linked_category_unique_identifier": 1,
                "linked_tax_rate_unique_identifier": 1,
                "item_flags": {
                  "is_sellable": true,
                  "has_negative_price": false,
                  "requires_age_verification": false,
                  "is_scale_item": false
                },
                "audit_trail": {
                  "created_at": "2025-01-08T15:30:00.000Z",
                  "created_by": "test@eckasse.com",
                  "version": 1
                }
              }
            ]
          }
        ]
      }
    ]
  }
}

--- File: /packages/backend/test_search.js ---

const { searchProducts } = require('./src/services/search.service');

console.log('Testing hybrid search for "кружка"...');

searchProducts('кружка').then(result => {
  console.log('\n=== SEARCH RESULTS ===');
  console.log('Success:', result.success);
  console.log('Message:', result.message);
  console.log('Search Method:', result.metadata?.searchMethod);
  console.log('Execution Time:', result.metadata?.executionTime + 'ms');
  
  if (result.results && result.results.length > 0) {
    console.log('\nFound Products:');
    result.results.forEach((item, i) => {
      console.log(`${i+1}. ${item.productName} - ${item.price}€`);
      if (item.similarity) console.log(`   Similarity: ${item.similarity}%`);
      if (item.levenshteinDistance !== undefined) console.log(`   Edit Distance: ${item.levenshteinDistance}`);
    });
  } else {
    console.log('\nNo products found.');
  }
}).catch(err => {
  console.error('Error:', err);
}).finally(() => {
  process.exit(0);
});

--- File: /packages/backend/test_user_management_flow.js ---

#!/usr/bin/env node

/**
 * Test script for Two-Level Management System
 * Tests authentication, pending changes, and storno credit system
 */

const WebSocket = require('ws');
const { v4: uuidv4 } = require('uuid');

class EcKasseTestClient {
    constructor(url = 'ws://localhost:3030') {
        this.url = url;
        this.ws = null;
        this.pendingRequests = new Map();
        this.requestTimeout = 5000; // 5 seconds
    }

    async connect() {
        return new Promise((resolve, reject) => {
            this.ws = new WebSocket(this.url);
            
            this.ws.on('open', () => {
                console.log('🔗 Connected to WebSocket server');
                resolve();
            });

            this.ws.on('message', (data) => {
                try {
                    const message = JSON.parse(data.toString());
                    this.handleMessage(message);
                } catch (error) {
                    console.error('❌ Failed to parse message:', error.message);
                }
            });

            this.ws.on('error', (error) => {
                console.error('❌ WebSocket error:', error.message);
                reject(error);
            });

            this.ws.on('close', () => {
                console.log('🔌 WebSocket connection closed');
            });
        });
    }

    handleMessage(message) {
        const { operationId, status, payload } = message;
        
        if (this.pendingRequests.has(operationId)) {
            const { resolve, reject } = this.pendingRequests.get(operationId);
            this.pendingRequests.delete(operationId);
            
            if (status === 'success') {
                resolve(payload);
            } else {
                reject(new Error(payload?.error || payload?.message || 'Unknown error'));
            }
        }
    }

    async sendCommand(command, payload = {}) {
        const operationId = uuidv4();
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(operationId);
                reject(new Error(`Request timeout for command: ${command}`));
            }, this.requestTimeout);

            this.pendingRequests.set(operationId, {
                resolve: (result) => {
                    clearTimeout(timeout);
                    resolve(result);
                },
                reject: (error) => {
                    clearTimeout(timeout);
                    reject(error);
                }
            });

            const message = {
                operationId,
                command,
                payload
            };

            this.ws.send(JSON.stringify(message));
        });
    }

    async close() {
        if (this.ws) {
            this.ws.close();
        }
    }
}

// Test scenarios
class UserManagementTests {
    constructor() {
        this.client = new EcKasseTestClient();
        this.adminSession = null;
        this.cashierSession = null;
        this.productId = null;
        this.testResults = {
            passed: 0,
            failed: 0,
            tests: []
        };
    }

    log(emoji, message) {
        console.log(`${emoji} ${message}`);
    }

    async test(name, testFn) {
        try {
            this.log('🧪', `Testing: ${name}`);
            await testFn();
            this.log('✅', `PASSED: ${name}`);
            this.testResults.passed++;
            this.testResults.tests.push({ name, status: 'PASSED' });
        } catch (error) {
            this.log('❌', `FAILED: ${name} - ${error.message}`);
            this.testResults.failed++;
            this.testResults.tests.push({ name, status: 'FAILED', error: error.message });
        }
    }

    async runAllTests() {
        try {
            await this.client.connect();
            
            this.log('🚀', 'Starting Two-Level Management System Tests...\n');

            // Authentication tests
            await this.test('Admin login', async () => {
                const result = await this.client.sendCommand('login', {
                    username: 'admin',
                    password: 'eckasse123',
                    ipAddress: '127.0.0.1',
                    userAgent: 'test-client'
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Login failed');
                }
                
                this.adminSession = result.session.sessionId;
                this.log('📝', `Admin session: ${this.adminSession}`);
            });

            await this.test('Cashier login', async () => {
                const result = await this.client.sendCommand('login', {
                    username: 'cashier1',
                    password: 'eckasse123',
                    ipAddress: '127.0.0.1',
                    userAgent: 'test-client'
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Login failed');
                }
                
                this.cashierSession = result.session.sessionId;
                this.log('📝', `Cashier session: ${this.cashierSession}`);
            });

            // Permission tests
            await this.test('Admin can edit products', async () => {
                const result = await this.client.sendCommand('canPerformAction', {
                    sessionId: this.adminSession,
                    action: 'edit_products'
                });
                
                if (!result.canPerform) {
                    throw new Error('Admin should be able to edit products');
                }
            });

            await this.test('Cashier cannot edit products directly', async () => {
                const result = await this.client.sendCommand('canPerformAction', {
                    sessionId: this.cashierSession,
                    action: 'edit_products'
                });
                
                if (result.canPerform) {
                    throw new Error('Cashier should not be able to edit products directly');
                }
            });

            // Get a product to test with
            await this.test('Get existing products', async () => {
                const categories = await this.client.sendCommand('getCategories', {});
                if (categories.length === 0) {
                    throw new Error('No categories found');
                }
                
                const products = await this.client.sendCommand('getItemsByCategory', {
                    categoryId: categories[0].id
                });
                
                if (!products.success || products.data.length === 0) {
                    throw new Error('No products found');
                }
                
                this.productId = products.data[0].id;
                this.log('📝', `Using product ID: ${this.productId}`);
            });

            // Pending changes tests
            await this.test('Cashier creates pending change', async () => {
                const result = await this.client.sendCommand('updateProduct', {
                    sessionId: this.cashierSession,
                    productId: this.productId,
                    updates: {
                        name: 'Updated Product Name',
                        price: 25.99,
                        reason: 'Price adjustment for test'
                    }
                });
                
                if (result.type !== 'pending_change') {
                    throw new Error('Expected pending change creation');
                }
                
                this.log('📝', `Pending change created: ${result.changeId}`);
                this.pendingChangeId = result.changeId;
            });

            await this.test('Manager can see pending changes', async () => {
                const result = await this.client.sendCommand('getPendingChanges', {
                    sessionId: this.adminSession
                });
                
                if (!result.success || result.changes.length === 0) {
                    throw new Error('No pending changes found');
                }
                
                this.log('📝', `Found ${result.changes.length} pending changes`);
            });

            await this.test('Manager approves pending change', async () => {
                const result = await this.client.sendCommand('approveChange', {
                    sessionId: this.adminSession,
                    changeId: this.pendingChangeId,
                    approvalNotes: 'Approved for testing'
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to approve change');
                }
                
                this.log('📝', 'Change approved successfully');
            });

            // Storno credit tests
            await this.test('Cashier performs automatic storno', async () => {
                const result = await this.client.sendCommand('performStorno', {
                    sessionId: this.cashierSession,
                    transactionId: 'test-transaction-001',
                    amount: 15.50,
                    reason: 'Customer requested refund - test',
                    isEmergency: false
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Storno failed');
                }
                
                if (result.storno.type !== 'automatic') {
                    throw new Error('Expected automatic storno approval');
                }
                
                this.log('📝', `Automatic storno processed: €${result.storno.amount}`);
            });

            await this.test('Cashier exceeds credit limit - requires approval', async () => {
                const result = await this.client.sendCommand('performStorno', {
                    sessionId: this.cashierSession,
                    transactionId: 'test-transaction-002',
                    amount: 75.00, // Should exceed daily limit
                    reason: 'Large refund - exceeds limit',
                    isEmergency: false
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Storno request failed');
                }
                
                if (result.storno.type !== 'pending_approval') {
                    throw new Error('Expected pending approval for large storno');
                }
                
                this.log('📝', `Pending storno created: €${result.storno.amount}`);
                this.pendingStornoId = result.storno.id;
            });

            await this.test('Manager can see pending stornos', async () => {
                const result = await this.client.sendCommand('getPendingStornos', {
                    sessionId: this.adminSession
                });
                
                if (!result.success || result.stornos.length === 0) {
                    throw new Error('No pending stornos found');
                }
                
                this.log('📝', `Found ${result.stornos.length} pending stornos`);
            });

            await this.test('Manager approves pending storno', async () => {
                const result = await this.client.sendCommand('approveStorno', {
                    managerSessionId: this.adminSession,
                    stornoId: this.pendingStornoId,
                    approvalNotes: 'Approved large refund for testing'
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to approve storno');
                }
                
                this.log('📝', 'Storno approved successfully');
            });

            // Manager dashboard test
            await this.test('Manager dashboard shows statistics', async () => {
                const result = await this.client.sendCommand('getManagerDashboard', {
                    sessionId: this.adminSession
                });
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to get dashboard stats');
                }
                
                this.log('📝', `Dashboard stats: ${JSON.stringify(result.stats, null, 2)}`);
            });

            // Logout tests
            await this.test('Admin logout', async () => {
                const result = await this.client.sendCommand('logout', {
                    sessionId: this.adminSession
                });
                
                if (!result.success) {
                    throw new Error('Admin logout failed');
                }
            });

            await this.test('Cashier logout', async () => {
                const result = await this.client.sendCommand('logout', {
                    sessionId: this.cashierSession
                });
                
                if (!result.success) {
                    throw new Error('Cashier logout failed');
                }
            });

        } catch (error) {
            this.log('💥', `Test suite failed: ${error.message}`);
        } finally {
            await this.client.close();
            this.showResults();
        }
    }

    showResults() {
        console.log('\n' + '='.repeat(60));
        console.log('📊 TEST RESULTS');
        console.log('='.repeat(60));
        console.log(`✅ Passed: ${this.testResults.passed}`);
        console.log(`❌ Failed: ${this.testResults.failed}`);
        console.log(`📈 Total:  ${this.testResults.passed + this.testResults.failed}`);
        
        if (this.testResults.failed > 0) {
            console.log('\n❌ FAILED TESTS:');
            this.testResults.tests
                .filter(test => test.status === 'FAILED')
                .forEach(test => {
                    console.log(`   - ${test.name}: ${test.error}`);
                });
        }
        
        console.log('\n' + '='.repeat(60));
        
        if (this.testResults.failed === 0) {
            console.log('🎉 ALL TESTS PASSED! Two-Level Management System is working correctly.');
        } else {
            console.log('⚠️  Some tests failed. Please check the implementation.');
            process.exit(1);
        }
    }
}

// Run tests if script is executed directly
if (require.main === module) {
    const tests = new UserManagementTests();
    
    // Handle graceful shutdown
    process.on('SIGINT', async () => {
        console.log('\n🛑 Test interrupted by user');
        await tests.client.close();
        process.exit(0);
    });
    
    tests.runAllTests().catch(console.error);
}

module.exports = UserManagementTests;

--- File: /packages/backend/verify_enrichment.js ---

#!/usr/bin/env node

/**
 * Quick verification script to demonstrate enrichment functionality
 */

const fs = require('fs');
const path = require('path');

async function showEnrichmentExample() {
    console.log('🔬 eckasse MDF Enrichment - Example Output\n');
    
    // Show what the enrichment process would produce
    const exampleEnriched = {
        company_details: {
            company_full_name: "Test Restaurant für Enrichment",
            meta_information: {
                format_version: "2.0.0",
                enriched_at: "2025-01-08T15:45:00.000Z",
                enriched_by: "eckasse-enrichment-service",
                audit_trail: {
                    change_log: [
                        {
                            timestamp: "2025-01-08T15:45:00.000Z",
                            change_type: "enrichment",
                            description: "Multi-pass AI enrichment applied"
                        }
                    ]
                }
            },
            global_configurations: {
                main_groups_definitions: [
                    {
                        main_group_unique_identifier: 1,
                        main_group_names: { de: "Vorspeisen" }
                    },
                    {
                        main_group_unique_identifier: 2,
                        main_group_names: { de: "Hauptgerichte" }
                    },
                    {
                        main_group_unique_identifier: 3,
                        main_group_names: { de: "Getränke" }
                    },
                    {
                        main_group_unique_identifier: 4,
                        main_group_names: { de: "Desserts" }
                    }
                ]
            },
            branches: [
                {
                    point_of_sale_devices: [
                        {
                            categories_for_this_pos: [
                                {
                                    category_unique_identifier: 1,
                                    category_names: { de: "Vorspeisen" },
                                    default_linked_main_group_unique_identifier: 1
                                },
                                {
                                    category_unique_identifier: 2,
                                    category_names: { de: "Hauptgerichte" },
                                    default_linked_main_group_unique_identifier: 2
                                },
                                {
                                    category_unique_identifier: 3,
                                    category_names: { de: "Getränke" },
                                    default_linked_main_group_unique_identifier: 3
                                }
                            ],
                            items_for_this_pos: [
                                {
                                    item_unique_identifier: 1,
                                    display_names: {
                                        menu: { de: "Bruschetta al Pomodoro" },
                                        button: { de: "Bruschetta\nal Pomodoro" },
                                        receipt: { de: "Bruschetta al Pomodoro" }
                                    },
                                    item_price_value: 8.50,
                                    additional_item_attributes: {
                                        ai_enrichment: {
                                            cuisine: "Italian",
                                            ingredients: ["bread", "tomatoes", "basil", "olive oil"],
                                            mealType: "appetizer",
                                            enriched_at: "2025-01-08T15:45:00.000Z"
                                        }
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    };
    
    console.log('📋 Example Enrichment Results:\n');
    
    console.log('🏷️ Main Groups Generated:');
    exampleEnriched.company_details.global_configurations.main_groups_definitions.forEach((group, index) => {
        console.log(`   ${index + 1}. ${group.main_group_names.de} (ID: ${group.main_group_unique_identifier})`);
    });
    
    console.log('\n📂 Categories Assigned:');
    exampleEnriched.company_details.branches[0].point_of_sale_devices[0].categories_for_this_pos.forEach(category => {
        console.log(`   "${category.category_names.de}" → Main Group ID ${category.default_linked_main_group_unique_identifier}`);
    });
    
    console.log('\n🍽️ Items Enriched:');
    const item = exampleEnriched.company_details.branches[0].point_of_sale_devices[0].items_for_this_pos[0];
    console.log(`   Item: ${item.display_names.menu.de}`);
    console.log(`   Button: ${item.display_names.button.de.replace('\n', ' / ')}`);
    console.log(`   Cuisine: ${item.additional_item_attributes.ai_enrichment.cuisine}`);
    console.log(`   Meal Type: ${item.additional_item_attributes.ai_enrichment.mealType}`);
    console.log(`   Ingredients: ${item.additional_item_attributes.ai_enrichment.ingredients.join(', ')}`);
    
    console.log('\n✨ Enrichment Process Summary:');
    console.log('   Pass 1: ✅ Data validation and preparation');
    console.log('   Pass 2: ✅ Web search enrichment and abbreviation generation');
    console.log('   Pass 3: ✅ Main groups (Warengruppen) generation and assignment');
    console.log('   Pass 4: ✅ Final validation and metadata updates');
    
    console.log('\n🎯 Usage Example:');
    console.log('   node src/lib/cli.js enrich-mdf sample.json --output enriched.json');
    console.log('   node src/lib/cli.js enrich-mdf sample.json --skip-web-search --dry-run');
    
    console.log('\n💡 Benefits of Enrichment:');
    console.log('   • Adds cuisine and ingredient information to items');
    console.log('   • Generates optimized receipt and button abbreviations');
    console.log('   • Creates logical main groups (Warengruppen) for organization');
    console.log('   • Assigns categories to appropriate main groups');
    console.log('   • Enhances searchability and user experience');
    
    console.log('\n✅ Implementation complete and ready for use!');
}

showEnrichmentExample();

--- File: /packages/client-desktop/electron/main.js ---

// packages/client-desktop/electron/main.js
const { app, BrowserWindow, ipcMain } = require('electron');
const path = require('path');
const url = require('url');
require('dotenv').config({ path: path.resolve(__dirname, '../../../.env') });

let mainWindow;

// Порт backend сервера (теперь служит и API и статику)
const BACKEND_PORT = process.env.BACKEND_PORT || 3030;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  const startUrl =
    process.env.ELECTRON_START_URL ||
    (!app.isPackaged
      ? `http://localhost:${BACKEND_PORT}` // Backend serving built files
      : url.format({
          pathname: path.join(__dirname, '../src/renderer/dist/index.html'), // Production build
          protocol: 'file:',
          slashes: true,
        }));

  mainWindow.loadURL(startUrl);

  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools();
    
    // Suppress DevTools Autofill errors
    mainWindow.webContents.once('devtools-opened', () => {
      mainWindow.webContents.devToolsWebContents.executeJavaScript(`
        const originalError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          if (message.includes('Autofill.enable') || message.includes('Autofill.setAddresses')) {
            return; // Skip autofill errors
          }
          originalError.apply(console, args);
        };
      `);
    });
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

app.on('ready', () => {
  createWindow();
  console.log(`Electron app ready. Backend serving at http://localhost:${BACKEND_PORT}`);
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// IPC для получения URL бэкенда
ipcMain.handle('get-backend-url', () => {
  return `http://localhost:${BACKEND_PORT}`;
});



--- File: /packages/client-desktop/electron/preload.js ---

// C:\Users\xelth\eckasse\electron\preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  getBackendUrl: () => ipcRenderer.invoke('get-backend-url'),
  // Вы можете добавить сюда другие безопасные вызовы к main процессу, если потребуется
  // Например:
  // send: (channel, data) => ipcRenderer.send(channel, data),
  // on: (channel, func) => {
  //   const subscription = (event, ...args) => func(...args);
  //   ipcRenderer.on(channel, subscription);
  //   return () => ipcRenderer.removeListener(channel, subscription);
  // },
});

console.log('Preload script for ecKasse loaded.');

--- File: /packages/client-desktop/package.json ---

{
  "name": "@eckasse/client-desktop",
  "version": "0.1.0",
  "private": true,
  "description": "Desktop client for ecKasse POS system",
  "main": "electron/main.js", 
  "scripts": {
    "dev:electron:watch": "electron electron/main.js",
    "dev": "concurrently -k -n \"BACKEND,ELECTRON\" -c \"bgBlue.bold,bgMagenta.bold\" \"npm run dev:backend\" \"wait-on http://localhost:3030 && npm run dev:electron:watch\"",
    "start": "npm run dev", 
    "dev:backend": "npm run dev --workspace=@eckasse/backend",

    "build": "electron-builder", 
    "dist": "npm run build",
    "package-win": "electron-builder --win --x64",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,md,css,scss}\""
  },
  "dependencies": {
    "axios": "^1.9.0" 
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "cross-env": "^7.0.3",
    "electron": "^31.1.0",
    "electron-builder": "^24.13.3",
    "wait-on": "^7.2.0"
  },
  "build": { 
    "appId": "com.eckasse.client.desktop",
    "productName": "ecKasse",
    "files": [
      "electron/**/*",
      "src/renderer/public/**/*", 
      "src/renderer/server.js",
      "node_modules/**/*", 
      "package.json"
    ],
    "directories": {
      "buildResources": "assets/build", 
      "output": "release/"
    },
    "win": { "icon": "assets/build/icon.ico" },
    "mac": { "icon": "assets/build/icon.icns" },
    "linux": { "icon": "assets/build/icons" }
  }
}

--- File: /packages/client-desktop/src/renderer/dist/assets/index-Bgt0YSOv.css ---

html{font-size:16px}@media (max-width: 1200px){html{font-size:15px}}@media (max-width: 992px){html{font-size:14px}}@media (max-width: 768px){html{font-size:13px}}body{margin:0;display:flex;place-items:center;min-width:320px;min-height:100vh}.receipt-feed.svelte-1x7q16i{height:100%;display:flex;flex-direction:column}.loading.svelte-1x7q16i,.error.svelte-1x7q16i,.empty.svelte-1x7q16i{text-align:center;padding:20px;color:#aaa;font-style:italic}.error.svelte-1x7q16i{color:#ff6b6b}.receipt-list.svelte-1x7q16i{flex:1}.receipt-item.svelte-1x7q16i{border:1px solid #444;border-radius:6px;margin-bottom:8px;background:#333;transition:all .2s ease}.receipt-item.svelte-1x7q16i:hover{border-color:#666}.receipt-item.expanded.svelte-1x7q16i{border-color:#4a69bd;background:#383838}.receipt-summary.svelte-1x7q16i{display:flex;align-items:center;padding:12px;cursor:pointer;-webkit-user-select:none;user-select:none}.receipt-left.svelte-1x7q16i{flex:1;display:flex;flex-direction:column}.receipt-right.svelte-1x7q16i{display:flex;flex-direction:column;align-items:flex-end;margin-right:12px}.receipt-date.svelte-1x7q16i{font-size:12px;color:#aaa;margin-bottom:2px}.receipt-payment.svelte-1x7q16i{font-size:12px;color:#e0e0e0}.receipt-price.svelte-1x7q16i{font-size:16px;font-weight:700;margin-bottom:4px}.receipt-meta.svelte-1x7q16i{display:flex;flex-direction:column;align-items:flex-end;gap:2px}.receipt-main-line.svelte-1x7q16i{display:flex;align-items:center;gap:8px;margin-bottom:4px}.receipt-id-large.svelte-1x7q16i{font-size:18px;color:#4a69bd;font-weight:700}.receipt-table-large.svelte-1x7q16i{font-size:18px;color:peru;font-weight:700}.receipt-items-count.svelte-1x7q16i{font-size:11px;color:#888}.expand-icon.svelte-1x7q16i{color:#666;font-size:12px;transition:transform .2s ease}.receipt-item.expanded.svelte-1x7q16i .expand-icon:where(.svelte-1x7q16i){transform:rotate(0)}.receipt-details.svelte-1x7q16i{border-top:1px solid #444;padding:12px}.items-list.svelte-1x7q16i{margin-bottom:12px}.item-row.svelte-1x7q16i{display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px dashed #555;font-size:13px}.item-row.svelte-1x7q16i:last-child{border-bottom:none}.item-qty.svelte-1x7q16i{font-weight:700;color:#d32f2f;min-width:40px}.item-name.svelte-1x7q16i{flex:1;padding:0 8px}.item-price.svelte-1x7q16i{font-weight:700;color:#4caf50}.receipt-totals.svelte-1x7q16i{border-top:1px solid #555;padding-top:8px;margin-bottom:12px}.total-row.svelte-1x7q16i{display:flex;justify-content:space-between;font-size:13px;margin-bottom:4px}.total-row.total.svelte-1x7q16i{font-weight:700;font-size:14px;border-top:1px solid #666;padding-top:4px;margin-top:4px}.receipt-actions.svelte-1x7q16i{display:flex;gap:8px}.action-button.svelte-1x7q16i{background:#5a7a5a;border:none;color:#fff;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px;transition:background .2s ease}.action-button.svelte-1x7q16i:hover{background:#6a8a6a}.price.svelte-1x7q16i{color:#4caf50}.parked-orders-container.svelte-1yvjwnh{width:100%;margin-bottom:12px}.no-orders.svelte-1yvjwnh{display:flex;align-items:center;justify-content:center;height:44px;color:#888;font-style:italic;font-size:13px}.orders-list.svelte-1yvjwnh{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:2px}.order-item.svelte-1yvjwnh{background:#2c2c2e;border:1px solid #444;border-radius:8px;padding:8px;cursor:pointer;transition:all .2s ease;box-shadow:0 2px 4px #0000004d;aspect-ratio:2/1;display:flex;flex-direction:row;align-items:stretch;min-height:0}.order-item.svelte-1yvjwnh:hover{background:#3a3a3c;border-color:#666;transform:scale(1.02);box-shadow:0 4px 8px #0006}.table-number.svelte-1yvjwnh{display:flex;align-items:center;justify-content:center;background:#2e1a16;border-radius:4px;margin-right:8px;min-width:40px;width:50px;font-weight:900;font-size:18px;color:peru}.order-stats.svelte-1yvjwnh{flex:1;display:flex;flex-direction:column;justify-content:space-around;align-items:flex-end;gap:2px}.stat-price.svelte-1yvjwnh{font-weight:700;color:#5fb85f;font-size:14px}.stat-open.svelte-1yvjwnh{font-weight:600;color:#e0e0e0;font-size:12px}.stat-activity.svelte-1yvjwnh{font-weight:500;color:#aaa;font-size:12px}.console-view.svelte-1a8nv3l{background-color:#2c2c2e;color:#e0e0e0;display:flex;flex-direction:column;height:100%;box-sizing:border-box}.content-area.svelte-1a8nv3l{flex-grow:1;overflow:hidden}.view-content.svelte-1a8nv3l{padding:15px;height:100%;display:flex;flex-direction:column;box-sizing:border-box}.view-content.order-view.svelte-1a8nv3l,.view-content.receipts-view.svelte-1a8nv3l{padding:8px}.orders-stack.svelte-1a8nv3l{height:100%;display:flex;flex-direction:column;min-height:0;overflow-y:auto;-ms-overflow-style:none;scrollbar-width:none}.orders-stack.svelte-1a8nv3l::-webkit-scrollbar{display:none}.receipts-stack.svelte-1a8nv3l{height:100%;display:flex;flex-direction:column;min-height:0;overflow-y:auto;-ms-overflow-style:none;scrollbar-width:none}.receipts-stack.svelte-1a8nv3l::-webkit-scrollbar{display:none}.parked-orders-section.svelte-1a8nv3l{flex-shrink:0;margin-bottom:8px;display:flex;flex-direction:column-reverse}.active-order-section.svelte-1a8nv3l{flex:1 0 300px;display:flex;flex-direction:column}.order-content.svelte-1a8nv3l{flex-grow:1;display:flex;flex-direction:column;min-height:0}.scrollable-items-content.svelte-1a8nv3l{flex:0 1 auto;overflow-y:auto;min-height:0;margin-bottom:16px;-ms-overflow-style:none;scrollbar-width:none}.scrollable-items-content.svelte-1a8nv3l::-webkit-scrollbar{display:none}.spacer.svelte-1a8nv3l{flex-grow:1;min-height:0}.active-order-section.svelte-1a8nv3l h2:where(.svelte-1a8nv3l){margin:0 0 16px;font-size:24px;color:#e0e0e0;flex-shrink:0}.scroll-content.svelte-1a8nv3l{flex-grow:1;overflow-y:auto;min-height:0;-ms-overflow-style:none;scrollbar-width:none}.scroll-content.svelte-1a8nv3l::-webkit-scrollbar{display:none}.item-list.svelte-1a8nv3l{list-style:none;padding:0;margin:0}.item-list.svelte-1a8nv3l li:where(.svelte-1a8nv3l){display:flex;justify-content:space-between;margin-bottom:8px;border-bottom:1px dashed #666;padding-bottom:8px}.qty.svelte-1a8nv3l{font-weight:700;margin-right:10px;color:#d32f2f}.name.svelte-1a8nv3l{flex-grow:1}.price.svelte-1a8nv3l{font-weight:700;color:#4caf50}.order-number.svelte-1a8nv3l{color:#4a69bd}.total.svelte-1a8nv3l{border-top:2px solid #e0e0e0;padding-top:10px;font-size:1.5em;font-weight:700;display:flex;justify-content:space-between}.agent-messages.svelte-1a8nv3l{display:flex;flex-direction:column;gap:8px;min-height:100%;justify-content:flex-end}.agent-message.svelte-1a8nv3l{padding:12px;border-radius:8px;max-width:85%}.agent-message.user.svelte-1a8nv3l{align-self:flex-end;background-color:#4a69bd;color:#fff}.agent-message.agent.svelte-1a8nv3l{align-self:flex-start;background-color:#444;color:#e0e0e0}.message-timestamp.svelte-1a8nv3l{font-size:12px;color:#aaa;margin-right:8px}.message-type.svelte-1a8nv3l{font-weight:700;font-size:13px;margin-bottom:4px;display:block}.message-content.svelte-1a8nv3l{white-space:pre-wrap;line-height:1.4}h2.svelte-1a8nv3l{margin:0 0 16px;font-size:24px;color:#e0e0e0}.table-number.svelte-1a8nv3l{color:peru;font-weight:700}.pinpad-error-message.svelte-1a8nv3l{background-color:#4a1a1a;border:1px solid #d32f2f;border-radius:4px;padding:8px 12px;margin:8px 0;color:#ffcdd2;font-size:14px;font-weight:500;text-align:center}.universal-button.svelte-1sdk9y9{background:none;border:none;padding:0;cursor:pointer;width:var(--button-width, 120px);height:var(--button-height, 80px);position:relative;transition:transform .2s ease-out;filter:drop-shadow(2px 2px 2px rgba(0,0,0,.4));flex-grow:0;flex-shrink:0;color:#fff;font-family:inherit}.universal-button.svelte-1sdk9y9:hover{transform:scale(1.05);filter:drop-shadow(4px 4px 5px rgba(0,0,0,.5))}.universal-button.svelte-1sdk9y9:active{transform:scale(.98)}.button-shape.svelte-1sdk9y9{width:100%;height:100%;background-color:var(--button-color);display:flex;align-items:center;justify-content:center;box-sizing:border-box;position:relative;overflow:hidden}.universal-button[style*=--button-background-style].svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){background:var(--button-background-style)}.universal-button.hex.half.svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){background-color:#5a7aad;border:none}.universal-button.hex.half.active.svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){background-color:#2c2c2e;border:none}.universal-button.rect.half.active.svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){background-color:#2c2c2e}.universal-button.hex.svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){clip-path:var(--clip-path)}.universal-button.rect.svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){border-radius:8px}.slot-container.svelte-1sdk9y9{width:100%;height:100%}.button-text.svelte-1sdk9y9{font-weight:400;font-family:Arial Narrow,Liberation Sans Narrow,Helvetica Neue Condensed,Arial,sans-serif;font-stretch:ultra-condensed;text-align:center;line-height:1.1;letter-spacing:-.5px;word-break:break-word;white-space:normal;padding:5px;text-shadow:2px 2px 3px rgba(0,0,0,.8);color:var(--button-text-color, inherit)}.universal-button.hex.svelte-1sdk9y9 .button-text:where(.svelte-1sdk9y9),.universal-button.rect.svelte-1sdk9y9 .button-text:where(.svelte-1sdk9y9){font-size:22px}.button-icon.svelte-1sdk9y9{font-size:24px;font-weight:700;text-shadow:2px 2px 3px rgba(0,0,0,.8);color:var(--button-text-color, inherit)}.universal-button.hex.half.svelte-1sdk9y9 .button-text:where(.svelte-1sdk9y9){font-size:14px;font-weight:700;text-shadow:1px 1px 2px rgba(0,0,0,.7);padding:5px}.universal-button.hex.half.svelte-1sdk9y9 .button-icon:where(.svelte-1sdk9y9){font-size:32px;font-weight:700;text-shadow:1px 1px 2px rgba(0,0,0,.7)}.universal-button.rect.half.svelte-1sdk9y9 .button-text:where(.svelte-1sdk9y9){font-size:14px;font-weight:700;text-shadow:1px 1px 2px rgba(0,0,0,.7);padding:5px}.universal-button.rect.half.svelte-1sdk9y9 .button-icon:where(.svelte-1sdk9y9){font-size:32px;font-weight:700;text-shadow:1px 1px 2px rgba(0,0,0,.7)}.universal-button.disabled.svelte-1sdk9y9{pointer-events:none;filter:drop-shadow(1px 1px 1px rgba(0,0,0,.2));opacity:.3}.universal-button.disabled.svelte-1sdk9y9 .button-shape:where(.svelte-1sdk9y9){background-color:#2a2a2a!important}.universal-button.disabled.svelte-1sdk9y9:hover{transform:none;filter:drop-shadow(1px 1px 1px rgba(0,0,0,.2))}.shape-overlay.svelte-1sdk9y9{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#404040;border:none;pointer-events:none;z-index:1}.shape-overlay.rect.svelte-1sdk9y9{width:50px;height:50px}.shape-overlay.hex.svelte-1sdk9y9{width:50px;height:50px;clip-path:polygon(50% 0%,100% 25%,100% 75%,50% 100%,0% 75%,0% 25%)}.shape-overlay.double-arrow-down.svelte-1sdk9y9{width:50px;height:50px;background:none;display:flex;align-items:center;justify-content:center;color:#404040}.shape-overlay.double-arrow-down.svelte-1sdk9y9:before{content:"";width:50px;height:50px;background-image:url("data:image/svg+xml,%3Csvg width='50' height='50' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 13L12 18L17 13M7 6L12 11L17 6' stroke='%23404040' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:center;background-size:contain}.pinpad-wrapper.svelte-1hgpdio{display:flex;justify-content:flex-start;align-items:center;height:100%;flex-shrink:0}.pinpad-grid.svelte-1hgpdio{display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:8px}button.svelte-1hgpdio{height:var(--button-height);width:var(--button-width);background-color:#4a4a4a;color:#fff;border:1px solid #666;border-radius:8px;font-size:28px;font-weight:700;cursor:pointer;transition:background-color .2s ease}.numpad-key.svelte-1hgpdio:hover{background-color:#5a5a5a}.function-key.svelte-1hgpdio{font-size:24px}.key-cancel.svelte-1hgpdio{background-color:#d32f2f;grid-column:4;grid-row:1}.key-cancel.svelte-1hgpdio:hover{background-color:#e53935}.key-correct.svelte-1hgpdio{background-color:#fbc02d;grid-column:4;grid-row:2}.key-correct.svelte-1hgpdio:hover{background-color:#fdd835}.key-enter.svelte-1hgpdio{background-color:#388e3c;grid-column:4;grid-row:3 / 5;height:calc(var(--button-height) * 2 + 8px)}.key-enter.svelte-1hgpdio:hover{background-color:#43a047}.key-plus.svelte-1hgpdio{grid-column:1;grid-row:4}.key-minus.svelte-1hgpdio{grid-column:3;grid-row:4}button.svelte-1hgpdio:disabled{opacity:.2;cursor:not-allowed}.preview-wrapper.svelte-10wicgb{width:100%;height:100%;display:flex;align-items:center;justify-content:center;background-color:#666;padding:5px;box-sizing:border-box;position:absolute;top:0;left:0;border-radius:6px}.preview-grid.svelte-10wicgb{display:grid;grid-template-columns:repeat(3,1fr);gap:2px;width:95%;height:95%}.key.svelte-10wicgb{background-color:#484848;border-radius:2px;min-height:0;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;color:#aaa;border:1px solid #555}.key.zero.svelte-10wicgb{grid-column:1 / 3}.key.cancel.svelte-10wicgb{background-color:#8a4040;color:#ddd}.key.correct.svelte-10wicgb{background-color:#8a7a40;color:#ddd}.key.enter.svelte-10wicgb{background-color:#4a6040;color:#ddd}.key.clear.svelte-10wicgb{background-color:#5a4848;color:#ddd}.context-menu.svelte-1g1fs6h{position:fixed;z-index:1000;background-color:#3a3a3af2;border:1px solid rgba(255,255,255,.2);border-radius:8px;box-shadow:0 8px 24px #00000080;min-width:280px;max-width:400px;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);animation:svelte-1g1fs6h-fadeIn .2s cubic-bezier(.25,.46,.45,.94)}.menu-header.svelte-1g1fs6h{padding:16px 16px 8px;border-bottom:1px solid rgba(255,255,255,.1)}.menu-header.svelte-1g1fs6h h3:where(.svelte-1g1fs6h){margin:0;color:#fff;font-size:18px;font-weight:700;text-shadow:1px 1px 2px rgba(0,0,0,.7)}.menu-content.svelte-1g1fs6h{padding:12px 16px}.detail-row.svelte-1g1fs6h{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px;gap:12px}.detail-row.svelte-1g1fs6h:last-child{margin-bottom:0}.label.svelte-1g1fs6h{color:#ccc;font-weight:500;min-width:80px;flex-shrink:0}.value.svelte-1g1fs6h{color:#fff;text-align:right;word-break:break-word;flex:1}.menu-footer.svelte-1g1fs6h{padding:8px 16px 16px;border-top:1px solid rgba(255,255,255,.1);display:flex;gap:8px;justify-content:flex-end}.edit-button.svelte-1g1fs6h{background-color:#27ae60;color:#fff;border:1px solid #2ecc71;border-radius:8px;cursor:pointer;font-size:18px;font-weight:700;transition:background-color .2s ease;height:60px;min-width:80px;padding:0 16px}.edit-button.svelte-1g1fs6h:hover{background-color:#2ecc71}.close-button.svelte-1g1fs6h{background-color:#666;color:#fff;border:1px solid #777;border-radius:8px;cursor:pointer;font-size:18px;font-weight:700;transition:background-color .2s ease;height:60px;min-width:80px;padding:0 16px}.close-button.svelte-1g1fs6h:hover{background-color:#777}@media (max-width: 320px) or (max-height: 400px){.context-menu.svelte-1g1fs6h{max-width:90vw;max-height:90vh;overflow-y:auto}.menu-header.svelte-1g1fs6h h3:where(.svelte-1g1fs6h){font-size:16px}.detail-row.svelte-1g1fs6h{flex-direction:column;gap:4px;margin-bottom:12px}.label.svelte-1g1fs6h{min-width:auto;font-weight:700}.value.svelte-1g1fs6h{text-align:left}.menu-footer.svelte-1g1fs6h{flex-direction:column}.edit-button.svelte-1g1fs6h,.close-button.svelte-1g1fs6h{height:50px;min-width:100%;font-size:16px}}@keyframes svelte-1g1fs6h-fadeIn{0%{opacity:0;transform:scale(.9) translateY(-10px)}to{opacity:1;transform:scale(1) translateY(0)}}.selection-area.svelte-gp7a2r{background-color:#4a4a4a;padding:0;height:100%;box-sizing:border-box;overflow:hidden;border-radius:8px;position:relative;display:flex;flex-direction:column}.grid-container.svelte-gp7a2r{flex:1;overflow:hidden}.status-message.svelte-gp7a2r{color:#fff;font-style:italic;text-align:center;margin:32px}.grid-container-unified.svelte-gp7a2r{height:100%;overflow:hidden}.grid-container-unified.hex.svelte-gp7a2r{padding:var(--hex-vertical-padding, 0px) 0px}.grid-container-unified.rect.svelte-gp7a2r{padding:var(--rect-vertical-padding, 6px) 0px}.button-row.svelte-gp7a2r{display:flex;justify-content:center;gap:6px;padding:0}.button-row.hex-row.svelte-gp7a2r{margin-bottom:calc(-1 * var(--optimal-hex-height, 121px) * .25 + 6px)}.button-row.rect-row.svelte-gp7a2r{margin-bottom:6px}.button-row.rect-row.svelte-gp7a2r:last-child{margin-bottom:0}.pinpad-overlay.svelte-gp7a2r{position:absolute;bottom:8px;left:8px;z-index:100;transform-origin:bottom left;animation:svelte-gp7a2r-expand .3s cubic-bezier(.25,.46,.45,.94) forwards}.pinpad-container.svelte-gp7a2r{background-color:#3a3a3af2;border-radius:8px;padding:16px;box-shadow:0 8px 24px #00000080;position:relative}@keyframes svelte-gp7a2r-expand{0%{transform:scale(.1);opacity:0}to{transform:scale(1);opacity:1}}.modal-overlay.svelte-o31k8w{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#000c;display:flex;justify-content:center;align-items:center;z-index:1000}.modal-content.svelte-o31k8w{background-color:#fff;padding:2rem;border-radius:12px;width:85%;max-width:1000px;max-height:90vh;overflow-y:auto;box-shadow:0 10px 30px #00000080}.time-confirmation-section.svelte-o31k8w{margin-bottom:2rem;border-bottom:2px solid #e9ecef;padding-bottom:2rem}.transactions-section.svelte-o31k8w{margin-top:1rem}h2.svelte-o31k8w{margin-top:0;color:#2c3e50;text-align:center}h3.svelte-o31k8w{color:#e74c3c;margin-bottom:1rem}.time-display-large.svelte-o31k8w{text-align:center;margin:1.5rem 0;padding:1.5rem;background:linear-gradient(135deg,#667eea,#764ba2);border-radius:12px;color:#fff;box-shadow:0 8px 32px #0000004d}.current-time.svelte-o31k8w{font-size:3rem;font-weight:700;line-height:1;margin-bottom:.5rem;text-shadow:2px 2px 4px rgba(0,0,0,.3);font-family:Segoe UI,-apple-system,BlinkMacSystemFont,sans-serif}.current-date.svelte-o31k8w{font-size:1.2rem;font-weight:500;opacity:.9;text-shadow:1px 1px 2px rgba(0,0,0,.3)}table.svelte-o31k8w{width:100%;border-collapse:collapse;margin:1rem 0}th.svelte-o31k8w,td.svelte-o31k8w{border:1px solid #ddd;padding:8px;text-align:left}th.svelte-o31k8w{background-color:#f2f2f2;font-weight:600}.actions.svelte-o31k8w button:where(.svelte-o31k8w){margin-right:5px;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;color:#fff;font-size:12px;font-weight:500}.btn-fiscalize.svelte-o31k8w{background-color:#28a745}.btn-fiscalize.svelte-o31k8w:hover{background-color:#218838}.btn-cancel.svelte-o31k8w{background-color:#dc3545}.btn-cancel.svelte-o31k8w:hover{background-color:#c82333}.btn-postpone.svelte-o31k8w{background-color:#ffc107;color:#212529}.btn-postpone.svelte-o31k8w:hover{background-color:#e0a800}.company-info-small.svelte-o31k8w{text-align:center;margin:1rem 0;padding:1rem;background-color:#f8f9fa;border-radius:6px;border:1px solid #e9ecef}.company-name.svelte-o31k8w{font-size:1.1rem;font-weight:600;color:#495057;margin-bottom:.25rem}.branch-info.svelte-o31k8w{font-size:.9rem;color:#6c757d}.main-actions.svelte-o31k8w{display:flex;justify-content:center;margin:2rem 0;gap:1rem}.btn-confirm.svelte-o31k8w,.btn-postpone-all.svelte-o31k8w{background:linear-gradient(135deg,#007bff,#0056b3);color:#fff;border:none;border-radius:8px;padding:16px 32px;font-size:16px;font-weight:600;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 15px #007bff4d;letter-spacing:.5px}.btn-confirm.svelte-o31k8w:hover,.btn-postpone-all.svelte-o31k8w:hover{background:linear-gradient(135deg,#0056b3,#004085);transform:translateY(-2px);box-shadow:0 6px 20px #007bff66}.btn-confirm.svelte-o31k8w:active,.btn-postpone-all.svelte-o31k8w:active{transform:translateY(0);box-shadow:0 2px 10px #007bff4d}.error.svelte-o31k8w{color:#dc3545;background-color:#f8d7da;border:1px solid #f5c6cb;padding:10px;border-radius:4px;margin-top:1rem}.pos-grid.svelte-b8b2uv{display:grid;grid-template-columns:350px 1fr;grid-template-rows:1fr;height:100vh;width:100vw;gap:4px;padding:4px;box-sizing:border-box;background-color:#333}.pos-grid.svelte-b8b2uv>div:where(.svelte-b8b2uv){border-radius:8px;overflow:hidden}.grid-item-display.svelte-b8b2uv{grid-row:1 / 2;grid-column:1 / 2}.grid-selection-area.svelte-b8b2uv{grid-row:1 / 2;grid-column:2 / 3}


--- File: /packages/client-desktop/src/renderer/dist/assets/index-D7hF3OpR.js ---

(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))a(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const l of i.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&a(l)}).observe(document,{childList:!0,subtree:!0});function r(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function a(s){if(s.ep)return;s.ep=!0;const i=r(s);fetch(s.href,i)}})();const w1=!1;var L7=Array.isArray,S5=Array.prototype.indexOf,o1=Array.from,Z1=Object.defineProperty,nt=Object.getOwnPropertyDescriptor,A5=Object.getOwnPropertyDescriptors,M5=Object.prototype,T5=Array.prototype,D1=Object.getPrototypeOf,E1=Object.isExtensible;function t7(e){return typeof e=="function"}const pt=()=>{};function O5(e){return e()}function p7(e){for(var t=0;t<e.length;t++)e[t]()}const Ve=2,c1=4,o7=8,u1=16,lt=32,Gt=64,d1=128,He=256,m7=512,Be=1024,it=2048,wt=4096,at=8192,k7=16384,B1=32768,f1=65536,L1=1<<17,I5=1<<18,q1=1<<19,r1=1<<20,v1=1<<21,mt=Symbol("$state"),U1=Symbol("legacy props"),W1=new class extends Error{name="StaleReactionError";message="The reaction that called `getAbortSignal()` was re-run or destroyed"};function H1(e){return e===this.v}function V1(e,t){return e!=e?t==t:e!==t||e!==null&&typeof e=="object"||typeof e=="function"}function j1(e){return!V1(e,this.v)}function R5(e){throw new Error("https://svelte.dev/e/effect_in_teardown")}function $5(){throw new Error("https://svelte.dev/e/effect_in_unowned_derived")}function F5(e){throw new Error("https://svelte.dev/e/effect_orphan")}function N5(){throw new Error("https://svelte.dev/e/effect_update_depth_exceeded")}function P5(e){throw new Error("https://svelte.dev/e/lifecycle_legacy_only")}function Z5(e){throw new Error("https://svelte.dev/e/props_invalid_value")}function D5(){throw new Error("https://svelte.dev/e/state_descriptors_fixed")}function B5(){throw new Error("https://svelte.dev/e/state_prototype_fixed")}function q5(){throw new Error("https://svelte.dev/e/state_unsafe_mutation")}let Yt=!1,U5=!1;function W5(){Yt=!0}const H5=1,V5=2,j5=16,z5=2,G5=4,Y5=8,J5=1,X5=2,Fe=Symbol();function S7(e){throw new Error("https://svelte.dev/e/lifecycle_outside_component")}let pe=null;function k1(e){pe=e}function ot(e,t=!1,r){pe={p:pe,c:null,e:null,s:e,x:null,l:null},Yt&&!t&&(pe.l={s:null,u:null,r1:[],r2:n7(!1)})}function ct(e){var t=pe,r=t.e;if(r!==null){t.e=null;for(var a of r)t5(a)}return e!==void 0&&(t.x=e),pe=t.p,e??{}}function A7(){return!Yt||pe!==null&&pe.l===null}function Ht(e){if(typeof e!="object"||e===null||mt in e)return e;const t=D1(e);if(t!==M5&&t!==T5)return e;var r=new Map,a=L7(e),s=dt(0),i=It,l=c=>{if(It===i)return c();var u=me,o=It;bt(null),T1(i);var v=c();return bt(u),T1(o),v};return a&&r.set("length",dt(e.length)),new Proxy(e,{defineProperty(c,u,o){(!("value"in o)||o.configurable===!1||o.enumerable===!1||o.writable===!1)&&D5();var v=r.get(u);return v===void 0?v=l(()=>{var g=dt(o.value);return r.set(u,g),g}):w(v,o.value,!0),!0},deleteProperty(c,u){var o=r.get(u);if(o===void 0){if(u in c){const p=l(()=>dt(Fe));r.set(u,p),Q7(s)}}else{if(a&&typeof u=="string"){var v=r.get("length"),g=Number(u);Number.isInteger(g)&&g<v.v&&w(v,g)}w(o,Fe),Q7(s)}return!0},get(c,u,o){if(u===mt)return e;var v=r.get(u),g=u in c;if(v===void 0&&(!g||nt(c,u)?.writable)&&(v=l(()=>{var d=Ht(g?c[u]:Fe),E=dt(d);return E}),r.set(u,v)),v!==void 0){var p=n(v);return p===Fe?void 0:p}return Reflect.get(c,u,o)},getOwnPropertyDescriptor(c,u){var o=Reflect.getOwnPropertyDescriptor(c,u);if(o&&"value"in o){var v=r.get(u);v&&(o.value=n(v))}else if(o===void 0){var g=r.get(u),p=g?.v;if(g!==void 0&&p!==Fe)return{enumerable:!0,configurable:!0,value:p,writable:!0}}return o},has(c,u){if(u===mt)return!0;var o=r.get(u),v=o!==void 0&&o.v!==Fe||Reflect.has(c,u);if(o!==void 0||fe!==null&&(!v||nt(c,u)?.writable)){o===void 0&&(o=l(()=>{var p=v?Ht(c[u]):Fe,d=dt(p);return d}),r.set(u,o));var g=n(o);if(g===Fe)return!1}return v},set(c,u,o,v){var g=r.get(u),p=u in c;if(a&&u==="length")for(var d=o;d<g.v;d+=1){var E=r.get(d+"");E!==void 0?w(E,Fe):d in c&&(E=l(()=>dt(Fe)),r.set(d+"",E))}if(g===void 0)(!p||nt(c,u)?.writable)&&(g=l(()=>dt(void 0)),w(g,Ht(o)),r.set(u,g));else{p=g.v!==Fe;var C=l(()=>Ht(o));w(g,C)}var b=Reflect.getOwnPropertyDescriptor(c,u);if(b?.set&&b.set.call(v,o),!p){if(a&&typeof u=="string"){var k=r.get("length"),_=Number(u);Number.isInteger(_)&&_>=k.v&&w(k,_+1)}Q7(s)}return!0},ownKeys(c){n(s);var u=Reflect.ownKeys(c).filter(g=>{var p=r.get(g);return p===void 0||p.v!==Fe});for(var[o,v]of r)v.v!==Fe&&!(o in c)&&u.push(o);return u},setPrototypeOf(){B5()}})}function M7(e){var t=Ve|it,r=me!==null&&(me.f&Ve)!==0?me:null;return fe===null||r!==null&&(r.f&He)!==0?t|=He:fe.f|=q1,{ctx:pe,deps:null,effects:null,equals:H1,f:t,fn:e,reactions:null,rv:0,v:Fe,wv:0,parent:r??fe,ac:null}}function kt(e){const t=M7(e);return d5(t),t}function ke(e){const t=M7(e);return t.equals=j1,t}function z1(e){var t=e.effects;if(t!==null){e.effects=null;for(var r=0;r<t.length;r+=1)_t(t[r])}}function K5(e){for(var t=e.parent;t!==null;){if((t.f&Ve)===0)return t;t=t.parent}return null}function C1(e){var t,r=fe;jt(K5(e));try{z1(e),t=C5(e)}finally{jt(r)}return t}function G1(e){var t=C1(e);if(e.equals(t)||(e.v=t,e.wv=f5()),!yt){var r=(Ct||(e.f&He)!==0)&&e.deps!==null?wt:Be;Ye(e,r)}}const Tt=new Map;function n7(e,t){var r={f:0,v:e,reactions:null,equals:H1,rv:0,wv:0};return r}function dt(e,t){const r=n7(e);return d5(r),r}function D(e,t=!1,r=!0){const a=n7(e);return t||(a.equals=j1),Yt&&r&&pe!==null&&pe.l!==null&&(pe.l.s??=[]).push(a),a}function S1(e,t){return w(e,x(()=>n(e))),t}function w(e,t,r=!1){me!==null&&(!Ke||(me.f&L1)!==0)&&A7()&&(me.f&(Ve|u1|L1))!==0&&!st?.includes(e)&&q5();let a=r?Ht(t):t;return Y1(e,a)}function Y1(e,t){if(!e.equals(t)){var r=e.v;yt?Tt.set(e,t):Tt.set(e,r),e.v=t,(e.f&Ve)!==0&&((e.f&it)!==0&&C1(e),Ye(e,(e.f&He)===0?Be:wt)),e.wv=f5(),J1(e,it),A7()&&fe!==null&&(fe.f&Be)!==0&&(fe.f&(lt|Gt))===0&&(ze===null?o6([e]):ze.push(e))}return t}function Q7(e){w(e,e.v+1)}function J1(e,t){var r=e.reactions;if(r!==null)for(var a=A7(),s=r.length,i=0;i<s;i++){var l=r[i],c=l.f;(c&it)===0&&(!a&&l===fe||(Ye(l,t),(c&(Be|He))!==0&&((c&Ve)!==0?J1(l,wt):R7(l))))}}let Q5=!1;var A1,X1,K1,Q1;function e6(){if(A1===void 0){A1=window,X1=/Firefox/.test(navigator.userAgent);var e=Element.prototype,t=Node.prototype,r=Text.prototype;K1=nt(t,"firstChild").get,Q1=nt(t,"nextSibling").get,E1(e)&&(e.__click=void 0,e.__className=void 0,e.__attributes=null,e.__style=void 0,e.__e=void 0),E1(r)&&(r.__t=void 0)}}function T7(e=""){return document.createTextNode(e)}function vt(e){return K1.call(e)}function O7(e){return Q1.call(e)}function m(e,t){return vt(e)}function ht(e,t){{var r=vt(e);return r instanceof Comment&&r.data===""?O7(r):r}}function A(e,t=1,r=!1){let a=e;for(;t--;)a=O7(a);return a}function t6(e){e.textContent=""}function e5(e){fe===null&&me===null&&F5(),me!==null&&(me.f&He)!==0&&fe===null&&$5(),yt&&R5()}function r6(e,t){var r=t.last;r===null?t.last=t.first=e:(r.next=e,e.prev=r,t.last=e)}function Et(e,t,r,a=!0){var s=fe,i={ctx:pe,deps:null,nodes_start:null,nodes_end:null,f:e|it,first:null,fn:t,last:null,next:null,parent:s,b:s&&s.b,prev:null,teardown:null,transitions:null,wv:0,ac:null};if(r)try{I7(i),i.f|=B1}catch(u){throw _t(i),u}else t!==null&&R7(i);var l=r&&i.deps===null&&i.first===null&&i.nodes_start===null&&i.teardown===null&&(i.f&(q1|d1))===0;if(!l&&a&&(s!==null&&r6(i,s),me!==null&&(me.f&Ve)!==0)){var c=me;(c.effects??=[]).push(i)}return i}function p1(e){const t=Et(o7,null,!1);return Ye(t,Be),t.teardown=e,t}function n1(e){if(e5(),!me&&fe&&(fe.f&lt)!==0){var t=pe;(t.e??=[]).push(e)}else return t5(e)}function t5(e){return Et(c1|v1,e,!1)}function n6(e){return e5(),Et(o7|v1,e,!0)}function a6(e){const t=Et(Gt,e,!0);return(r={})=>new Promise(a=>{r.outro?h7(t,()=>{_t(t),a(void 0)}):(_t(t),a(void 0))})}function r5(e){return Et(c1,e,!1)}function Me(e,t){var r=pe,a={effect:null,ran:!1};r.l.r1.push(a),a.effect=m1(()=>{e(),!a.ran&&(a.ran=!0,w(r.l.r2,!0),x(t))})}function Jt(){var e=pe;m1(()=>{if(n(e.l.r2)){for(var t of e.l.r1){var r=t.effect;(r.f&Be)!==0&&Ye(r,wt),c7(r)&&I7(r),t.ran=!1}e.l.r2.v=!1}})}function m1(e){return Et(o7,e,!0)}function ne(e,t=[],r=M7){const a=t.map(r);return h1(()=>e(...a.map(n)))}function h1(e,t=0){var r=Et(o7|u1|t,e,!0);return r}function a7(e,t=!0){return Et(o7|lt,e,!0,t)}function n5(e){var t=e.teardown;if(t!==null){const r=yt,a=me;M1(!0),bt(null);try{t.call(null)}finally{M1(r),bt(a)}}}function a5(e,t=!1){var r=e.first;for(e.first=e.last=null;r!==null;){r.ac?.abort(W1);var a=r.next;(r.f&Gt)!==0?r.parent=null:_t(r,t),r=a}}function s6(e){for(var t=e.first;t!==null;){var r=t.next;(t.f&lt)===0&&_t(t),t=r}}function _t(e,t=!0){var r=!1;(t||(e.f&I5)!==0)&&e.nodes_start!==null&&e.nodes_end!==null&&(s5(e.nodes_start,e.nodes_end),r=!0),a5(e,t&&!r),x7(e,0),Ye(e,k7);var a=e.transitions;if(a!==null)for(const i of a)i.stop();n5(e);var s=e.parent;s!==null&&s.first!==null&&i5(e),e.next=e.prev=e.teardown=e.ctx=e.deps=e.fn=e.nodes_start=e.nodes_end=e.ac=null}function s5(e,t){for(;e!==null;){var r=e===t?null:O7(e);e.remove(),e=r}}function i5(e){var t=e.parent,r=e.prev,a=e.next;r!==null&&(r.next=a),a!==null&&(a.prev=r),t!==null&&(t.first===e&&(t.first=a),t.last===e&&(t.last=r))}function h7(e,t){var r=[];g1(e,r,!0),l5(r,()=>{_t(e),t&&t()})}function l5(e,t){var r=e.length;if(r>0){var a=()=>--r||t();for(var s of e)s.out(a)}else t()}function g1(e,t,r){if((e.f&at)===0){if(e.f^=at,e.transitions!==null)for(const l of e.transitions)(l.is_global||r)&&t.push(l);for(var a=e.first;a!==null;){var s=a.next,i=(a.f&f1)!==0||(a.f&lt)!==0;g1(a,t,i?r:!1),a=s}}}function g7(e){o5(e,!0)}function o5(e,t){if((e.f&at)!==0){e.f^=at;for(var r=e.first;r!==null;){var a=r.next,s=(r.f&f1)!==0||(r.f&lt)!==0;o5(r,s?t:!1),r=a}if(e.transitions!==null)for(const i of e.transitions)(i.is_global||t)&&i.in()}}let _7=[];function i6(){var e=_7;_7=[],p7(e)}function c5(e){_7.length===0&&queueMicrotask(i6),_7.push(e)}function l6(e){var t=fe;if((t.f&B1)===0){if((t.f&d1)===0)throw e;t.fn(e)}else u5(e,t)}function u5(e,t){for(;t!==null;){if((t.f&d1)!==0)try{t.b.error(e);return}catch{}t=t.parent}throw e}let a1=!1,y7=null,Ot=!1,yt=!1;function M1(e){yt=e}let C7=[];let me=null,Ke=!1;function bt(e){me=e}let fe=null;function jt(e){fe=e}let st=null;function d5(e){me!==null&&me.f&r1&&(st===null?st=[e]:st.push(e))}let Pe=null,Ue=0,ze=null;function o6(e){ze=e}let b7=1,s7=0,It=s7;function T1(e){It=e}let Ct=!1;function f5(){return++b7}function c7(e){var t=e.f;if((t&it)!==0)return!0;if((t&wt)!==0){var r=e.deps,a=(t&He)!==0;if(r!==null){var s,i,l=(t&m7)!==0,c=a&&fe!==null&&!Ct,u=r.length;if(l||c){var o=e,v=o.parent;for(s=0;s<u;s++)i=r[s],(l||!i?.reactions?.includes(o))&&(i.reactions??=[]).push(o);l&&(o.f^=m7),c&&v!==null&&(v.f&He)===0&&(o.f^=He)}for(s=0;s<u;s++)if(i=r[s],c7(i)&&G1(i),i.wv>e.wv)return!0}(!a||fe!==null&&!Ct)&&Ye(e,Be)}return!1}function v5(e,t,r=!0){var a=e.reactions;if(a!==null&&!st?.includes(e))for(var s=0;s<a.length;s++){var i=a[s];(i.f&Ve)!==0?v5(i,t,!1):t===i&&(r?Ye(i,it):(i.f&Be)!==0&&Ye(i,wt),R7(i))}}function C5(e){var t=Pe,r=Ue,a=ze,s=me,i=Ct,l=st,c=pe,u=Ke,o=It,v=e.f;Pe=null,Ue=0,ze=null,Ct=(v&He)!==0&&(Ke||!Ot||me===null),me=(v&(lt|Gt))===0?e:null,st=null,k1(e.ctx),Ke=!1,It=++s7,e.f|=r1,e.ac!==null&&(e.ac.abort(W1),e.ac=null);try{var g=(0,e.fn)(),p=e.deps;if(Pe!==null){var d;if(x7(e,Ue),p!==null&&Ue>0)for(p.length=Ue+Pe.length,d=0;d<Pe.length;d++)p[Ue+d]=Pe[d];else e.deps=p=Pe;if(!Ct||(v&Ve)!==0&&e.reactions!==null)for(d=Ue;d<p.length;d++)(p[d].reactions??=[]).push(e)}else p!==null&&Ue<p.length&&(x7(e,Ue),p.length=Ue);if(A7()&&ze!==null&&!Ke&&p!==null&&(e.f&(Ve|wt|it))===0)for(d=0;d<ze.length;d++)v5(ze[d],e);return s!==null&&s!==e&&(s7++,ze!==null&&(a===null?a=ze:a.push(...ze))),g}catch(E){l6(E)}finally{Pe=t,Ue=r,ze=a,me=s,Ct=i,st=l,k1(c),Ke=u,It=o,e.f^=r1}}function c6(e,t){let r=t.reactions;if(r!==null){var a=S5.call(r,e);if(a!==-1){var s=r.length-1;s===0?r=t.reactions=null:(r[a]=r[s],r.pop())}}r===null&&(t.f&Ve)!==0&&(Pe===null||!Pe.includes(t))&&(Ye(t,wt),(t.f&(He|m7))===0&&(t.f^=m7),z1(t),x7(t,0))}function x7(e,t){var r=e.deps;if(r!==null)for(var a=t;a<r.length;a++)c6(e,r[a])}function I7(e){var t=e.f;if((t&k7)===0){Ye(e,Be);var r=fe,a=Ot;fe=e,Ot=!0;try{(t&u1)!==0?s6(e):a5(e),n5(e);var s=C5(e);e.teardown=typeof s=="function"?s:null,e.wv=b7;var i;w1&&U5&&(e.f&it)!==0&&e.deps}finally{Ot=a,fe=r}}}function u6(){try{N5()}catch(e){if(y7!==null)u5(e,y7);else throw e}}function d6(){var e=Ot;try{var t=0;for(Ot=!0;C7.length>0;){t++>1e3&&u6();var r=C7,a=r.length;C7=[];for(var s=0;s<a;s++){var i=v6(r[s]);f6(i)}Tt.clear()}}finally{a1=!1,Ot=e,y7=null}}function f6(e){var t=e.length;if(t!==0){for(var r=0;r<t;r++){var a=e[r];if((a.f&(k7|at))===0&&c7(a)){var s=b7;if(I7(a),a.deps===null&&a.first===null&&a.nodes_start===null&&(a.teardown===null?i5(a):a.fn=null),b7>s&&(a.f&v1)!==0)break}}for(;r<t;r+=1)R7(e[r])}}function R7(e){a1||(a1=!0,queueMicrotask(d6));for(var t=y7=e;t.parent!==null;){t=t.parent;var r=t.f;if((r&(Gt|lt))!==0){if((r&Be)===0)return;t.f^=Be}}C7.push(t)}function v6(e){for(var t=[],r=e;r!==null;){var a=r.f,s=(a&(lt|Gt))!==0,i=s&&(a&Be)!==0;if(!i&&(a&at)===0){(a&c1)!==0?t.push(r):s?r.f^=Be:c7(r)&&I7(r);var l=r.first;if(l!==null){r=l;continue}}var c=r.parent;for(r=r.next;r===null&&c!==null;)r=c.next,c=c.parent}return t}function n(e){var t=e.f,r=(t&Ve)!==0;if(me!==null&&!Ke){if(!st?.includes(e)){var a=me.deps;e.rv<s7&&(e.rv=s7,Pe===null&&a!==null&&a[Ue]===e?Ue++:Pe===null?Pe=[e]:(!Ct||!Pe.includes(e))&&Pe.push(e))}}else if(r&&e.deps===null&&e.effects===null){var s=e,i=s.parent;i!==null&&(i.f&He)===0&&(s.f^=He)}if(r&&!yt&&(s=e,c7(s)&&G1(s)),yt){if(Tt.has(e))return Tt.get(e);if(r){s=e;var l=s.v;return((s.f&Be)!==0||p5(s))&&(l=C1(s)),Tt.set(s,l),l}}return e.v}function p5(e){if(e.v===Fe)return!0;if(e.deps===null)return!1;for(const t of e.deps)if(Tt.has(t)||(t.f&Ve)!==0&&p5(t))return!0;return!1}function x(e){var t=Ke;try{return Ke=!0,e()}finally{Ke=t}}const C6=-7169;function Ye(e,t){e.f=e.f&C6|t}function Z(e){if(!(typeof e!="object"||!e||e instanceof EventTarget)){if(mt in e)s1(e);else if(!Array.isArray(e))for(let t in e){const r=e[t];typeof r=="object"&&r&&mt in r&&s1(r)}}}function s1(e,t=new Set){if(typeof e=="object"&&e!==null&&!(e instanceof EventTarget)&&!t.has(e)){t.add(e),e instanceof Date&&e.getTime();for(let a in e)try{s1(e[a],t)}catch{}const r=D1(e);if(r!==Object.prototype&&r!==Array.prototype&&r!==Map.prototype&&r!==Set.prototype&&r!==Date.prototype){const a=A5(r);for(let s in a){const i=a[s].get;if(i)try{i.call(e)}catch{}}}}}const p6=["touchstart","touchmove"];function m6(e){return p6.includes(e)}function h6(e){var t=me,r=fe;bt(null),jt(null);try{return e()}finally{bt(t),jt(r)}}const g6=new Set,O1=new Set;function _6(e,t,r,a={}){function s(i){if(a.capture||r7.call(t,i),!i.cancelBubble)return h6(()=>r?.call(this,i))}return e.startsWith("pointer")||e.startsWith("touch")||e==="wheel"?c5(()=>{t.addEventListener(e,s,a)}):t.addEventListener(e,s,a),s}function oe(e,t,r,a,s){var i={capture:a,passive:s},l=_6(e,t,r,i);(t===document.body||t===window||t===document||t instanceof HTMLMediaElement)&&p1(()=>{t.removeEventListener(e,l,i)})}function r7(e){var t=this,r=t.ownerDocument,a=e.type,s=e.composedPath?.()||[],i=s[0]||e.target,l=0,c=e.__root;if(c){var u=s.indexOf(c);if(u!==-1&&(t===document||t===window)){e.__root=t;return}var o=s.indexOf(t);if(o===-1)return;u<=o&&(l=u)}if(i=s[l]||e.target,i!==t){Z1(e,"currentTarget",{configurable:!0,get(){return i||r}});var v=me,g=fe;bt(null),jt(null);try{for(var p,d=[];i!==null;){var E=i.assignedSlot||i.parentNode||i.host||null;try{var C=i["__"+a];if(C!=null&&(!i.disabled||e.target===i))if(L7(C)){var[b,...k]=C;b.apply(i,[e,...k])}else C.call(i,e)}catch(_){p?d.push(_):p=_}if(e.cancelBubble||E===t||E===null)break;i=E}if(p){for(let _ of d)queueMicrotask(()=>{throw _});throw p}}finally{e.__root=t,delete e.currentTarget,bt(v),jt(g)}}}function m5(e){var t=document.createElement("template");return t.innerHTML=e.replaceAll("<!>","<!---->"),t.content}function i7(e,t){var r=fe;r.nodes_start===null&&(r.nodes_start=e,r.nodes_end=t)}function B(e,t){var r=(t&J5)!==0,a=(t&X5)!==0,s,i=!e.startsWith("<!>");return()=>{s===void 0&&(s=m5(i?e:"<!>"+e),r||(s=vt(s)));var l=a||X1?document.importNode(s,!0):s.cloneNode(!0);if(r){var c=vt(l),u=l.lastChild;i7(c,u)}else i7(l,l);return l}}function e1(e=""){{var t=T7(e+"");return i7(t,t),t}}function w7(){var e=document.createDocumentFragment(),t=document.createComment(""),r=T7();return e.append(t,r),i7(t,r),e}function P(e,t){e!==null&&e.before(t)}function H(e,t){var r=t==null?"":typeof t=="object"?t+"":t;r!==(e.__t??=e.nodeValue)&&(e.__t=r,e.nodeValue=r+"")}function y6(e,t){return b6(e,t)}const Ut=new Map;function b6(e,{target:t,anchor:r,props:a={},events:s,context:i,intro:l=!0}){e6();var c=new Set,u=g=>{for(var p=0;p<g.length;p++){var d=g[p];if(!c.has(d)){c.add(d);var E=m6(d);t.addEventListener(d,r7,{passive:E});var C=Ut.get(d);C===void 0?(document.addEventListener(d,r7,{passive:E}),Ut.set(d,1)):Ut.set(d,C+1)}}};u(o1(g6)),O1.add(u);var o=void 0,v=a6(()=>{var g=r??t.appendChild(T7());return a7(()=>{if(i){ot({});var p=pe;p.c=i}s&&(a.$$events=s),o=e(g,a)||{},i&&ct()}),()=>{for(var p of c){t.removeEventListener(p,r7);var d=Ut.get(p);--d===0?(document.removeEventListener(p,r7),Ut.delete(p)):Ut.set(p,d)}O1.delete(u),g!==r&&g.parentNode?.removeChild(g)}});return x6.set(o,v),o}let x6=new WeakMap;function Y(e,t,[r,a]=[0,0]){var s=e,i=null,l=null,c=Fe,u=r>0?f1:0,o=!1;const v=(p,d=!0)=>{o=!0,g(d,p)},g=(p,d)=>{c!==(c=p)&&(c?(i?g7(i):d&&(i=a7(()=>d(s))),l&&h7(l,()=>{l=null})):(l?g7(l):d&&(l=a7(()=>d(s,[r+1,a]))),i&&h7(i,()=>{i=null})))};h1(()=>{o=!1,t(v),o||g(null,null)},u)}function h5(e,t){return t}function w6(e,t,r,a){for(var s=[],i=t.length,l=0;l<i;l++)g1(t[l].e,s,!0);var c=i>0&&s.length===0&&r!==null;if(c){var u=r.parentNode;t6(u),u.append(r),a.clear(),ft(e,t[0].prev,t[i-1].next)}l5(s,()=>{for(var o=0;o<i;o++){var v=t[o];c||(a.delete(v.k),ft(e,v.prev,v.next)),_t(v.e,!c)}})}function xt(e,t,r,a,s,i=null){var l=e,c={flags:t,items:new Map,first:null};{var u=e;l=u.appendChild(T7())}var o=null,v=!1,g=ke(()=>{var p=r();return L7(p)?p:p==null?[]:o1(p)});h1(()=>{var p=n(g),d=p.length;v&&d===0||(v=d===0,E6(p,c,l,s,t,a,r),i!==null&&(d===0?o?g7(o):o=a7(()=>i(l)):o!==null&&h7(o,()=>{o=null})),n(g))})}function E6(e,t,r,a,s,i,l){var c=e.length,u=t.items,o=t.first,v=o,g,p=null,d=[],E=[],C,b,k,_;for(_=0;_<c;_+=1){if(C=e[_],b=i(C,_),k=u.get(b),k===void 0){var $=v?v.e.nodes_start:r;p=k6($,t,p,p===null?t.first:p.next,C,b,_,a,s,l),u.set(b,p),d=[],E=[],v=p.next;continue}if(L6(k,C,_),(k.e.f&at)!==0&&g7(k.e),k!==v){if(g!==void 0&&g.has(k)){if(d.length<E.length){var N=E[0],q;p=N.prev;var I=d[0],W=d[d.length-1];for(q=0;q<d.length;q+=1)I1(d[q],N,r);for(q=0;q<E.length;q+=1)g.delete(E[q]);ft(t,I.prev,W.next),ft(t,p,I),ft(t,W,N),v=N,p=W,_-=1,d=[],E=[]}else g.delete(k),I1(k,v,r),ft(t,k.prev,k.next),ft(t,k,p===null?t.first:p.next),ft(t,p,k),p=k;continue}for(d=[],E=[];v!==null&&v.k!==b;)(v.e.f&at)===0&&(g??=new Set).add(v),E.push(v),v=v.next;if(v===null)continue;k=v}d.push(k),p=k,v=k.next}if(v!==null||g!==void 0){for(var se=g===void 0?[]:o1(g);v!==null;)(v.e.f&at)===0&&se.push(v),v=v.next;var Q=se.length;if(Q>0){var te=c===0?r:null;w6(t,se,te,u)}}fe.first=t.first&&t.first.e,fe.last=p&&p.e}function L6(e,t,r,a){Y1(e.v,t),e.i=r}function k6(e,t,r,a,s,i,l,c,u,o){var v=(u&H5)!==0,g=(u&j5)===0,p=v?g?D(s,!1,!1):n7(s):s,d=(u&V5)===0?l:n7(l),E={i:d,v:p,k:i,a:null,e:null,prev:r,next:a};try{return E.e=a7(()=>c(e,p,d,o),Q5),E.e.prev=r&&r.e,E.e.next=a&&a.e,r===null?t.first=E:(r.next=E,r.e.next=E.e),a!==null&&(a.prev=E,a.e.prev=E.e),E}finally{}}function I1(e,t,r){for(var a=e.next?e.next.e.nodes_start:r,s=t?t.e.nodes_start:r,i=e.e.nodes_start;i!==a;){var l=O7(i);s.before(i),i=l}}function ft(e,t,r){t===null?e.first=r:(t.next=r,t.e.next=r&&r.e),r!==null&&(r.prev=t,r.e.prev=t&&t.e)}function S6(e,t,r=!1,a=!1,s=!1){var i=e,l="";ne(()=>{var c=fe;if(l!==(l=t()??"")&&(c.nodes_start!==null&&(s5(c.nodes_start,c.nodes_end),c.nodes_start=c.nodes_end=null),l!=="")){var u=l+"";r?u=`<svg>${u}</svg>`:a&&(u=`<math>${u}</math>`);var o=m5(u);if((r||a)&&(o=vt(o)),i7(vt(o),o.lastChild),r||a)for(;vt(o);)i.before(vt(o));else i.before(o)}})}function A6(e,t,r,a,s){var i=t.$$slots?.[r],l=!1;i===!0&&(i=t.children,l=!0),i===void 0||i(e,l?()=>a:a)}function M6(e){const t={};e.children&&(t.default=!0);for(const r in e.$$slots)t[r]=!0;return t}const R1=[...` 	
\r\f \v\uFEFF`];function T6(e,t,r){var a=e==null?"":""+e;if(t&&(a=a?a+" "+t:t),r){for(var s in r)if(r[s])a=a?a+" "+s:s;else if(a.length)for(var i=s.length,l=0;(l=a.indexOf(s,l))>=0;){var c=l+i;(l===0||R1.includes(a[l-1]))&&(c===a.length||R1.includes(a[c]))?a=(l===0?"":a.substring(0,l))+a.substring(c+1):l=c}}return a===""?null:a}function O6(e,t){return e==null?null:String(e)}function zt(e,t,r,a,s,i){var l=e.__className;if(l!==r||l===void 0){var c=T6(r,a,i);c==null?e.removeAttribute("class"):e.className=c,e.__className=r}else if(i&&s!==i)for(var u in i){var o=!!i[u];(s==null||o!==!!s[u])&&e.classList.toggle(u,o)}return i}function $7(e,t,r,a){var s=e.__style;if(s!==t){var i=O6(t);i==null?e.removeAttribute("style"):e.style.cssText=i,e.__style=t}return a}function t1(e,t,r){var a=nt(e,t);a&&a.set&&(e[t]=r,p1(()=>{e[t]=null}))}class _1{#e=new WeakMap;#t;#r;static entries=new WeakMap;constructor(t){this.#r=t}observe(t,r){var a=this.#e.get(t)||new Set;return a.add(r),this.#e.set(t,a),this.#n().observe(t,this.#r),()=>{var s=this.#e.get(t);s.delete(r),s.size===0&&(this.#e.delete(t),this.#t.unobserve(t))}}#n(){return this.#t??(this.#t=new ResizeObserver(t=>{for(var r of t){_1.entries.set(r.target,r);for(var a of this.#e.get(r.target)||[])a(r)}}))}}var I6=new _1({box:"border-box"});function R6(e,t,r){var a=I6.observe(e,()=>r(e[t]));r5(()=>(x(()=>r(e[t])),a))}function $1(e,t){return e===t||e?.[mt]===t}function Rt(e={},t,r,a){return r5(()=>{var s,i;return m1(()=>{s=i,i=[],x(()=>{e!==r(...i)&&(t(e,...i),s&&$1(r(...s),e)&&t(null,...s))})}),()=>{c5(()=>{i&&$1(r(...i),e)&&t(null,...i)})}}),e}function Lt(e=!1){const t=pe,r=t.l.u;if(!r)return;let a=()=>Z(t.s);if(e){let s=0,i={};const l=M7(()=>{let c=!1;const u=t.s;for(const o in u)u[o]!==i[o]&&(i[o]=u[o],c=!0);return c&&s++,s});a=()=>n(l)}r.b.length&&n6(()=>{F1(t,a),p7(r.b)}),n1(()=>{const s=x(()=>r.m.map(O5));return()=>{for(const i of s)typeof i=="function"&&i()}}),r.a.length&&n1(()=>{F1(t,a),p7(r.a)})}function F1(e,t){if(e.l.s)for(const r of e.l.s)n(r);t()}function y1(e,t,r){if(e==null)return t(void 0),r&&r(void 0),pt;const a=x(()=>e.subscribe(t,r));return a.unsubscribe?()=>a.unsubscribe():a}const Wt=[];function $6(e,t){return{subscribe:et(e,t).subscribe}}function et(e,t=pt){let r=null;const a=new Set;function s(c){if(V1(e,c)&&(e=c,r)){const u=!Wt.length;for(const o of a)o[1](),Wt.push(o,e);if(u){for(let o=0;o<Wt.length;o+=2)Wt[o][0](Wt[o+1]);Wt.length=0}}}function i(c){s(c(e))}function l(c,u=pt){const o=[c,u];return a.add(o),a.size===1&&(r=t(s,i)||pt),c(e),()=>{a.delete(o),a.size===0&&r&&(r(),r=null)}}return{set:s,update:i,subscribe:l}}function g5(e,t,r){const a=!Array.isArray(e),s=a?[e]:e;if(!s.every(Boolean))throw new Error("derived() expects stores as input, got a falsy value");const i=t.length<2;return $6(r,(l,c)=>{let u=!1;const o=[];let v=0,g=pt;const p=()=>{if(v)return;g();const E=t(a?o[0]:o,l,c);i?l(E):g=typeof E=="function"?E:pt},d=s.map((E,C)=>y1(E,b=>{o[C]=b,v&=~(1<<C),u&&p()},()=>{v|=1<<C}));return u=!0,p(),function(){p7(d),g(),u=!1}})}function F6(e){let t;return y1(e,r=>t=r)(),t}let v7=!1,i1=Symbol();function Qe(e,t,r){const a=r[t]??={store:null,source:D(void 0),unsubscribe:pt};if(a.store!==e&&!(i1 in r))if(a.unsubscribe(),a.store=e??null,e==null)a.source.v=void 0,a.unsubscribe=pt;else{var s=!0;a.unsubscribe=y1(e,i=>{s?a.source.v=i:w(a.source,i)}),s=!1}return e&&i1 in r?F6(e):n(a.source)}function F7(){const e={};function t(){p1(()=>{for(var r in e)e[r].unsubscribe();Z1(e,i1,{enumerable:!1,value:!0})})}return[e,t]}function N6(e){var t=v7;try{return v7=!1,[e(),v7]}finally{v7=t}}const P6={get(e,t){let r=e.props.length;for(;r--;){let a=e.props[r];if(t7(a)&&(a=a()),typeof a=="object"&&a!==null&&t in a)return a[t]}},set(e,t,r){let a=e.props.length;for(;a--;){let s=e.props[a];t7(s)&&(s=s());const i=nt(s,t);if(i&&i.set)return i.set(r),!0}return!1},getOwnPropertyDescriptor(e,t){let r=e.props.length;for(;r--;){let a=e.props[r];if(t7(a)&&(a=a()),typeof a=="object"&&a!==null&&t in a){const s=nt(a,t);return s&&!s.configurable&&(s.configurable=!0),s}}},has(e,t){if(t===mt||t===U1)return!1;for(let r of e.props)if(t7(r)&&(r=r()),r!=null&&t in r)return!0;return!1},ownKeys(e){const t=[];for(let r of e.props)if(t7(r)&&(r=r()),!!r){for(const a in r)t.includes(a)||t.push(a);for(const a of Object.getOwnPropertySymbols(r))t.includes(a)||t.push(a)}return t}};function St(...e){return new Proxy({props:e},P6)}function Le(e,t,r,a){var s=!Yt||(r&z5)!==0,i=(r&Y5)!==0,l=a,c=!0,u=()=>(c&&(c=!1,l=a),l),o;{var v=mt in e||U1 in e;o=nt(e,t)?.set??(v&&t in e?_=>e[t]=_:void 0)}var g,p=!1;[g,p]=N6(()=>e[t]),g===void 0&&a!==void 0&&(g=u(),o&&(s&&Z5(),o(g)));var d;if(s?d=()=>{var _=e[t];return _===void 0?u():(c=!0,_)}:d=()=>{var _=e[t];return _!==void 0&&(l=void 0),_===void 0?l:_},s&&(r&G5)===0)return d;if(o){var E=e.$$legacy;return function(_,$){return arguments.length>0?((!s||!$||E||p)&&o($?d():_),_):d()}}var C=!1,b=ke(()=>(C=!1,d()));n(b);var k=fe;return function(_,$){if(arguments.length>0){const N=$?n(b):s&&i?Ht(_):_;return w(b,N),C=!0,l!==void 0&&(l=N),_}return yt&&C||(k.f&k7)!==0?b.v:n(b)}}function gt(e){pe===null&&S7(),Yt&&pe.l!==null?y5(pe).m.push(e):n1(()=>{const t=x(e);if(typeof t=="function")return t})}function Z6(e){pe===null&&S7(),gt(()=>()=>x(e))}function D6(e,t,{bubbles:r=!1,cancelable:a=!1}={}){return new CustomEvent(e,{detail:t,bubbles:r,cancelable:a})}function _5(){const e=pe;return e===null&&S7(),(t,r,a)=>{const s=e.s.$$events?.[t];if(s){const i=L7(s)?s.slice():[s],l=D6(t,r,a);for(const c of i)c.call(e.x,l);return!l.defaultPrevented}return!0}}function B6(e){pe===null&&S7(),pe.l===null&&P5(),y5(pe).a.push(e)}function y5(e){var t=e.l;return t.u??={a:[],b:[],m:[]}}const q6="5";typeof window<"u"&&((window.__svelte??={}).v??=new Set).add(q6);W5();const U6="modulepreload",W6=function(e){return"/"+e},N1={},$t=function(t,r,a){let s=Promise.resolve();if(r&&r.length>0){let o=function(v){return Promise.all(v.map(g=>Promise.resolve(g).then(p=>({status:"fulfilled",value:p}),p=>({status:"rejected",reason:p}))))};var l=o;document.getElementsByTagName("link");const c=document.querySelector("meta[property=csp-nonce]"),u=c?.nonce||c?.getAttribute("nonce");s=o(r.map(v=>{if(v=W6(v),v in N1)return;N1[v]=!0;const g=v.endsWith(".css"),p=g?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${v}"]${p}`))return;const d=document.createElement("link");if(d.rel=g?"stylesheet":U6,g||(d.as="script"),d.crossOrigin="",d.href=v,u&&d.setAttribute("nonce",u),document.head.appendChild(d),g)return new Promise((E,C)=>{d.addEventListener("load",E),d.addEventListener("error",()=>C(new Error(`Unable to preload CSS for ${v}`)))})}))}function i(c){const u=new Event("vite:preloadError",{cancelable:!0});if(u.payload=c,window.dispatchEvent(u),!u.defaultPrevented)throw c}return s.then(c=>{for(const u of c||[])u.status==="rejected"&&i(u.reason);return t().catch(i)})};function H6(){const{subscribe:e,set:t,update:r}=et({connected:!1,isConnected:!1,lastMessage:null,error:null});let a=null;const s=new Map;function i(){try{a=new WebSocket("ws://localhost:3030"),a.onopen=()=>{console.log("WebSocket connected"),r(u=>({...u,connected:!0,isConnected:!0,error:null}))},a.onmessage=u=>{try{const o=JSON.parse(u.data);if(console.log("WebSocket message received:",o),o.serverTime&&$t(async()=>{const{timeStore:v}=await Promise.resolve().then(()=>dr);return{timeStore:v}},void 0).then(({timeStore:v})=>{v.updateServerTime(o.serverTime)}),r(v=>({...v,lastMessage:o})),o.operationId&&s.has(o.operationId)){const v=s.get(o.operationId);s.delete(o.operationId),v(o)}}catch(o){console.error("Error parsing WebSocket message:",o)}},a.onclose=()=>{console.log("WebSocket disconnected"),r(u=>({...u,connected:!1,isConnected:!1})),setTimeout(i,3e3)},a.onerror=u=>{console.error("WebSocket error:",u),r(o=>({...o,error:u.message}))}}catch(u){console.error("Failed to create WebSocket connection:",u),r(o=>({...o,error:u.message}))}}function l(u){if(a&&a.readyState===WebSocket.OPEN){const o={operationId:c(),...u};return console.log("Sending WebSocket message:",o),a.send(JSON.stringify(o)),new Promise(v=>{s.set(o.operationId,v),setTimeout(()=>{s.has(o.operationId)&&(s.delete(o.operationId),v({error:"Timeout waiting for response"}))},1e4)})}else return Promise.resolve({error:"WebSocket not connected"})}function c(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(u){const o=Math.random()*16|0;return(u==="x"?o:o&3|8).toString(16)})}return i(),{subscribe:e,send:l,connect:i}}const Ce=H6(),V6=et([]);function j6(e){if(!e||typeof e!="object")return{};const t={};for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){const a=e[r];["string","number","boolean"].includes(typeof a)?t[r]=a:a instanceof Error?t[r]={message:a.message,stack:a.stack}:t[r]=JSON.stringify(a,null,2)}return t}function L(e,t,r={}){const a=new Date().toISOString().slice(0,19).replace("T"," ");V6.update(i=>[...i.slice(-100),{timestamp:a,level:e,message:t,context:r}]);let s;Ce.subscribe(i=>s=i)(),Ce&&s&&s.connected&&Ce.send({command:"logClientEvent",payload:{level:e,message:t,context:j6(r)}})}function z6(){const{subscribe:e,set:t,update:r}=et({transactionId:null,uuid:null,items:[],total:0,tax:0,status:"idle",paymentType:null,paymentAmount:null,metadata:{}});let a=null,s=[];function i(){t({transactionId:null,uuid:null,items:[],total:0,tax:0,status:"idle",paymentType:null,paymentAmount:null,metadata:{}}),a=null,s=[],L("INFO","Order reset and ready for new transaction.")}Ce.subscribe(d=>{let E;if(e(C=>E=C)(),d.lastMessage?.command==="orderUpdated"&&d.lastMessage.status==="success"&&d.lastMessage.payload){const C=d.lastMessage.payload;if(r(b=>({...b,transactionId:C.id,uuid:C.uuid,items:C.items||[],total:parseFloat(C.total_amount),tax:parseFloat(C.tax_amount),status:"active",metadata:C.metadata?typeof C.metadata=="string"?JSON.parse(C.metadata):C.metadata:{}})),L("INFO",`Order ${C.id} updated.`),E.status==="initializing"&&s.length>0){const b=[...s];s=[],b.forEach(({itemId:k,quantity:_,userId:$})=>{L("INFO",`Adding queued item ${k} to transaction ${C.id}`),Ce.send({command:"addItemToTransaction",payload:{transactionId:C.id,itemId:k,quantity:_,userId:$}})})}}else if(d.lastMessage?.command==="transactionFinished"&&d.lastMessage.status==="success"){const C=d.lastMessage.payload;C.transaction?(r(b=>({...b,transactionId:C.transaction.id,uuid:C.transaction.uuid,items:C.transaction.items||[],total:parseFloat(C.transaction.total_amount),tax:parseFloat(C.transaction.tax_amount),status:"finished",paymentType:C.transaction.payment_type,paymentAmount:parseFloat(C.transaction.payment_amount),metadata:C.transaction.metadata?typeof C.transaction.metadata=="string"?JSON.parse(C.transaction.metadata):C.transaction.metadata:{}})),L("SUCCESS",`Transaction ${C.transaction.id} finished successfully.`)):(L("SUCCESS",`Transaction ${E.transactionId} finished successfully.`),r(b=>({...b,status:"finished"}))),setTimeout(()=>{L("INFO","Auto-resetting order for next transaction."),i()},2e3)}});async function l(d=1,E={}){return a||(r(C=>({...C,status:"initializing"})),L("INFO","Initializing new order..."),a=new Promise((C,b)=>{let k;k=Ce.subscribe(_=>{_.lastMessage?.command==="orderUpdated"&&_.lastMessage.status==="success"?(k&&k(),C(_.lastMessage.payload)):_.lastMessage?.command==="orderUpdated"&&_.lastMessage.status==="error"&&(k&&k(),r($=>({...$,status:"error"})),b(new Error(_.lastMessage.payload?.message||"Failed to initialize order")))})}),Ce.send({command:"findOrCreateActiveTransaction",payload:{criteria:{metadata:E},userId:d}}),a)}async function c(d,E=1,C=1){let b;if(e(k=>b=k)(),b.status==="idle"){L("INFO",`First item click detected. Initializing order and queuing item ${d}...`),s.push({itemId:d,quantity:E,userId:C});try{await l(C)}catch(k){L("ERROR",`Failed to initialize order: ${k.message}`),s=[];return}return}if(b.status==="initializing"){L("INFO",`Order initializing. Queuing item ${d}...`),s.push({itemId:d,quantity:E,userId:C});return}if(b.status==="active"&&b.transactionId){L("INFO",`Adding item ${d} to transaction ${b.transactionId}`),Ce.send({command:"addItemToTransaction",payload:{transactionId:b.transactionId,itemId:d,quantity:E,userId:C}});return}L("ERROR","Cannot add item: invalid order state.")}async function u(d,E=1){let C;if(e(b=>C=b)(),!C.transactionId||C.status!=="active"){L("ERROR","No active order to finish.");return}L("INFO",`Finishing transaction ${C.transactionId}...`),Ce.send({command:"finishTransaction",payload:{transactionId:C.transactionId,paymentData:d,userId:E}})}async function o(d,E=1,C=!0){let b;if(e(k=>b=k)(),!b.transactionId||b.status!=="active"){L("ERROR","No active order to park.");return}return L("INFO",`Parking transaction ${b.transactionId} to table ${d} (updateTime: ${C})...`),new Promise(async(k,_)=>{const $=Ce.subscribe(async N=>{if(N.lastMessage?.command==="parkTransactionResponse"&&N.lastMessage.status==="success"){$(),i(),L("SUCCESS",`Order parked to table ${d}`);try{const{parkedOrdersStore:q}=await $t(async()=>{const{parkedOrdersStore:I}=await Promise.resolve().then(()=>l1);return{parkedOrdersStore:I}},void 0);await q.refresh(),L("INFO","Parked orders list refreshed")}catch{L("WARNING","Could not refresh parked orders list after parking")}k(N.lastMessage.payload)}else N.lastMessage?.command==="parkTransactionResponse"&&N.lastMessage.status==="error"&&($(),L("ERROR",`Failed to park order: ${N.lastMessage.payload?.message||"Unknown error"}`),_(new Error(N.lastMessage.payload?.message||"Failed to park order")))});Ce.send({command:"parkTransaction",payload:{transactionId:b.transactionId,tableIdentifier:d,userId:E,updateTimestamp:C}})})}function v(d){L("INFO",`Loading order ${d.id}...`),r(E=>({...E,transactionId:d.id,uuid:d.uuid,items:d.items||[],total:parseFloat(d.total_amount),tax:parseFloat(d.tax_amount),status:"active",metadata:d.metadata?typeof d.metadata=="string"?JSON.parse(d.metadata):d.metadata:{}})),L("SUCCESS",`Order ${d.id} loaded successfully`)}async function g(d,E=1){let C;if(e(b=>C=b)(),!C.transactionId||C.status!=="active")throw L("ERROR","No active order to assign table number to."),new Error("No active order to assign table number to.");L("INFO",`Checking availability and assigning table ${d} to transaction ${C.transactionId}...`);try{const b=Math.random().toString(36).substring(2,15),k=await new Promise((_,$)=>{const N=setTimeout(()=>{q&&q(),$(new Error("Table availability check timeout"))},5e3);let q;q=Ce.subscribe(I=>{I.lastMessage?.command==="checkTableAvailabilityResponse"&&I.lastMessage?.operationId===b&&(clearTimeout(N),q&&q(),_(I.lastMessage))}),Ce.send({operationId:b,command:"checkTableAvailability",payload:{tableNumber:d,excludeTransactionId:C.transactionId}})});if(console.log("Table availability check result:",k),k.status==="success"&&k.payload.isInUse)return L("ERROR",`Table ${d} is already in use by another order`),{tableInUse:!0};r(_=>({..._,metadata:{..._.metadata,table:d}})),Ce.send({command:"updateTransactionMetadata",payload:{transactionId:C.transactionId,metadata:{...C.metadata,table:d},userId:E}}),L("SUCCESS",`Table ${d} assigned to order`)}catch(b){throw L("ERROR",`Failed to assign table ${d}: ${b.message}`),b}}async function p(){L("INFO","Clearing active order view"),i();try{const{parkedOrdersStore:d}=await $t(async()=>{const{parkedOrdersStore:E}=await Promise.resolve().then(()=>l1);return{parkedOrdersStore:E}},void 0);await d.refreshParkedOrders()}catch{L("WARNING","Could not refresh parked orders after clearing view")}}return{subscribe:e,set:t,update:r,initializeOrder:l,addItem:c,finishOrder:u,resetOrder:i,parkCurrentOrder:o,assignTableNumber:g,loadOrder:v,clearActiveOrderView:p}}const Oe=z6(),G6=Object.freeze(Object.defineProperty({__proto__:null,orderStore:Oe},Symbol.toStringTag,{value:"Module"}));function Y6(){const{subscribe:e,set:t,update:r}=et({receipts:[],loading:!1,error:null,lastUpdated:null});Ce.subscribe(i=>{if(i.lastMessage?.command==="getRecentReceiptsResponse")if(i.lastMessage.status==="success"){const l=i.lastMessage.payload;if(l.success&&l.transactions){const c=l.transactions.map(u=>({...u,metadata:u.metadata?JSON.parse(u.metadata):{}}));r(u=>({...u,receipts:c,loading:!1,error:null,lastUpdated:new Date})),L("INFO",`Loaded ${l.transactions.length} recent receipts.`)}else r(c=>({...c,loading:!1,error:l.message||"Failed to load receipts"})),L("ERROR",`Failed to load receipts: ${l.message||"Unknown error"}`)}else r(l=>({...l,loading:!1,error:i.lastMessage.payload?.message||"Failed to load receipts"})),L("ERROR",`Failed to load receipts: ${i.lastMessage.payload?.message||"Unknown error"}`)});function a(i=20){r(c=>({...c,loading:!0,error:null})),L("INFO",`Loading recent receipts (limit: ${i})...`);let l;Ce.subscribe(c=>l=c)(),l&&l.connected?Ce.send({command:"getRecentReceipts",payload:{limit:i}}):(L("WARNING","WebSocket not connected, skipping receipt load"),r(c=>({...c,loading:!1,error:"WebSocket connection not available"})))}function s(){L("INFO","Refreshing receipts..."),a()}return{subscribe:e,loadReceipts:a,refresh:s}}const E7=Y6(),Ft=et("order");g5(Ft,e=>{const t=["order","receipts","agent"],r=t.indexOf(e);return[...t.slice(r),...t.slice(0,r)]});const J6=Object.freeze(Object.defineProperty({__proto__:null,currentView:Ft},Symbol.toStringTag,{value:"Module"}));function X6(){const{subscribe:e,set:t,update:r}=et({isActive:!1,mode:null,liveValue:"",confirmCallback:null,cancelCallback:null,lastRedClickTime:0,errorMessage:null});return{subscribe:e,activate(a,s,i){t({isActive:!0,mode:a,liveValue:"",confirmCallback:s,cancelCallback:i,lastRedClickTime:0,errorMessage:null})},deactivate(){t({isActive:!1,mode:null,liveValue:"",confirmCallback:null,cancelCallback:null,lastRedClickTime:0,errorMessage:null})},append(a){r(s=>s.isActive?{...s,liveValue:s.liveValue+a,errorMessage:null}:s)},backspace(){r(a=>a.isActive?{...a,liveValue:a.liveValue.slice(0,-1),errorMessage:null}:a)},clear(){r(a=>a.isActive?{...a,liveValue:"",errorMessage:null}:a)},async confirm(){let a,s,i;if(r(l=>(a=l,l)),!(!a.isActive||!a.confirmCallback)){s=a.confirmCallback,i=a.liveValue;try{await s(i),r(()=>({isActive:!1,mode:null,liveValue:"",confirmCallback:null,cancelCallback:null,lastRedClickTime:0,errorMessage:null}))}catch(l){console.error("Pinpad confirm callback failed:",l),r(()=>({isActive:!1,mode:null,liveValue:"",confirmCallback:null,cancelCallback:null,lastRedClickTime:0,errorMessage:null}))}}},cancel(){r(a=>{const s=Date.now();if(s-a.lastRedClickTime<300){const l=a.cancelCallback,c={isActive:!1,mode:null,liveValue:"",confirmCallback:null,cancelCallback:null,lastRedClickTime:0,errorMessage:null};return l&&setTimeout(()=>l(),0),c}else return{...a,liveValue:"",lastRedClickTime:s,errorMessage:null}})},activateTableEntry(){this.activate("table",async a=>{if(a&&a.trim())try{const s=await Oe.assignTableNumber(a.trim());if(s&&s.tableInUse){r(i=>({...i,liveValue:""}));return}return s}catch(s){throw s}},()=>{})},activateTableEntryWithAutoCollapse(){this.activate("table",async a=>{if(a&&a.trim())try{const s=await Oe.assignTableNumber(a.trim());if(s&&s.tableInUse){r(u=>({...u,liveValue:""}));return}let i;Oe.subscribe(u=>i=u)();const l=i.items&&i.items.length>0,c=i.metadata&&i.metadata.table;if(l&&c){await Oe.parkCurrentOrder(c,1,!1);const{parkedOrdersStore:u}=await $t(async()=>{const{parkedOrdersStore:o}=await Promise.resolve().then(()=>l1);return{parkedOrdersStore:o}},void 0);return await u.refresh(),Oe.resetOrder(),window.dispatchEvent(new CustomEvent("autoCollapseComplete")),{autoCollapsed:!0}}return s}catch(s){throw s}},()=>{})}}}const We=X6(),K6=Object.freeze(Object.defineProperty({__proto__:null,pinpadStore:We},Symbol.toStringTag,{value:"Module"}));var Q6=B('<div class="loading svelte-1x7q16i">Loading receipts...</div>'),er=B('<div class="error svelte-1x7q16i"> </div>'),tr=B('<div class="empty svelte-1x7q16i">No receipts found.</div>'),rr=B('<span class="receipt-table-large svelte-1x7q16i"> </span>'),nr=B('<div class="item-row svelte-1x7q16i"><span class="item-qty svelte-1x7q16i"> </span> <span class="item-name svelte-1x7q16i"> </span> <span class="item-price svelte-1x7q16i"> </span></div>'),ar=B('<div class="receipt-details svelte-1x7q16i"><div class="items-list svelte-1x7q16i"></div> <div class="receipt-totals svelte-1x7q16i"><div class="total-row svelte-1x7q16i"><span>Tax:</span> <span class="price svelte-1x7q16i"> </span></div> <div class="total-row total svelte-1x7q16i"><span>Total:</span> <span class="price svelte-1x7q16i"> </span></div></div> <div class="receipt-actions svelte-1x7q16i"><button class="action-button svelte-1x7q16i">🖨️ Reprint</button></div></div>'),sr=B('<div><div class="receipt-summary svelte-1x7q16i"><div class="receipt-left svelte-1x7q16i"><div class="receipt-main-line svelte-1x7q16i"><span class="receipt-id-large svelte-1x7q16i"> </span> <!></div> <div class="receipt-date svelte-1x7q16i"> </div> <div class="receipt-payment svelte-1x7q16i"> </div></div> <div class="receipt-right svelte-1x7q16i"><div class="receipt-price svelte-1x7q16i"><span class="price svelte-1x7q16i"> </span></div> <div class="receipt-meta svelte-1x7q16i"><div class="receipt-items-count svelte-1x7q16i"> </div></div></div> <div class="expand-icon svelte-1x7q16i"> </div></div> <!></div>'),ir=B('<div class="receipt-list svelte-1x7q16i"></div>'),lr=B('<div class="receipt-feed svelte-1x7q16i"><!></div>');function or(e,t){ot(t,!1);const[r,a]=F7(),s=()=>Qe(E7,"$receiptsStore",r);let i=Le(t,"autoExpandLatest",8,!1),l=D(null),c=D(!1),u=D();gt(()=>{E7.loadReceipts()});function o(_){w(c,!0),w(l,n(l)===_?null:_)}function v(_){return new Date(_).toLocaleString("de-DE",{day:"2-digit",month:"2-digit",year:"numeric",hour:"2-digit",minute:"2-digit"})}function g(_){return parseFloat(_).toFixed(2)+"€"}function p(_){return _.display_names&&_.display_names.menu&&_.display_names.menu.de?_.display_names.menu.de:"Unnamed Item"}function d(_){L("INFO",`Reprint requested for receipt №${_.id}`),console.log("Reprint receipt:",_)}Me(()=>Z(i()),()=>{i()&&w(c,!1)}),Me(()=>(Z(i()),n(c),s(),n(l)),()=>{if(i()&&!n(c)&&s().receipts.length>0){const $=s().receipts.sort((N,q)=>new Date(q.fiscal_timestamp||q.updated_at)-new Date(N.fiscal_timestamp||N.updated_at))[0]?.id;$&&n(l)!==$&&w(l,$)}}),Jt(),Lt();var E=lr(),C=m(E);{var b=_=>{var $=Q6();P(_,$)},k=(_,$)=>{{var N=I=>{var W=er(),se=m(W);ne(()=>H(se,`Error: ${s(),x(()=>s().error)??""}`)),P(I,W)},q=(I,W)=>{{var se=te=>{var z=tr();P(te,z)},Q=te=>{var z=ir();xt(z,5,()=>(s(),x(()=>s().receipts.sort((ie,R)=>new Date(ie.fiscal_timestamp||ie.updated_at)-new Date(R.fiscal_timestamp||R.updated_at)))),ie=>ie.id,(ie,R)=>{var X=sr();let F;var re=m(X),U=m(re),J=m(U),G=m(J),V=m(G),K=A(G,2);{var ee=be=>{var Re=rr(),Je=m(Re);ne(()=>H(Je,`#${n(R),x(()=>n(R).metadata.table)??""}`)),P(be,Re)};Y(K,be=>{n(R),x(()=>n(R).metadata?.table)&&be(ee)})}var ce=A(J,2),ue=m(ce),de=A(ce,2),we=m(de),le=A(U,2),ye=m(le),Se=m(ye),Ze=m(Se),ge=A(ye,2),Ee=m(ge),Te=m(Ee),ae=A(le,2),j=m(ae),ve=A(re,2);{var Ie=be=>{var Re=ar(),Je=m(Re);xt(Je,5,()=>(n(R),x(()=>n(R).items)),rt=>rt.id,(rt,Ge)=>{var u7=nr(),Qt=m(u7),B7=m(Qt),d7=A(Qt,2),q7=m(d7),U7=A(d7,2),f=m(U7);ne((h,M)=>{H(B7,`${n(Ge),x(()=>n(Ge).quantity)??""}x`),H(q7,h),H(f,M)},[()=>(n(Ge),x(()=>p(n(Ge)))),()=>(n(Ge),x(()=>g(n(Ge).total_price)))],ke),P(rt,u7)});var Nt=A(Je,2),Pt=m(Nt),Xt=A(m(Pt),2),Kt=m(Xt),N7=A(Pt,2),P7=A(m(N7),2),Z7=m(P7),tt=A(Nt,2),D7=m(tt);ne((rt,Ge)=>{H(Kt,rt),H(Z7,Ge)},[()=>(n(R),x(()=>g(n(R).tax_amount))),()=>(n(R),x(()=>g(n(R).total_amount)))],ke),oe("click",D7,()=>d(n(R))),P(be,Re)};Y(ve,be=>{n(l),n(R),x(()=>n(l)===n(R).id)&&be(Ie)})}ne((be,Re,Je)=>{F=zt(X,1,"receipt-item svelte-1x7q16i",null,F,be),H(V,`№${n(R),x(()=>n(R).id)??""}`),H(ue,Re),H(we,(n(R),x(()=>n(R).payment_type||"Unknown"))),H(Ze,Je),H(Te,`${n(R),x(()=>n(R).items?.length||0)??""} items`),H(j,(n(l),n(R),x(()=>n(l)===n(R).id?"▼":"▶")))},[()=>({expanded:n(l)===n(R).id}),()=>(n(R),x(()=>v(n(R).fiscal_timestamp||n(R).updated_at))),()=>(n(R),x(()=>g(n(R).total_amount)))],ke),oe("click",re,()=>o(n(R).id)),P(ie,X)}),Rt(z,ie=>w(u,ie),()=>n(u)),P(te,z)};Y(I,te=>{s(),x(()=>s().receipts.length===0)?te(se):te(Q,!1)},W)}};Y(_,I=>{s(),x(()=>s().error)?I(N):I(q,!1)},$)}};Y(C,_=>{s(),x(()=>s().loading)?_(b):_(k,!1)})}P(e,E),ct(),a()}class cr{constructor(){this.store=et([]),this.subscribe=this.store.subscribe,this.set=this.store.set,this.update=this.store.update}async refreshParkedOrders(){try{L("DEBUG","Requesting parked transactions...");const t=this.generateUUID();L("DEBUG",`Generated operationId: ${t}`);const r=await this.sendRequestWithFallback(t,"getParkedTransactions",{});L("DEBUG",`Parked transactions response: ${JSON.stringify(r)}`),r.status==="success"?(L("DEBUG",`Setting parked orders: ${JSON.stringify(r.payload)}`),this.set(r.payload||[])):(L("ERROR",`Failed to fetch parked orders: ${JSON.stringify(r)}`),this.set([]))}catch(t){L("ERROR",`Error fetching parked orders: ${t.message}`),this.set([])}}async sendRequestWithFallback(t,r,a){try{return await this.sendWebSocketRequest(t,r,a)}catch(s){L("WARNING",`WebSocket request failed, trying HTTP fallback: ${s.message}`);try{return await this.sendHttpRequest(t,r,a)}catch(i){throw L("ERROR",`Both WebSocket and HTTP requests failed: ${i.message}`),i}}}sendWebSocketRequest(t,r,a){return new Promise((s,i)=>{let l;if(Ce.subscribe(o=>l=o)(),!l||!l.connected){i(new Error("WebSocket is not connected"));return}const c=setTimeout(()=>{u(),i(new Error("WebSocket request timeout"))},3e3),u=Ce.subscribe(o=>{o.lastMessage&&o.lastMessage.operationId===t&&(clearTimeout(c),u(),s(o.lastMessage))});Ce.send({operationId:t,command:r,payload:a})})}async sendHttpRequest(t,r,a){const s=await fetch("/api/websocket-fallback",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({operationId:t,command:r,payload:a})});if(!s.ok)throw new Error(`HTTP request failed: ${s.status}`);return await s.json()}refresh(){return this.refreshParkedOrders()}async activateOrder(t,r=!1){try{const a=this.generateUUID(),s=await this.sendRequestWithFallback(a,"activateTransaction",{transactionId:t,userId:1,updateTimestamp:r});if(s.status==="success")return r&&await this.refreshParkedOrders(),s.payload;throw new Error(s.payload?.message||"Failed to activate order")}catch(a){throw L("ERROR",`Error activating order: ${a.message}`),a}}generateUUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){const r=Math.random()*16|0;return(t==="x"?r:r&3|8).toString(16)})}}const Vt=new cr,l1=Object.freeze(Object.defineProperty({__proto__:null,parkedOrdersStore:Vt},Symbol.toStringTag,{value:"Module"}));class ur{constructor(){this.store=et({serverTime:null,clientTime:null,timeOffset:0,lastSync:null}),this.subscribe=this.store.subscribe,this.update=this.store.update,this.set=this.store.set}updateServerTime(t){const r=new Date(t),a=new Date,s=r.getTime()-a.getTime();this.update(i=>({...i,serverTime:r,clientTime:a,timeOffset:s,lastSync:a}))}getServerTime(){let t;if(this.subscribe(a=>t=a)(),!t.lastSync)return new Date;const r=new Date;return new Date(r.getTime()+t.timeOffset)}formatTimeElapsed(t){const r=new Date,a=new Date(t),s=r.getTime()-a.getTime(),i=Math.floor(s/(1e3*60));return i>0?i:0}resetTimeOffset(){this.update(t=>({...t,timeOffset:0,lastSync:null}))}}const l7=new ur,b1=g5(l7,(e,t)=>{const r=()=>{const s=l7.getServerTime();t(s)};r();const a=setInterval(r,1e3);return()=>clearInterval(a)},new Date),dr=Object.freeze(Object.defineProperty({__proto__:null,currentTime:b1,timeStore:l7},Symbol.toStringTag,{value:"Module"}));var fr=B('<div class="no-orders svelte-1yvjwnh"><span>Нет припаркованных заказов</span></div>'),vr=B('<div class="order-item svelte-1yvjwnh"><div class="table-number svelte-1yvjwnh"> </div> <div class="order-stats svelte-1yvjwnh"><div class="stat-price svelte-1yvjwnh"> </div> <div class="stat-open svelte-1yvjwnh"> </div> <div class="stat-activity svelte-1yvjwnh"> </div></div></div>'),Cr=B('<div class="orders-list svelte-1yvjwnh"></div>'),pr=B('<div class="parked-orders-container svelte-1yvjwnh"><!></div>');function mr(e,t){ot(t,!1);let r=D([]),a,s,i=!1;gt(async()=>{a=Vt.subscribe(C=>{w(r,C)}),s=Ce.subscribe(async C=>{C.connected&&!i&&(i=!0,await Vt.refreshParkedOrders())})}),Z6(()=>{a&&a(),s&&s()});async function l(C){try{const{orderStore:b}=await $t(async()=>{const{orderStore:$}=await Promise.resolve().then(()=>G6);return{orderStore:$}},void 0);let k;if(b.subscribe($=>k=$)(),k.transactionId&&k.status==="active"){const $=k.items&&k.items.length>0,N=k.metadata&&k.metadata.table;if($&&N)await b.parkCurrentOrder(N,1,!1),await Vt.refreshParkedOrders();else if($&&!N){const{pinpadStore:q}=await $t(async()=>{const{pinpadStore:W}=await Promise.resolve().then(()=>K6);return{pinpadStore:W}},void 0),{consoleView:I}=await $t(async()=>{const{consoleView:W}=await Promise.resolve().then(()=>J6);return{consoleView:W}},void 0);I.set("order"),q.activateTableEntry();return}else b.resetOrder()}const _=await Vt.activateOrder(C.id,!1);b.loadOrder(_)}catch(b){console.error("Failed to switch to order:",b)}}function c(C){return(parseFloat(C)||0).toFixed(2)+" €"}function u(C){const k=(C.metadata||{}).table||C.id.toString();return k.length>3?`#${k.substring(0,3)}`:`#${k}`}function o(C){return l7.formatTimeElapsed(C)}function v(C){const b=o(C.created_at),k=o(C.updated_at);return{price:c(C.total_amount),openMinutes:b,activityMinutes:k}}Lt();var g=pr(),p=m(g);{var d=C=>{var b=fr();P(C,b)},E=C=>{var b=Cr();xt(b,5,()=>n(r),k=>k.id,(k,_)=>{var $=vr(),N=m($),q=m(N),I=A(N,2),W=m(I),se=m(W),Q=A(W,2),te=m(Q),z=A(Q,2),ie=m(z);ne((R,X,F,re)=>{H(q,R),H(se,X),H(te,`${F??""}min`),H(ie,`${re??""}min`)},[()=>u(n(_)),()=>v(n(_)).price,()=>v(n(_)).openMinutes,()=>v(n(_)).activityMinutes],ke),oe("click",$,()=>l(n(_))),P(k,$)}),P(C,b)};Y(p,C=>{n(r).length===0?C(d):C(E,!1)})}P(e,g),ct()}var hr=B('<span class="table-number svelte-1a8nv3l"> </span>'),gr=B('<div class="pinpad-error-message svelte-1a8nv3l"> </div>'),_r=B('<li class="svelte-1a8nv3l"><span class="qty svelte-1a8nv3l"> </span> <span class="name svelte-1a8nv3l"> </span> <span class="price svelte-1a8nv3l"> </span></li>'),yr=B('<div class="view-content order-view svelte-1a8nv3l"><div class="orders-stack svelte-1a8nv3l"><div class="parked-orders-section svelte-1a8nv3l"><!></div> <div class="active-order-section svelte-1a8nv3l"><div class="order-content svelte-1a8nv3l"><h2 class="svelte-1a8nv3l"><span class="order-number svelte-1a8nv3l"> </span><!></h2> <!> <div class="scrollable-items-content svelte-1a8nv3l"><ul class="item-list svelte-1a8nv3l"></ul></div> <div class="spacer svelte-1a8nv3l"></div> <div class="total svelte-1a8nv3l"><span>Total:</span> <span class="price svelte-1a8nv3l"> </span></div></div></div></div></div>'),br=B('<div class="view-content receipts-view svelte-1a8nv3l"><div class="receipts-stack svelte-1a8nv3l"><!></div></div>'),xr=B('<div><span class="message-timestamp svelte-1a8nv3l"> </span> <span class="message-type svelte-1a8nv3l"> </span> <div class="message-content svelte-1a8nv3l"> </div></div>'),wr=B('<div class="view-content svelte-1a8nv3l"><div class="scroll-content svelte-1a8nv3l"><div class="agent-messages svelte-1a8nv3l"></div></div></div>'),Er=B('<div class="console-view svelte-1a8nv3l"><div class="content-area svelte-1a8nv3l"><!></div></div>');function Lr(e,t){ot(t,!1);const[r,a]=F7(),s=()=>Qe(Oe,"$orderStore",r),i=()=>Qe(E7,"$receiptsStore",r),l=()=>Qe(Ft,"$currentView",r),c=()=>Qe(We,"$pinpadStore",r);let u=D(),o=D(),v=D(),g=!1,p=D(!1),d=!1,E=D("order"),C=D(!1),b=D(s().status),k=D(s().items.length),_=D(s().transactionId),$=D(s().metadata?.table);gt(()=>{setTimeout(()=>{d||(I(),q(),d=!0)},200)}),B6(()=>{if(!n(p)){let F=null;l()==="order"?F=n(o):l()==="agent"?F=n(u):l()==="receipts"&&(F=n(v)),F&&setTimeout(()=>{F&&!n(p)&&(q(),g||(w(p,!0),F.scrollTop=F.scrollHeight,setTimeout(()=>{w(p,!1),q()},100)))},50)}});const N=[{timestamp:"10:30",type:"user",message:"Найди товар Кофе"},{timestamp:"10:30",type:"agent",message:'Поиск товара "Кофе"... Найден товар: Кофе Эспрессо - 2.50€'},{timestamp:"10:31",type:"user",message:"Создай товар Капучино цена 3.00 категория Напитки"},{timestamp:"10:31",type:"agent",message:'Создаю товар "Капучино" с ценой 3.00€ в категории "Напитки"... Товар успешно создан.'},{timestamp:"10:32",type:"user",message:"Покажи все товары в категории Напитки"},{timestamp:"10:32",type:"agent",message:`Товары в категории "Напитки":
- Кофе Эспрессо - 2.50€
- Капучино - 3.00€
- Американо - 2.00€`}];function q(){if(!n(p)){let F=null;if(l()==="order"?F=n(o):l()==="agent"?F=n(u):l()==="receipts"&&(F=n(v)),F){const U=F.scrollTop,J=F.clientHeight,G=F.scrollHeight;g=U+J>=G-1}else g=!0}}function I(){let F=null;l()==="order"?F=n(o):l()==="agent"?F=n(u):l()==="receipts"&&(F=n(v)),F&&(F.scrollTop=F.scrollHeight,g=!0)}function W(){let F;switch(n(E)){case"order":F=["order","receipts","agent"];break;case"receipts":F=["receipts","order","agent"];break;case"agent":F=["agent","order","receipts"];break;default:F=["order","receipts","agent"]}const U=(F.indexOf(l())+1)%F.length,J=F[U];l()==="receipts"&&J!=="receipts"&&w(C,!1),Ft.set(J)}function se(){return g}Me(()=>(n(b),s(),n(v)),()=>{n(b)==="finished"&&s().status==="idle"&&(w(E,"receipts"),w(C,!0),Ft.set("receipts"),E7.refresh(),setTimeout(()=>{n(v)&&(S1(v,n(v).scrollTop=n(v).scrollHeight),q())},300)),w(b,s().status)}),Me(()=>(i(),n(v),l()),()=>{i().receipts&&n(v)&&l()==="receipts"&&setTimeout(()=>{q()},100)}),Me(()=>(l(),n(o),s(),n(k),n(_),n($)),()=>{if(l()==="order"&&n(o)){const F=s().items.length,re=s().transactionId,U=s().metadata?.table;(F!==n(k)||re!==n(_)||U!==n($))&&setTimeout(()=>{n(o)&&S1(o,n(o).scrollTop=n(o).scrollHeight)},100),w(k,F),w(_,re),w($,U)}}),Jt(),Lt();var Q=Er(),te=m(Q),z=m(te);{var ie=F=>{var re=yr(),U=m(re),J=m(U),G=m(J);mr(G,{});var V=A(J,2),K=m(V),ee=m(K),ce=m(ee),ue=m(ce),de=A(ce);{var we=ae=>{var j=hr(),ve=m(j);ne(()=>H(ve,`#${c(),s(),x(()=>c().isActive&&c().mode==="table"?c().liveValue:s().metadata?.table)??""}`)),P(ae,j)};Y(de,ae=>{s(),c(),x(()=>s().metadata?.table||c().isActive&&c().mode==="table")&&ae(we)})}var le=A(ee,2);{var ye=ae=>{var j=gr(),ve=m(j);ne(()=>H(ve,(c(),x(()=>c().errorMessage)))),P(ae,j)};Y(le,ae=>{c(),x(()=>c().errorMessage)&&ae(ye)})}var Se=A(le,2),Ze=m(Se);xt(Ze,5,()=>(s(),x(()=>s().items)),ae=>ae.id,(ae,j)=>{var ve=_r(),Ie=m(ve),be=m(Ie),Re=A(Ie,2),Je=m(Re),Nt=A(Re,2),Pt=m(Nt);ne((Xt,Kt)=>{H(be,`${n(j),x(()=>n(j).quantity)??""}x`),H(Je,Xt),H(Pt,`${Kt??""}€`)},[()=>(n(j),x(()=>n(j).display_names?(typeof n(j).display_names=="string"?JSON.parse(n(j).display_names):n(j).display_names).menu.de||"N/A":"Loading...")),()=>(n(j),x(()=>n(j).total_price.toFixed(2)))],ke),P(ae,ve)});var ge=A(Se,4),Ee=A(m(ge),2),Te=m(Ee);Rt(U,ae=>w(o,ae),()=>n(o)),ne(ae=>{H(ue,`Order №${s(),x(()=>s().transactionId||"...")??""}`),H(Te,`${ae??""}€`)},[()=>(s(),x(()=>s().total.toFixed(2)))],ke),oe("scroll",U,()=>!n(p)&&q()),P(F,re)},R=(F,re)=>{{var U=G=>{var V=br(),K=m(V),ee=m(K);or(ee,{get autoExpandLatest(){return n(C)}}),Rt(K,ce=>w(v,ce),()=>n(v)),oe("scroll",K,()=>!n(p)&&q()),P(G,V)},J=(G,V)=>{{var K=ee=>{var ce=wr(),ue=m(ce),de=m(ue);xt(de,5,()=>N,h5,(we,le)=>{var ye=xr();let Se;var Ze=m(ye),ge=m(Ze),Ee=A(Ze,2),Te=m(Ee),ae=A(Ee,2),j=m(ae);ne(ve=>{Se=zt(ye,1,"agent-message svelte-1a8nv3l",null,Se,ve),H(ge,(n(le),x(()=>n(le).timestamp))),H(Te,(n(le),x(()=>n(le).type==="user"?"User":"Agent"))),H(j,(n(le),x(()=>n(le).message)))},[()=>({user:n(le).type==="user",agent:n(le).type==="agent"})],ke),P(we,ye)}),Rt(ue,we=>w(u,we),()=>n(u)),oe("scroll",ue,()=>!n(p)&&q()),P(ee,ce)};Y(G,ee=>{l()==="agent"&&ee(K)},V)}};Y(F,G=>{l()==="receipts"?G(U):G(J,!1)},re)}};Y(z,F=>{l()==="order"?F(ie):F(R,!1)})}P(e,Q),t1(t,"scrollToBottom",I),t1(t,"cycleViews",W),t1(t,"getIsAtBottom",se);var X=ct({scrollToBottom:I,cycleViews:W,getIsAtBottom:se});return a(),X}var kr=B('<div class="slot-container svelte-1sdk9y9"><!></div>'),Sr=B('<span class="button-icon svelte-1sdk9y9"><!></span>'),Ar=B("<div></div>"),Mr=B("<!> <!>",1),Tr=B('<span class="button-text svelte-1sdk9y9"> </span>'),Or=B('<button><div class="button-shape svelte-1sdk9y9"><!></div></button>');function At(e,t){const r=M6(t);ot(t,!1);const a=D(),s=D(),i=D();let l=Le(t,"label",8,""),c=Le(t,"icon",8,""),u=Le(t,"color",8,"#666666"),o=Le(t,"textColor",8,""),v=Le(t,"backgroundStyle",8,""),g=Le(t,"disabled",8,!1),p=Le(t,"data",8,null),d=Le(t,"width",8,120),E=Le(t,"height",8,80),C=Le(t,"shape",8,"rect"),b=Le(t,"side",8,""),k=Le(t,"active",8,!1),_=Le(t,"showShape",8,"");const $=_5();let N,q=!1;function I(){!g()&&!q&&$("click",{data:p(),label:l()})}function W(U){g()||(U.preventDefault(),$("secondaryaction",{data:p(),label:l(),mouseX:U.clientX,mouseY:U.clientY,originalEvent:U}))}function se(U){!g()&&U.button===0&&(q=!1,N=setTimeout(()=>{q=!0,$("secondaryaction",{data:p(),label:l(),mouseX:U.clientX,mouseY:U.clientY,originalEvent:U})},500))}function Q(){clearTimeout(N),setTimeout(()=>{q=!1},10)}function te(){clearTimeout(N),q=!1}Me(()=>Z(b()),()=>{w(a,b()==="left"||b()==="right")}),Me(()=>Z(l()),()=>{w(s,l())}),Me(()=>(Z(C()),n(a),Z(b())),()=>{w(i,C()==="hex"&&n(a)?b()==="left"?"polygon(0% 0%, 100% 25%, 100% 75%, 0% 100%)":"polygon(0% 25%, 100% 0%, 100% 100%, 0% 75%)":C()==="hex"?"polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)":"none")}),Jt(),Lt();var z=Or();let ie;var R=m(z),X=m(R);{var F=U=>{var J=kr(),G=m(J);A6(G,t,"default",{}),P(U,J)},re=(U,J)=>{{var G=K=>{var ee=Mr(),ce=ht(ee);{var ue=le=>{var ye=Sr(),Se=m(ye);S6(Se,c),P(le,ye)};Y(ce,le=>{c()&&le(ue)})}var de=A(ce,2);{var we=le=>{var ye=Ar();ne(()=>zt(ye,1,`shape-overlay ${_()??""}`,"svelte-1sdk9y9")),P(le,ye)};Y(de,le=>{_()&&le(we)})}P(K,ee)},V=(K,ee)=>{{var ce=ue=>{var de=Tr(),we=m(de);ne(()=>H(we,n(s))),P(ue,de)};Y(K,ue=>{l()&&ue(ce)},ee)}};Y(U,K=>{c()||_()?K(G):K(V,!1)},J)}};Y(X,U=>{x(()=>r.default)?U(F):U(re,!1)})}ne(U=>{ie=zt(z,1,`universal-button ${C()??""}`,"svelte-1sdk9y9",ie,U),$7(z,`
    --button-width: ${d()??""}px; 
    --button-height: ${E()??""}px; 
    --button-color: ${u()??""};
    ${o()?`--button-text-color: ${o()};`:""}
    ${v()?`--button-background-style: ${v()};`:""}
    --clip-path: ${n(i)??""};
  `)},[()=>({disabled:g(),half:n(a),left:b()==="left",right:b()==="right",active:k()})],ke),oe("click",z,I),oe("contextmenu",z,W),oe("mousedown",z,se),oe("mouseup",z,Q),oe("mouseleave",z,te),P(e,z),ct()}var Ir=B('<div class="pinpad-wrapper svelte-1hgpdio"><div class="pinpad-grid svelte-1hgpdio"><button class="numpad-key svelte-1hgpdio">1</button> <button class="numpad-key svelte-1hgpdio">2</button> <button class="numpad-key svelte-1hgpdio">3</button> <button class="function-key key-cancel svelte-1hgpdio">X</button> <button class="numpad-key svelte-1hgpdio">4</button> <button class="numpad-key svelte-1hgpdio">5</button> <button class="numpad-key svelte-1hgpdio">6</button> <button class="function-key key-correct svelte-1hgpdio">←</button> <button class="numpad-key svelte-1hgpdio">7</button> <button class="numpad-key svelte-1hgpdio">8</button> <button class="numpad-key svelte-1hgpdio">9</button> <button class="function-key key-enter svelte-1hgpdio">↵</button> <button class="numpad-key function-key key-plus svelte-1hgpdio">+</button> <button class="numpad-key svelte-1hgpdio">0</button> <button class="numpad-key function-key key-minus svelte-1hgpdio">-</button></div></div>');function Rr(e,t){ot(t,!1);let r=Le(t,"onClose",8,()=>{}),a=D(0),s=D(80),i=D(107);const l=8;function c(z){We.append(z.toString())}function u(){We.backspace()}function o(){We.confirm()}function v(){We.cancel()}function g(){r()()}Me(()=>(n(a),n(s)),()=>{n(a)>0&&(w(s,(n(a)-l*3)/4),w(i,n(s)*(4/3)))}),Jt(),Lt();var p=Ir(),d=m(p),E=m(d),C=A(E,2),b=A(C,2),k=A(b,2),_=A(k,2),$=A(_,2),N=A($,2),q=A(N,2),I=A(q,2),W=A(I,2),se=A(W,2),Q=A(se,2),te=A(Q,4);ne(()=>$7(d,`--button-height: ${n(s)??""}px; --button-width: ${n(i)??""}px;`)),oe("click",E,()=>c(1)),oe("click",C,()=>c(2)),oe("click",b,()=>c(3)),oe("click",k,v),oe("dblclick",k,g),oe("click",_,()=>c(4)),oe("click",$,()=>c(5)),oe("click",N,()=>c(6)),oe("click",q,u),oe("click",I,()=>c(7)),oe("click",W,()=>c(8)),oe("click",se,()=>c(9)),oe("click",Q,o),oe("click",te,()=>c(0)),R6(p,"clientHeight",z=>w(a,z)),P(e,p),ct()}var $r=B('<div class="preview-wrapper svelte-10wicgb"><div class="preview-grid svelte-10wicgb"><div class="key svelte-10wicgb">1</div><div class="key svelte-10wicgb">2</div><div class="key cancel svelte-10wicgb">3</div> <div class="key svelte-10wicgb">4</div><div class="key svelte-10wicgb">5</div><div class="key correct svelte-10wicgb">6</div> <div class="key svelte-10wicgb">7</div><div class="key svelte-10wicgb">8</div><div class="key enter svelte-10wicgb">9</div> <div class="key zero svelte-10wicgb">0</div><div class="key clear svelte-10wicgb">C</div></div></div>');function P1(e){var t=$r();P(e,t)}var Fr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Description:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Nr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Allergens:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Pr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Dietary:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Zr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Category:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Dr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Product ID:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Br=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Price:</span> <span class="value svelte-1g1fs6h"> </span></div> <!> <!> <!> <!> <!>',1),qr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Type:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Ur=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Category ID:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Wr=B('<div class="detail-row svelte-1g1fs6h"><span class="label svelte-1g1fs6h">Source ID:</span> <span class="value svelte-1g1fs6h"> </span></div>'),Hr=B("<!> <!> <!>",1),Vr=B('<div class="context-menu svelte-1g1fs6h"><div class="menu-header svelte-1g1fs6h"><h3 class="svelte-1g1fs6h"><!></h3></div> <div class="menu-content svelte-1g1fs6h"><!></div> <div class="menu-footer svelte-1g1fs6h"><button class="edit-button svelte-1g1fs6h">Edit</button> <button class="close-button svelte-1g1fs6h">Close</button></div></div>');function jr(e,t){ot(t,!1);const r=D(),a=D(),s=D();let i=Le(t,"item",8,null),l=Le(t,"x",8,0),c=Le(t,"y",8,0),u=Le(t,"visible",8,!1);const o=_5();let v=D(),g=D(0),p=D(0);gt(()=>{function I(se){n(v)&&!n(v).contains(se.target)&&o("close")}function W(se){se.key==="Escape"&&o("close")}return u()&&(document.addEventListener("click",I),document.addEventListener("keydown",W)),()=>{document.removeEventListener("click",I),document.removeEventListener("keydown",W)}});function d(I){return typeof I=="number"?`€${I.toFixed(2)}`:i()&&i().item_price_value&&typeof i().item_price_value=="number"?`€${i().item_price_value.toFixed(2)}`:I||"N/A"}function E(I){try{const W=JSON.parse(I);return W.menu?.de||W.button?.de||W.de||"Unnamed"}catch{return I||"Unnamed"}}function C(I){try{return JSON.parse(I).de||"Unnamed Category"}catch{return I||"Unnamed Category"}}function b(I){try{return JSON.parse(I)}catch{return{}}}function k(){if(!n(v))return;const I=n(v).getBoundingClientRect(),W=window.innerWidth,se=window.innerHeight;if(I.width===0||I.height===0){setTimeout(()=>k(),10);return}const Q=10,te=10,z=I.width>W-Q*2,ie=I.height>se-Q*2;let R,X;z&&ie?(R=Q,X=Q):z?(R=Q,X=c()+te,X+I.height>se-Q&&(X=c()-I.height-te),X<Q&&(X=Q)):ie?(X=Q,R=l()+te,R+I.width>W-Q&&(R=l()-I.width-te),R<Q&&(R=Q)):(R=l()+te,X=c()+te,R+I.width>W-Q&&(R=l()-I.width-te),X+I.height>se-Q&&(X=c()-I.height-te),R<Q&&(R=Q),X<Q&&(X=Q)),w(g,R),w(p,X)}function _(){o("edit",{item:i()}),o("close")}Me(()=>Z(i()),()=>{w(r,i()&&i().category_names)}),Me(()=>Z(i()),()=>{w(a,i()&&i().display_names)}),Me(()=>(n(a),Z(i())),()=>{w(s,n(a)&&i().additional_item_attributes?b(i().additional_item_attributes):{})}),Me(()=>(Z(u()),n(v)),()=>{u()&&n(v)&&requestAnimationFrame(()=>k())}),Jt(),Lt();var $=w7(),N=ht($);{var q=I=>{var W=Vr(),se=m(W),Q=m(se),te=m(Q);{var z=V=>{var K=e1();ne(ee=>H(K,ee),[()=>(Z(i()),x(()=>C(i().category_names)))],ke),P(V,K)},ie=(V,K)=>{{var ee=ue=>{var de=e1();ne(we=>H(de,we),[()=>(Z(i()),x(()=>E(i().display_names)))],ke),P(ue,de)},ce=ue=>{var de=e1("Item Details");P(ue,de)};Y(V,ue=>{n(a)?ue(ee):ue(ce,!1)},K)}};Y(te,V=>{n(r)?V(z):V(ie,!1)})}var R=A(se,2),X=m(R);{var F=V=>{var K=Br(),ee=ht(K),ce=A(m(ee),2),ue=m(ce),de=A(ee,2);{var we=j=>{var ve=Fr(),Ie=A(m(ve),2),be=m(Ie);ne(()=>H(be,(n(s),x(()=>n(s).description)))),P(j,ve)};Y(de,j=>{n(s),x(()=>n(s).description)&&j(we)})}var le=A(de,2);{var ye=j=>{var ve=Nr(),Ie=A(m(ve),2),be=m(Ie);ne(Re=>H(be,Re),[()=>(n(s),x(()=>n(s).allergens.join(", ")))],ke),P(j,ve)};Y(le,j=>{n(s),x(()=>n(s).allergens&&n(s).allergens.length>0)&&j(ye)})}var Se=A(le,2);{var Ze=j=>{var ve=Pr(),Ie=A(m(ve),2),be=m(Ie);ne(Re=>H(be,Re),[()=>(n(s),x(()=>n(s).dietary_info.join(", ")))],ke),P(j,ve)};Y(Se,j=>{n(s),x(()=>n(s).dietary_info&&n(s).dietary_info.length>0)&&j(Ze)})}var ge=A(Se,2);{var Ee=j=>{var ve=Zr(),Ie=A(m(ve),2),be=m(Ie);ne(()=>H(be,(Z(i()),x(()=>i().associated_category_unique_identifier)))),P(j,ve)};Y(ge,j=>{Z(i()),x(()=>i().associated_category_unique_identifier)&&j(Ee)})}var Te=A(ge,2);{var ae=j=>{var ve=Dr(),Ie=A(m(ve),2),be=m(Ie);ne(()=>H(be,(Z(i()),x(()=>i().id)))),P(j,ve)};Y(Te,j=>{Z(i()),x(()=>i().id)&&j(ae)})}ne(j=>H(ue,j),[()=>(Z(i()),x(()=>d(i().item_price_value)))],ke),P(V,K)},re=(V,K)=>{{var ee=ce=>{var ue=Hr(),de=ht(ue);{var we=ge=>{var Ee=qr(),Te=A(m(Ee),2),ae=m(Te);ne(()=>H(ae,(Z(i()),x(()=>i().category_type)))),P(ge,Ee)};Y(de,ge=>{Z(i()),x(()=>i().category_type)&&ge(we)})}var le=A(de,2);{var ye=ge=>{var Ee=Ur(),Te=A(m(Ee),2),ae=m(Te);ne(()=>H(ae,(Z(i()),x(()=>i().id)))),P(ge,Ee)};Y(le,ge=>{Z(i()),x(()=>i().id)&&ge(ye)})}var Se=A(le,2);{var Ze=ge=>{var Ee=Wr(),Te=A(m(Ee),2),ae=m(Te);ne(()=>H(ae,(Z(i()),x(()=>i().source_unique_identifier)))),P(ge,Ee)};Y(Se,ge=>{Z(i()),x(()=>i().source_unique_identifier)&&ge(Ze)})}P(ce,ue)};Y(V,ce=>{n(r)&&ce(ee)},K)}};Y(X,V=>{n(a)?V(F):V(re,!1)})}var U=A(R,2),J=m(U),G=A(J,2);Rt(W,V=>w(v,V),()=>n(v)),ne(()=>$7(W,`left: ${(n(g)||l())??""}px; top: ${(n(p)||c())??""}px;`)),oe("click",J,()=>_()),oe("click",G,()=>o("close")),P(I,W)};Y(N,I=>{u()&&i()&&I(q)})}P(e,$),ct()}var zr=B('<div class="pinpad-overlay svelte-gp7a2r"><div class="pinpad-container svelte-gp7a2r"><!></div></div>'),Gr=B('<p class="status-message svelte-gp7a2r"> </p>'),Yr=B("<div></div>"),Jr=B("<div></div>"),Xr=B('<div class="selection-area svelte-gp7a2r"><!> <!> <div class="grid-container svelte-gp7a2r"><!></div></div>');function Kr(e,t){ot(t,!1);const[r,a]=F7(),s=()=>Qe(Oe,"$orderStore",r),i=()=>Qe(b1,"$currentTime",r),l=()=>Qe(We,"$pinpadStore",r);let c=D([]),u=D([]),o=D("Initializing..."),v=!1,g=D("categories"),p=null,d=D("6-6-6"),E=D(!1),C=D(null),b=D(0),k=D(0),_=D(0),$=D(0),N=D([]),q=Le(t,"handleSmartAction",8,()=>{});const I=160,W=160,se=6,Q=6,te=6,z=6,ie=6;function R(f,h,M,T,y,S,qe=!1){const Xe=f,he=h-2*S;function f7(Ae){const $e=(Xe-(Ae+1)*y)/Ae;if($e<M)return null;let ut=$e*T*.75+y,_e=Math.floor(he/ut),e7=(he-(_e-1)*y)/(1+(_e-1)*.75);const De=$e*(T*.7);let xe;e7>=De&&_e>0?xe=_e:xe=Math.max(1,_e-1);let Ne;return qe?xe>0?Ne=(he-(xe-1)*y)/(1+(xe-1)*.75):Ne=Math.max(he,De):xe>0?Ne=(he-(xe-1)*y)/xe:Ne=Math.max(he,De),{columns:Ae,rows:xe,buttonWidth:$e,buttonHeight:Ne,layout:"symmetrical"}}function W7(Ae){const $e=(Xe-(Ae+1)*y)/(Ae+.5);if($e<M)return null;let ut=$e*T*.75+y,_e=Math.floor(he/ut),e7=(he-(_e-1)*y)/(1+(_e-1)*.75);const De=$e*(T*.7);let xe;e7>=De&&_e>0?xe=_e:xe=Math.max(1,_e-1);let Ne;return qe?xe>0?Ne=(he-(xe-1)*y)/(1+(xe-1)*.75):Ne=Math.max(he,De):xe>0?Ne=(he-(xe-1)*y)/xe:Ne=Math.max(he,De),{columns:Ae,rows:xe,buttonWidth:$e,buttonHeight:Ne,layout:"asymmetrical"}}let je=null,H7=Math.floor((Xe-y)/M);for(let Ae=1;Ae<=H7;Ae++){const $e=f7(Ae),O=W7(Ae),ut=[$e,O].filter(_e=>_e!==null);for(const _e of ut)je?(_e.columns>je.columns||_e.columns===je.columns&&(_e.layout==="asymmetrical"&&je.layout==="symmetrical"||_e.buttonWidth>je.buttonWidth))&&(je=_e):je=_e}return je||{columns:1,rows:1,buttonWidth:Math.max(M,Xe-2*y),buttonHeight:Math.max(M,he),layout:"symmetrical"}}let X=D(I),F=D(7.5625*16),re=D(1),U=D(1),J=D(W),G=D(W),V=D(1),K=D(1),ee=D("symmetrical");function ce(){const f=[];if(n(d)==="6-6-6")for(let h=0;h<n(U);h++)ue(f,h,n(ee));else n(d)==="4-4-4"&&de(f,n(ee));if(f.length>0){let h=f.filter(M=>M.type==="full"||M.type==="rect-grid");h.length>0&&(h.sort((M,T)=>T.rowIndex-M.rowIndex||M.columnIndex-T.columnIndex),h[0].isPinpadTrigger=!0)}if(f.length>0){const M=Math.max(...f.map(y=>y.rowIndex))-1;let T=f.filter(y=>(y.type==="full"||y.type==="rect-grid")&&y.rowIndex===M);T.length>0&&(T.sort((y,S)=>y.columnIndex-S.columnIndex),T[0].isTableButton=!0)}return f}function ue(f,h,M){const T=h%2===1;if(M==="symmetrical"){const y=T?n(re):n(re)-1;if(y<0)return;if(T)for(let S=0;S<y;S++)f.push({id:`full-${h}-${S}`,type:"full",content:null,rowIndex:h,columnIndex:S});else{f.push({id:`half-start-${h}`,type:"left-half",content:null,rowIndex:h,columnIndex:0});for(let S=0;S<y;S++)f.push({id:`full-${h}-${S}`,type:"full",content:null,rowIndex:h,columnIndex:S+1});f.push({id:`half-end-${h}`,type:"right-half",content:null,rowIndex:h,columnIndex:y+1})}}else{const y=n(re);if(T){for(let S=0;S<y;S++)f.push({id:`full-${h}-${S}`,type:"full",content:null,rowIndex:h,columnIndex:S});f.push({id:`half-end-${h}`,type:"right-half",content:null,rowIndex:h,columnIndex:y})}else{f.push({id:`half-start-${h}`,type:"left-half",content:null,rowIndex:h,columnIndex:0});for(let S=0;S<y;S++)f.push({id:`full-${h}-${S}`,type:"full",content:null,rowIndex:h,columnIndex:S+1})}}}function de(f,h){for(let M=0;M<n(K);M++)we(f,M,h)}function we(f,h,M){const T=h%2===1;if(M==="symmetrical"){const y=T?n(V):n(V)-1;if(y<0)return;if(T)for(let S=0;S<y;S++)f.push({id:`rect-full-${h}-${S}`,type:"rect-grid",content:null,rowIndex:h,columnIndex:S,width:n(J),height:n(G)});else{f.push({id:`rect-half-start-${h}`,type:"left-half-rect",content:null,rowIndex:h,columnIndex:0,width:n(J)/2-te/2,height:n(G)});for(let S=0;S<y;S++)f.push({id:`rect-full-${h}-${S}`,type:"rect-grid",content:null,rowIndex:h,columnIndex:S+1,width:n(J),height:n(G)});f.push({id:`rect-half-end-${h}`,type:"right-half-rect",content:null,rowIndex:h,columnIndex:y+1,width:n(J)/2-te/2,height:n(G)})}}else{const y=n(V);if(T){for(let S=0;S<y;S++)f.push({id:`rect-full-${h}-${S}`,type:"rect-grid",content:null,rowIndex:h,columnIndex:S,width:n(J),height:n(G)});f.push({id:`rect-half-end-${h}`,type:"right-half-rect",content:null,rowIndex:h,columnIndex:y,width:n(J)/2-te/2,height:n(G)})}else{f.push({id:`rect-half-start-${h}`,type:"left-half-rect",content:null,rowIndex:h,columnIndex:0,width:n(J)/2-te/2,height:n(G)});for(let S=0;S<y;S++)f.push({id:`rect-full-${h}-${S}`,type:"rect-grid",content:null,rowIndex:h,columnIndex:S+1,width:n(J),height:n(G)})}}}function le(){n(N).forEach(f=>{f.content=null})}function ye(){n(N).length!==0&&(le(),Se(n(N)),n(g)==="categories"?Ze(n(N),n(c)):ge(n(N),n(u)),w(N,[...n(N)]))}function Se(f){const h=f.filter(T=>T.type==="left-half"||T.type==="left-half-rect");if(h.length>0){h.sort((y,S)=>S.rowIndex-y.rowIndex);const T=h[0];T.content={isSmartNavigation:!0}}const M=f.filter(T=>T.type==="right-half"||T.type==="right-half-rect");if(M.length>0){M.sort((y,S)=>y.rowIndex-S.rowIndex);const T=M[0];if(T.content={isLayoutToggle:!0,icon:"",showShape:n(d)==="6-6-6"?"rect":"hex"},M.length>1){M.sort((S,qe)=>qe.rowIndex-S.rowIndex);const y=M[0];y.content={isTimeButton:!0}}}}function Ze(f,h){Ee(f);let M=0;for(const T of f){if(M>=h.length)break;(T.type==="full"||T.type==="rect-grid")&&!T.isPinpadTrigger&&!T.content&&(T.content=h[M],M++)}}function ge(f,h){const M=f.filter(y=>(y.type==="left-half"||y.type==="left-half-rect")&&!y.content);if(M.length>0){M.sort((S,qe)=>S.rowIndex-qe.rowIndex);const y=M[0];y.content={isBackButton:!0,icon:"←"}}Ee(f);let T=0;for(const y of f){if(T>=h.length)break;(y.type==="full"||y.type==="rect-grid")&&!y.isPinpadTrigger&&!y.content&&(y.content=h[T],T++)}}function Ee(f){const h=Math.max(...f.map(y=>y.rowIndex)),M=f.filter(y=>y.rowIndex===h&&(y.type==="full"||y.type==="rect-grid")&&!y.isPinpadTrigger&&!y.isTableButton);L("DEBUG",`Found ${M.length} bottom row buttons for payment assignment`),M.sort((y,S)=>S.columnIndex-y.columnIndex);const T=[{type:"bar",label:"Bar",color:"#5a7a5a",icon:'<?xml version="1.0" encoding="utf-8" ?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="96" viewBox="0 0 128 96"><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M860.049 42.5451C863.174 42.624 864.396 43.2157 867.135 44.649C899.278 61.4706 930.616 79.3737 962.241 97.0455L1140.06 196.515L1235.83 249.392C1244.2 254.024 1279.17 272.625 1283.9 277.585C1282.44 280.57 1281.27 282.302 1279.45 285.063C1282.58 292.135 1296.05 322.182 1296.51 327.834C1294.74 332.438 1289.84 335.037 1285.72 337.876C1288.3 345.822 1294.55 360.167 1297.81 368.289C1294.05 372.162 1290.61 374.451 1286.23 377.548C1289.54 386.869 1295.46 400.922 1297.78 409.853C1294.56 413.357 1291.61 414.85 1287.52 417.236C1290.52 427.181 1296.24 437.43 1299.15 447.79C1295.53 451.696 1291.99 453.323 1287.39 455.808C1291.55 465.344 1300.2 486.142 1302.74 495.595C1300.26 497.252 1297.58 498.606 1294.99 500.086C1280.56 508.342 1266.12 516.628 1251.85 525.174L1139.03 593.407L784.062 803.333L568.699 931.564C544.412 945.804 520.233 960.147 496.127 974.691C493.279 976.409 490.339 977.962 487.355 979.433C482.346 976.418 477.284 972.61 472.507 969.184C419.655 931.492 366.284 906.945 308.516 877.93C246.547 846.805 187.533 807.107 130.367 768.004C109.446 753.693 89.6758 737.836 69.6562 722.326C67.6909 720.788 66.5047 719.127 66.4393 716.66C68.933 711.97 79.7318 705.333 84.8102 701.638C80.3582 697.5 66.4077 688.821 65.9928 683.839C67.4568 679.274 79.8188 670.984 84.5252 667.263C62.3668 647.79 57.3531 652.544 84.8764 632.52C60.2719 609.41 57.851 620.244 83.8486 596.689C61.5012 576.407 56.2767 581.092 83.5163 559.902C78.7788 555.355 65.7634 547.292 65.5365 541.128C66.4298 538.823 67.721 538.009 69.9547 536.831C110.119 515.654 150.867 494.877 189.936 471.676L442.039 318.543C574.814 237.077 708.69 156.693 833.113 62.8355C842.043 56.0988 850.441 48.3397 860.049 42.5451Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M437.354 362.52C440.468 362.724 453.229 370.573 456.645 372.576C456.248 411.173 470.048 437.93 496.698 465.191C535.474 505.015 587.787 528.835 640.955 542.632C663.451 548.469 686.655 552.888 709.82 554.963C713.453 555.288 721.068 555.741 724.211 556.957C735.116 561.174 750.44 569.728 760.561 574.97C753.804 579.772 739.809 587.316 732.134 591.946L669.659 629.727L529.807 716.115C509.311 728.821 489.035 740.492 468.5 753.531L460.175 748.22C380.381 698.429 296.612 654.368 217.514 603.59C191.072 586.615 156.144 564.027 132.384 544.176C159.606 527.584 189.257 513.528 216.644 496.662C246.139 478.497 276.856 461.286 306.409 443.286L437.354 362.52Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M432.603 379.871C433.645 380.086 437.093 381.244 437.144 382.487C438.791 442.392 490.02 487.403 537.337 514.789C596.404 549.752 662.499 562.556 729.71 570.091C731.937 570.341 734.147 574.935 729.179 577.671C716.909 584.428 704.675 592.104 692.723 599.379L602.992 654.239C577.877 669.443 547.915 688.824 522.338 702.561C519.263 701.134 515.523 698.889 512.498 697.182C481.961 681.362 440.641 679.265 407.87 688.789C406.567 688.288 404.507 687.394 403.295 686.669C374.494 669.436 345.564 652.574 316.516 635.765L261.137 604.086C252.052 598.921 242.711 593.921 233.779 588.521C231.308 587.027 230.306 586.046 229.463 583.32C230.908 581.26 234.513 577.718 236.32 576.107C255.415 559.082 260.677 539.318 247.048 516.743C244.349 512.273 239.119 505.351 238.102 500.399C241.624 496.163 261.502 486.587 267.152 483.284C323.079 450.594 379.073 416.312 432.603 379.871Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M427.755 394.648C428.427 395.385 433.323 416.495 434.744 420.094C459.781 483.513 526.563 524.948 587.468 548.864C624.138 563.264 672.331 572.498 712.153 577.016C695.782 588.268 673.468 600.738 656.112 611.431L521.867 692.386C519.632 690.964 516.728 689.382 514.39 688.03C486.171 672.098 440.303 671.74 409.318 679.477C354.86 647.196 298.177 613.73 242.73 583.323C268.545 554.332 271.645 536.924 249.926 503.745C274.308 489.403 298.626 475.702 322.89 460.996C358.43 439.456 392.74 416.944 427.755 394.648Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M420.928 529.557C440.364 527.204 462.006 533.996 478.231 544.432C505.824 562.18 515.928 600.707 474.606 607.832C454.695 610.962 434.049 605.236 417.133 593.494C402.754 583.514 382.618 560.384 395.572 541.734C401.072 533.816 411.655 530.807 420.928 529.557Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M422.396 537.572C439.811 536.323 454.996 540.394 470.629 549.858C482.293 556.92 499.445 575.18 490.349 590.521C487.135 595.941 479.225 598.025 473.215 599.15C451.773 602.522 429.989 593.983 414.337 579.352C406.313 571.858 395.794 557.307 403.413 546.275C407.534 540.308 415.724 538.43 422.396 537.572Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M431.608 541.652C444.113 540.518 460.635 548.703 470.113 556.27C487.388 570.061 493.855 594.7 463.692 595.478C440.635 595.539 414.37 580.096 409.069 556.385C412.156 543.961 420.397 542.15 431.608 541.652Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M430.903 549.572C448.069 550.417 469.541 559.747 476.043 577.382C478.355 583.655 470.553 586.503 465.732 587.494C449.066 587.673 424.543 577.138 418.728 559.024C416.76 552.894 426.122 550.234 430.903 549.572Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M863.232 87.2873C868.567 89.6681 886.32 100.38 892.447 103.717L979.224 151.934L1114.89 227.794L1173.27 260.337C1186.49 267.632 1202.25 275.698 1214.72 283.907C1209 289.833 1199.51 297.299 1193.06 302.539C1171.88 319.752 1149.38 334.848 1126.86 350.222C1068.59 390.001 1009.09 427.414 948.803 464.056C943.611 467.224 938.593 470.196 933.305 473.202C924.501 468.621 915.791 464.102 907.108 459.282C906.201 449.664 904.907 440.279 901.844 431.01C875.061 354.618 788.264 311.126 715.725 289.766C690.219 282.255 665.241 278.117 639.239 274.945C635.813 274.527 610.758 260.836 605.986 258.388C614.148 253.38 622.098 248.137 630.126 242.907C691.186 203.12 754.381 166.396 813.541 123.77C830.223 111.75 846.473 99.1284 863.232 87.2873Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M815.169 143.23C820.01 143.65 833.17 150.547 839.172 152.369C874.725 163.16 897.612 162.491 932.11 152.143C942.359 156.464 964.128 169.229 974.479 174.967L1058.24 221.96L1094.81 242.726C1100.33 245.843 1112.84 252.545 1117.13 256.195C1117.34 260.585 1105.49 276.929 1103.32 286.649C1100.24 300.451 1104.41 311.66 1113.37 322.128C1115.87 325.056 1119.01 327.92 1121.01 331.197C1121.62 332.201 1122.93 334.597 1122.42 335.804C1120.61 340.094 970.753 433.542 952.784 444.112C947.193 447.448 933.215 456.755 927.395 457.038C922.096 455.492 923.587 449.148 922.925 444.574C919.499 423.328 908.247 398.45 894.432 382.153C832.481 309.078 733.877 272.032 640.4 263.141C638.522 262.962 635.673 262.607 634.669 260.853C633.123 258.153 634.219 255.542 636.744 253.994C643.855 249.564 651.066 245.211 658.22 240.808L696.671 216.774C735.109 192.526 776.172 165.946 815.169 143.23Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M816.101 153.267C820.938 154.455 832.096 159.798 838.708 161.788C869.421 171.029 899.584 172.361 930.24 162.219C947.297 169.696 972.382 184.596 989.162 193.882C1028.19 215.481 1066.9 238.259 1106.14 259.543C1088.09 286.126 1087.98 309.936 1111.16 333.263C1060.03 366.162 1007.49 400.291 955.796 431.906L931.939 446.143C927.207 420.913 921.429 401.986 905.252 381.29C844.52 303.595 746.727 268.758 652.988 254.98C663.751 247.371 676.39 240.21 687.734 233.247C730.593 206.94 772.911 178.996 816.101 153.267Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M888.123 236.906C907.271 234.803 932.137 243.119 947.369 254.887C974.635 275.953 981.482 312.727 938.595 317.809C918.294 320.264 896.142 310.455 880.077 298.717C851.933 278.153 845.179 241.729 888.123 236.906Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M890.004 245.573C937.28 239.841 993.388 301.88 937.771 309.217C918.326 309.468 904.878 305.036 888.766 294.023C866.822 279.023 851.144 250.275 890.004 245.573Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M892.847 249.501C931.261 247.398 982.077 294.562 935.937 303.868C890.274 305.892 849.093 257.039 892.847 249.501Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M891.042 258.136C909.921 256.863 934.938 267.401 943.991 285.485C946.571 290.639 940.383 294.001 936.192 295.279C918.197 296.181 894.229 286.385 884.441 270.486C880.864 264.675 886.294 260.418 891.042 258.136Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M569.917 250.985C600.071 265.336 632.286 283.54 662.879 298.923C711.717 323.48 766.327 347.323 809.98 379.871C826.232 391.988 846.064 414.687 853.035 433.848C854.302 437.33 855.088 441.13 857.422 443.983C863.801 446.774 872.064 451.533 878.336 455.01C902.214 468.252 927.647 480.196 951.405 493.459C908.132 517.066 865.758 544.694 822.8 569.044C814.508 573.744 806.127 579.048 798.227 584.4C766.533 568.817 735.905 551.346 704.091 536.024C702.171 535.099 698.985 533.607 697.306 532.481C673.358 521.726 648.07 509.769 624.496 498.22C583.418 478.096 532.775 457.445 510.864 414.593C506.97 406.225 502.743 397.162 503.534 387.804C476.645 373.018 448.813 356.935 421.883 342.599L528.917 276.068C542.309 267.916 556.415 258.63 569.917 250.985Z"/><defs><linearGradient id="gradient_0" gradientUnits="userSpaceOnUse" x1="544.67743" y1="255.5813" x2="738.42389" y2="525.00348"><stop offset="0" stop-color="#F8EB90"/><stop offset="1" stop-color="#FFFFD2"/></linearGradient></defs><path fill="url(#gradient_0)" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M569.917 250.985C600.071 265.336 632.286 283.54 662.879 298.923C711.717 323.48 766.327 347.323 809.98 379.871C826.232 391.988 846.064 414.687 853.035 433.848C854.302 437.33 855.088 441.13 857.422 443.983C853.575 445.243 804.676 422.223 797.335 418.71C769.583 376.013 706.172 385.172 664.305 394.727C652.184 388.193 632.718 378.227 621.721 370.91C630.035 366.065 667.548 352.436 670.579 347.151C671.017 346.386 671.238 346.007 670.935 345.145C669.188 340.164 647.653 329.692 642.244 327.013C624.624 331.338 598.901 338.381 584.078 349.222C575.251 344.602 566.965 339.622 557.836 335.447C552.574 339.326 538.585 346.698 539.551 353.13C542.187 357.322 555.973 363.928 561.107 366.698C549.376 382.992 546.393 398.072 555.473 416.545C553.228 416.274 550.212 415.039 547.914 414.849C535.217 413.802 523.166 411.107 510.864 414.593C506.97 406.225 502.743 397.162 503.534 387.804C476.645 373.018 448.813 356.935 421.883 342.599L528.917 276.068C542.309 267.916 556.415 258.63 569.917 250.985Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.335 418.71C804.676 422.223 853.575 445.243 857.422 443.983C863.801 446.774 872.064 451.533 878.336 455.01C902.214 468.252 927.647 480.196 951.405 493.459C908.132 517.066 865.758 544.694 822.8 569.044C814.508 573.744 806.127 579.048 798.227 584.4C766.533 568.817 735.905 551.346 704.091 536.024C702.171 535.099 698.985 533.607 697.306 532.481L697.873 532.018C700.327 526.361 701.065 520.78 700.101 514.628C703.495 512.657 713.957 509.832 718.378 508.193C735.602 501.808 750.436 496.233 765.745 486.115C774.383 490.846 783.039 495.918 791.597 500.82C819.215 485.313 812.782 481.683 789.782 468.353C793.85 464.364 796.947 461.728 799.157 456.387C804.272 444.025 801.874 430.64 797.335 418.71Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M510.864 414.593C523.166 411.107 535.217 413.802 547.914 414.849C550.212 415.039 553.228 416.274 555.473 416.545C580.97 454.453 635.267 440.421 671.257 430.401C687.885 439.97 712.836 453.889 728.216 464.596C705.104 476.524 685.157 483.456 658.974 481.774C653.66 481.432 648.928 480.59 647.24 485.37C648.235 489.553 662.656 496.087 666.635 498.036C673.281 501.292 693.907 515.244 700.101 514.628C701.065 520.78 700.327 526.361 697.873 532.018L697.306 532.481C673.358 521.726 648.07 509.769 624.496 498.22C583.418 478.096 532.775 457.445 510.864 414.593Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M640.185 336.046C642.83 335.508 653.255 343.434 656.336 345.46C645.76 350.701 612.377 362.37 605.617 369.018C605.368 369.963 605.028 370.443 605.403 371.393C606.759 374.84 655.877 401.06 662.736 404.42C676.979 400.771 688.966 397.925 703.859 396.505C730.277 393.985 759.902 396.222 781.406 413.504C787.341 418.274 788.821 423.006 790.903 427.556C799.425 446.176 777.023 464.451 777.514 469.565C780.218 473.679 794.229 481.385 799.309 484.577C796.768 487.06 794.581 488.468 791.672 490.483C782.636 486.244 773.886 479.946 765.086 476.211C760.594 478.571 754.374 482.673 750.07 484.872C741.459 489.272 702.648 507.972 695.517 503.867C688.167 499.397 681.096 495.283 673.599 491.064C693.635 488.397 712.157 482.521 730.623 474.385C734.361 472.738 745.292 469.144 744.592 464.398C739.087 458.429 682.333 426.511 671.894 420.729C641.877 428.698 610.614 440.045 580.05 426.53C566.213 420.412 559.105 408.835 559.609 393.973C560.034 381.437 568.245 374.725 573.232 364.366C570.541 360.45 558.019 354.151 552.879 350.762C554.682 349.216 556.807 347.722 558.729 346.299C566.619 349.644 575.646 355.465 583.82 359.403C606.463 345.801 614.955 343.283 640.185 336.046Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M722.101 411.605C737.772 411.348 758.748 414.519 764.527 431.839C767.317 440.202 765.15 455.657 755.317 458.84C752.4 459.784 743.566 453.412 740.728 451.599C726.943 442.578 704.381 431.65 690.422 421.497C689.301 420.681 689.132 419.302 689.298 417.982C693.653 413.301 715.287 412.062 722.101 411.605Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M710.515 421.038C727.155 419.458 767.026 420.763 753.881 448.036C753.467 448.009 753.052 447.982 752.638 447.955C747.23 443.878 711.218 424.966 709.383 421.771L710.515 421.038Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M591.602 375.857C597.22 376.002 638.908 399.26 645.236 404.957C646.316 405.929 645.976 406.073 645.946 407.497C643.067 410.968 637.218 411.321 632.606 412.183C619.004 414.782 595.21 419.653 585.345 407.827C576.495 397.218 582.398 383.484 591.602 375.857Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M593.621 385.939C597.317 387.28 623.862 401.502 627.032 403.761C626.254 405.165 624.38 405.444 622.523 406.143C608.472 409.297 578.03 407.704 593.621 385.939Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M958.26 500.59C958.309 500.625 958.368 500.65 958.407 500.696C962.834 505.853 957.008 663.434 960.509 688.464C950.668 693.822 939.461 701.527 929.263 707.407L808.704 777.941C808.442 778.033 807.839 777.914 807.504 777.878C806.214 772.473 807.171 739.691 807.157 732.541L806.953 588.7L905.241 531.681C923.167 521.165 940.027 510.784 958.26 500.59Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M412.322 347.92C416.816 350.025 423.761 354.119 428.31 356.61C422.313 361.097 411.451 367.39 404.908 371.418L360.596 398.714C302.781 434.608 244.266 469.314 185.486 503.604C172.48 511.191 159.621 518.247 146.399 525.395C137.481 530.216 125.773 535.714 117.759 541.377C116.952 547.239 127.828 553.362 132.282 556.711C210.683 615.672 296.46 661.42 380.672 711.072L437.39 745.031C447.127 750.877 458.251 757.912 468.159 763.233C475.752 760.476 490.892 750.508 498.41 745.867L544.998 717.293C619.75 671.852 694.616 623.998 770.082 580.078C775.451 582.717 781.943 586.585 787.255 589.575L761.206 604.833C722.229 627.901 683.446 652.216 644.859 675.97L559.799 727.884C528.141 747.473 492.014 771.026 459.842 789.273C447.919 780.414 435.816 772.359 423.345 764.354C324.641 700.998 216.927 652.431 123.988 580.014C109.003 568.338 91.9762 556.103 78.3558 542.954C90.0386 536.171 103.574 529.531 115.655 523.282C177.727 491.173 236.95 454.856 296.607 418.571L412.322 347.92Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M861.831 52.5308C864.57 53.4612 866.642 54.7966 869.163 56.1524C895.556 70.3495 921.356 85.7755 947.671 100.079L1230.57 257.315C1243.69 264.517 1256.59 272.149 1269.71 279.217C1175.6 356.192 1064.94 422.527 962.281 487.861C955.8 484.64 949.585 481.389 943.198 477.985C957.053 471.093 969.852 462.305 983.014 454.139C1002.69 441.928 1022.29 429.641 1041.75 417.075C1091.21 385.124 1141.82 353.315 1188.62 317.456C1196.79 310.96 1204.7 304.43 1212.88 297.641C1214.61 296.561 1229.81 283.569 1227.54 281.605C1214.93 270.713 1176.54 251.32 1163.95 244.234L1006.02 155.809L910.312 102.616C896.349 94.9347 875.909 82.8363 861.902 76.4106C848.931 86.0075 836.038 95.7336 823.008 105.255C772.056 142.483 717.854 176.355 664.456 209.85L618.677 238.899C611.474 243.382 602.599 249.25 595.166 252.922L579.38 244.973C586.064 239.989 596.866 233.954 604.242 229.447C694.042 174.577 778.363 116.742 861.831 52.5308Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1270.8 289.893C1272.96 292.825 1283.87 319.801 1286.62 325.591C1278.17 331.226 1270.07 337.936 1261.81 343.912C1187.3 397.796 1108.04 445.022 1030.56 494.428C1013.74 505.152 996.892 515.727 979.854 526.156L969.058 532.999L969.14 493.949C1015.46 466.402 1064.52 434.21 1109.86 404.585C1162.52 370.179 1222.97 330.276 1270.8 289.893Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M91.6453 638.482C103.953 646.879 115.372 656.633 127.826 665.029C166.574 690.715 206.543 715.44 246.478 739.271C296.476 769.107 349.931 793.164 399.496 823.956C424.004 839.181 444.342 855.915 466.744 873.715C468.112 879.395 469.588 884.456 471.626 889.956C472.58 892.531 473.366 894.901 471.384 897.008C468.81 897.241 466.72 895.563 464.34 894.178C445.231 882.901 427.416 872.021 407.602 861.914C357.452 836.333 306.383 813.11 258.107 783.947C236.427 770.85 215.516 755.041 195.065 740.053C155.645 711.164 115.611 680.647 77.7347 649.719C80.709 646.876 88.1036 641.359 91.6453 638.482Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M796.964 594.669C797.903 595.624 797.706 628.46 797.791 632.87C758.677 654.126 713.854 682.432 675.547 705.861L564.05 773.108L502.681 810.522C496.455 814.362 480.297 825.458 474.689 827.69C473.102 826.709 473.456 826.243 472.719 823.847C470.606 814.956 467.488 805.868 464.666 797.139L626.169 698.15C682.708 663.228 739.441 627.95 796.964 594.669Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.044 747.362C798.209 749.044 797.339 779.545 797.277 784.393C774.596 798.797 748.409 813.318 725.074 827.162L584.117 911.18L516.906 951.046C512.152 953.879 495.739 964.606 491.921 965.861C490.855 964.386 490.673 962.102 490.285 960.157C487.96 952.624 485.662 942.556 483.859 934.791C510.263 920.072 538.617 901.898 564.811 886.326L797.044 747.362Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1278.83 460.526C1280.31 461.728 1289.87 487.117 1291.76 491.296C1273.36 503.483 1250.57 515.042 1231.25 527.038C1147.83 578.839 1061.93 627.476 978.162 678.58L969.392 683.776L969.349 650.115C1071.39 586.385 1178.34 525.899 1278.83 460.526Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M90.6621 566.012C94.2425 567.739 115.922 585.196 120.908 588.956C144.752 606.934 168.463 623.812 193.672 639.907C279.732 694.853 371.914 737.515 455.181 796.902C457.255 805.975 461.882 818.644 464.919 827.744L456.302 821.837C437.304 809.215 412.935 793.127 392.689 783.515C308.973 743.771 230.258 701.308 157.306 643.444C130.213 621.955 102.537 601.283 76.0478 578.105C81.1274 573.239 85.0668 570.269 90.6621 566.012Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1276.97 343.922C1278.24 345.07 1284.96 362.277 1286.21 365.269C1271.33 378.179 1252.43 390.146 1236.17 401.458C1196.88 428.81 1155.67 452.679 1114.91 477.692C1068.35 506.266 1022.13 535.903 975.567 564.486L969.426 568.438L969.312 543.759C987.076 531.966 1006.12 521.007 1024.2 509.396C1097.52 462.302 1172.29 417.417 1244.13 368.024C1255.34 360.312 1265.94 351.871 1276.97 343.922Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M92.073 707.244C96.827 710.25 108.054 720.177 113.454 724.178C125.763 733.665 138.563 742.511 151.197 751.557C252.777 824.288 368.724 870.892 474.29 936.516C477.145 945.066 480.447 956.714 482.505 965.345L474.413 959.924C417.838 916.715 348.082 889.14 285.76 855.459C260.338 841.719 233.831 825.241 209.48 809.701C165.084 781.369 120.105 750.32 78.5487 717.975C82.4679 714.298 87.7255 710.538 92.073 707.244Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1278.91 423.435C1281.04 425.688 1286.56 441.72 1287.81 445.22C1260.55 459.216 1226.9 483.491 1199.93 499.704L976.397 634.607L969.635 638.524L969.638 614.354C976.112 610.606 983.222 605.713 989.667 601.682L1025.65 579.519L1125.76 517.752C1156.88 498.516 1189.21 480.238 1220.42 461.007C1240.34 448.74 1259.36 436.262 1278.91 423.435Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1277.32 383.851C1279.11 386.469 1285.26 403.4 1286.42 406.966C1247.12 436.113 1197.35 463.842 1155.47 489.164C1094.9 525.782 1034.48 562.538 974.788 600.595L969.632 604.061C969.216 595.803 969.345 587.057 969.34 578.749C985.442 569.917 1003.34 558.104 1019.1 548.208L1096.43 499.974C1157.19 462.339 1219.68 426.187 1277.32 383.851Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.018 644.025C798.153 645.984 797.717 664.168 797.697 667.478L490.319 853.219C488.322 854.41 484.175 857.184 481.944 856.791L481.351 855.179L476.3 837.531C550.982 790.866 627.053 746.037 702.297 700.274C733.407 681.354 765.234 661.666 797.018 644.025Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M796.144 713.972C797.169 714.023 796.659 713.897 797.588 714.689C798.143 720.767 797.863 729.708 797.825 736.041C782.372 746.246 763.437 756.647 747.252 766.178L704.245 792.073C685.865 802.946 667.108 813.601 648.921 824.75L528.827 896.917L497.329 915.851C494.328 917.646 483.987 924.921 481.059 923.763C479.578 917.212 478.162 912.409 476.125 905.996C491.621 896.09 507.834 886.696 523.541 877.046L668.598 789.446L744.023 744.402C761.137 734.168 778.593 723.339 796.144 713.972Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.64 679.311C798.227 682.105 797.864 697.514 797.82 701.35C786.406 709.726 763.622 722.011 750.562 729.739L665.998 780.086C647.975 790.673 485.471 890.39 480.91 890.217L480.102 888.511C478.566 883.691 476.899 878.8 475.309 873.988C489.856 863.025 514.844 848.467 530.871 838.655L631.938 777.669L723.655 722.582C747.011 708.427 773.636 691.801 797.64 679.311Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M91.5519 673.89C94.0596 674.424 103.861 682.738 106.766 684.98L136.633 707.935C143.937 713.582 151.332 719.396 158.81 724.823C198 753.261 236.647 783.513 279.107 806.966C319.861 829.477 362.019 848.87 403.394 870.089C425.017 881.179 445.701 894.414 466.887 906.253L472.42 924.781L462.864 918.825C442.691 905.435 423.47 895.715 402.129 884.387L315.476 838.814C229.524 793.403 152.982 746.575 77.734 684.331C81.0255 681.446 87.818 676.674 91.5519 673.89Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M90.3191 603.13C92.5802 603.689 114.003 621.952 118.142 624.953C179.105 672.678 242.2 718.726 311.635 753.489C335.205 765.524 359.003 776.963 382.617 788.933C395.682 795.556 407.921 803.048 420.577 810.087C436.39 818.88 451.715 831.588 467.306 839.637C468.645 843.999 475.978 862.421 471.238 864.567C468.558 864.134 467.138 862.414 465.033 860.548C460.124 856.525 455.213 852.33 450.246 848.404C394.909 804.664 330.579 776.139 269.507 741.688C222.574 715.213 175.837 685.643 130.831 655.876C112.798 643.948 93.8019 627.776 76.7684 614.098C80.6892 610.639 86.155 606.482 90.3191 603.13Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M661.488 287.464C666.79 287.508 683.545 291.363 689.038 292.6C735.859 303.144 783.592 321.731 823.292 349.114C849.832 367.42 877.716 395.337 890.122 425.594C893.947 434.925 896.091 444.606 897.907 454.483C890.221 451.644 871.851 440.831 863.779 436.415C836.913 363.545 745.72 332.104 682.551 298.555C675.873 295.009 668.394 291.864 662.044 287.825L661.488 287.464Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M466.427 378.102C473.667 381.407 486.484 389.411 494.354 393.581L495.094 396.757C506.731 448.249 551.905 472.032 595.063 494.104C629.895 511.917 665.547 527.413 700.781 544.266C700.963 544.388 701.145 544.509 701.327 544.631C701.124 544.64 700.921 544.649 700.718 544.658C613.241 536.538 468.049 479.249 466.427 378.102Z"/></svg>'},{type:"karte",label:"Karte",color:"#4a5a7a",backgroundStyle:"radial-gradient(ellipse at center, #5A6A8A 0%, #4a5a7a 30%, #3A4A6A 70%, #2A3A5A 100%)",icon:'<?xml version="1.0" encoding="utf-8" ?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="96" viewBox="0 0 128 96"><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M807.317 68.2765C820.431 67.1691 839.986 70.5919 851.168 77.146C871.678 89.1672 892.165 104.257 911.939 117.564L1058.95 217.842L1251.96 348.212L1305.11 383.997C1324.51 397.057 1348.69 408.252 1349.32 435.089C1349.98 463.165 1349.57 484.093 1323.01 500.326C1309.22 508.749 1294.33 516.538 1280.14 524.698L1187.81 577.679L969.575 704.01L725.739 844.823L635.963 896.542C611.948 910.372 588.598 928.335 560.366 930.79C544.542 932.596 524.547 929.561 510.257 922.328C502.731 918.519 493.633 911.938 486.43 907.014L445.147 878.285L326.803 796.265L137.69 665.856L69.5758 619.048C57.5273 610.719 46.0634 602.385 33.5897 593.767C14.6332 580.671 14.3808 550.176 18.0428 529.767C22.2786 506.161 54.0385 492.179 73.8552 480.614L173.588 423.356L475.458 248.277L683.605 128.121L741.28 95.2464C764.06 82.331 780.246 70.693 807.317 68.2765Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M936.748 147.946L937.77 147.891C942.322 150.05 964.642 165.687 970.563 169.585C1003.05 190.969 1035.2 213.353 1067.43 235.177L1243.46 354.268C1268.75 371.322 1294.36 387.897 1319.63 404.988C1334.95 415.342 1346.56 432.664 1336.1 450.727C1327.38 465.775 1313.25 471.674 1298.83 479.793C1289.65 484.984 1280.42 490.214 1271.27 495.454L1162.81 557.59L850.887 737.966L673.514 841.046L618.993 872.441C586.839 891.265 570.187 905.144 529.877 896.119C512.311 890.821 495.623 876.782 480.303 866.465L388.562 803.416L122.035 619.757L656.364 309.793L840.708 203.156C872.355 184.879 904.869 165.554 936.748 147.946Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1161.77 370.492C1173.22 372.496 1241.89 425.373 1258.54 433.493C1260.14 434.273 1266.07 438.028 1265.86 440.095C1258.27 445.232 1250.27 449.417 1242.35 454.007L1193.99 481.788L1046.72 566.731L555.865 847.933C552.887 846.965 529.695 830.843 524.649 827.513L477.564 796.522C472.543 793.186 452.343 781.095 451.831 776.897C453.513 774.571 455.582 773.347 458.048 771.919L1161.77 370.492Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M857.797 551.203C857.939 551.182 858.079 551.139 858.223 551.14C860.445 551.148 946.229 609.038 952.579 614.614C938.402 622.454 924.084 631.09 909.953 639.14L781.27 713.125L687.953 766.285C643.976 791.506 599.469 817.572 555.24 842.242C523.233 820.465 490.085 799.52 458.339 777.647L857.797 551.203Z"/><path fill="#6E8CB8" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1217.5 413.246C1221.19 414.057 1251.71 435.529 1256.75 439.034C1248.63 445.038 1229.83 455.136 1220.38 460.515L1161.49 494.461L957.758 611.648C947.806 603.009 929.553 591.892 917.834 584.298C927.179 578.035 942.554 570.31 952.873 564.431L1025.25 523.034L1217.5 413.246Z"/><path fill="#6E8CB8" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1162.36 376.583C1171.49 381.779 1183.81 390.4 1192.99 396.42C1177.54 404.066 1160 414.692 1144.91 423.314L1070.17 465.987L894.011 566.571C891.947 567.092 867.851 550.574 863.441 548.007C871.109 543.134 879.848 538.019 887.836 533.616C980.128 482.739 1070.04 427.356 1162.36 376.583Z"/><path fill="#BB6970" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1197.45 399.952C1199.96 399.929 1210.55 407.508 1213.43 409.42L913.375 580.978C911.734 580.31 899.704 572.175 897.439 570.669L1063.8 475.702L1149.75 426.579C1164.68 418.132 1182.32 407.534 1197.45 399.952Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M403.688 544.292C422.838 543.09 438.409 553.924 452.99 564.812C463.405 572.589 496.507 595.156 497.777 607.636C498.196 611.753 495.33 615.907 492.773 618.907C480.135 633.735 414.255 669.516 394.805 677.039C386.235 680.355 377.249 682.668 368.077 683.399C358.89 683.961 349.562 683.63 340.79 680.584C327.058 675.816 298.294 652.776 286.017 642.535C279.066 636.737 272.499 630.504 271.734 620.975C271.215 614.514 273.249 609.964 277.439 605.163C288.357 592.656 360.191 555.78 377.803 549.499C386.236 546.492 394.793 544.946 403.688 544.292Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M337.742 576.219C346.772 575.546 361.015 575.433 369.847 576.735C369.951 579.148 369.783 583.536 369.721 586.084C369.455 596.973 381.251 595.7 388.422 598.989C392.034 600.645 396.912 606.146 400.654 608.063C408.915 612.267 419.427 614.316 426.474 620.492C430.098 623.668 428.337 633.161 428.299 637.752C428.274 640.922 428.925 649.356 427.07 651.198C418.968 650.405 406.333 649.673 398.939 647.192C383.865 642.135 378.86 623.473 364.379 619.127C361.236 618.184 356.37 617.851 352.992 617.554C347.327 612.725 341.196 607.678 335.915 602.493C336.827 595.865 336.08 581.149 337.742 576.219Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M330.815 577.94L331.302 578.112C332.32 579.827 331.25 599.789 331.127 603.389C325.927 606.537 282.158 630.279 280.339 630.224C277.885 626.526 277.439 624.288 276.45 620.075C278.573 609.07 285.196 603.516 294.628 598.127C306.617 591.277 318.694 584.555 330.815 577.94Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M487.135 599.276C488.907 599.828 489.531 600.732 490.574 602.232C495.569 609.229 489.776 616.365 484.197 620.758C470.147 631.822 453.914 640.267 438.317 648.879C436.506 649.928 435.772 650.262 433.824 651.043L433.196 650.414C432.769 643.478 433.367 633.859 433.621 626.71C451.117 618.788 469.432 607.797 487.135 599.276Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M354.705 622.14C365.643 623.422 367.96 624.22 374.597 633.284C357.443 642.898 340.347 652.2 322.922 661.308L321.28 661.904C316.675 660.586 308.097 653.455 304.077 650.299C320.701 640.868 338.483 631.732 354.705 622.14Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M424.264 552.584C428.813 553.574 438.947 560.892 443.095 563.738C431.172 571.74 405.87 583.995 392.142 591.766C387.563 594.419 378.19 592.975 375.457 588.009C375.009 587.196 375.215 580.419 375.24 579.074C389.534 572.77 411.124 560.655 424.264 552.584Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M447.098 567.329C451.663 569.704 460.007 576.853 464.147 580.284C446.747 588.653 428.209 599.82 411.084 607.412C403.323 604.314 399.456 602.179 393.781 596.158C411.2 587.447 429.797 576.692 447.098 567.329Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M376.8 637.927C380.222 638.53 388.1 647.192 390.908 650.021C383.596 654.755 373.86 659.224 366.207 663.747C361.749 666.382 346.148 676.185 342.056 676.04C335.014 672.888 331.573 670.65 325.514 666.231C339.278 657.494 362.113 645.85 376.8 637.927Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M332.477 608.607C335.914 608.905 345.535 617.557 348.755 620.181C333.936 627.447 315.504 638.131 300.662 646.066C297.215 645.946 287.745 637.47 284.629 634.881C298.693 626.213 317.752 616.448 332.477 608.607Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M467.892 583.145C471.002 584.059 480.517 592.964 483.348 595.513C467.525 604.337 450.136 612.207 433.654 621.357L433.171 621.219C427.803 615.11 425.31 613.343 417.71 610.041C434.18 600.767 451.322 592.533 467.892 583.145Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M397.303 652.26C403.955 654.29 418.448 655.141 425.874 655.688C411.237 665.107 395.646 672.341 378.85 676.82C368.915 679.041 360.224 678.731 350.175 678.495C365.632 669.319 382.029 661.232 397.303 652.26Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M399.472 549.54C402.797 549.185 414.827 547.907 416.524 550.577C414.558 554.173 382.431 569.829 375.596 574.404C372.386 572.747 371.461 572.38 367.988 571.389C358.755 570.256 352.31 570.798 343.11 571.432C359.595 561.618 380.463 552.638 399.472 549.54Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M564.117 631.48C579.235 631.18 622.042 655.383 593.894 664.699C581.903 664.931 560.467 653.865 555.151 642.198C552.485 636.346 559.567 632.964 564.117 631.48Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M562.219 636.708C572.862 635.691 584.042 642.372 592.282 648.534C596.748 651.873 598.161 655.388 594.46 659.66C586.069 659.902 577.83 655.436 570.83 651.166C565.408 647.857 557.21 643.451 562.219 636.708Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M530.637 648.756C544.383 647.853 561.14 657.341 569.293 668.326C573.625 674.161 569.131 678.826 564.033 681.732C555.621 683.184 548.141 679.416 541.056 675.143C531.811 669.567 514.196 658.012 530.637 648.756Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M531.836 653.41C534.123 653.307 537.731 653.079 539.713 653.966C546.712 657.099 571.427 667.226 562.233 677.358C553.226 677.743 532.034 666.602 529.594 657.634C529.993 654.903 529.795 655.813 531.836 653.41Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M851.436 469.541C868.316 470.058 906.808 496.956 876.056 502.507C859.509 502.018 821.368 475.885 851.436 469.541Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M850.489 474.607C858.276 474.498 880.683 485.282 881.34 493.553C880.168 496.139 880.546 495.329 877.818 497.145C873.036 497.524 870.609 497.149 866.237 494.958C860.231 491.947 847.062 486.209 846.724 478.412C848.015 475.731 847.515 476.631 850.489 474.607Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M756.101 522.058C771.474 520.96 812.567 545.356 786.698 554.743C774.983 555.124 763.571 547.697 754.361 540.774C744.992 533.731 743.537 526.419 756.101 522.058Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M756.136 526.772C765.275 526.513 789.215 537.089 788.899 546.93C788.013 549.137 787.49 549.222 785.346 550.562C777.681 549.855 753.405 538.383 752.749 530.09C753.885 527.717 753.586 528.431 756.136 526.772Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M816.511 488.171C831.922 485.578 872.059 508.75 849.173 520.201C835.941 521.342 817.97 511.387 810.423 500.61C806.416 494.889 811.696 490.556 816.511 488.171Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M817.516 492.68C824.622 492.135 830.726 494.28 836.569 498.179C842.255 501.973 854.332 507.42 849.022 515.215C844.474 515.74 841.537 515.647 837.271 513.788C830.291 510.747 817.544 504.871 815.397 496.96C815.829 494.175 815.599 495.12 817.516 492.68Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M643.316 586.097C656.231 585.523 674.192 594.698 681.348 605.71C685.378 611.911 678.78 616.173 673.737 618.31C662.418 618.958 647.768 610.206 639.395 602.833C631.268 595.675 633.789 589.64 643.316 586.097Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M645.188 590.631C653.318 590.912 677.042 601.163 676.339 610.233C674.719 612.71 675.409 611.865 672.352 613.511C664.154 613.196 640.883 602.429 640.952 593.924C642.003 591.89 642.999 591.711 645.188 590.631Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M594.482 614.119C604.796 613.551 611.909 618.856 620.44 623.94C630.485 629.926 640.941 640.994 624.197 647.302C610.664 646.464 567.48 625.857 594.482 614.119Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M593.591 619.401C602.762 618.293 624.92 629.032 627.083 637.678C626.56 640.5 626.964 639.437 624.699 641.926C615.401 642.594 605.394 636.509 597.874 631.561C592.933 628.309 589.223 624.627 593.591 619.401Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M673.86 568.723C687.236 568.007 704.894 577.332 712.214 588.742C715.811 594.351 710.612 598.771 705.711 600.928C694.765 602.298 684.778 594.921 676.103 589.037C667.381 583.12 660.801 574.355 673.86 568.723Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M674.664 573.363C684.884 572.856 692.409 577.733 700.653 583.216C705.412 586.38 709.809 590.534 705.561 595.886C700.164 596.64 696.573 595.628 691.807 593.09C685.824 589.904 674.477 584.41 672.461 577.63C672.883 574.72 672.43 575.842 674.664 573.363Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M786.467 505.422C799.353 504.564 817.443 514.055 824.613 524.969C828.486 530.865 822.362 535.062 817.536 537.237C809.002 538.097 801.555 534.295 794.453 529.928C784.679 523.918 770.14 514.488 786.467 505.422Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M788.709 510.142C797.074 510.733 820.221 519.824 819.502 529.273C818.253 531.492 817.706 531.636 815.377 532.764C807.647 532.382 784.324 521.643 784.784 513.043C786.112 511.055 786.38 511.078 788.709 510.142Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M705.268 550.776C714.018 549.967 720.774 553.726 728.042 558.223C737.095 563.824 752.572 573.799 736.1 582.101C722.328 585.076 681.774 562.703 705.268 550.776Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M706.208 555.352C713.91 555.225 735.902 565.565 737.506 573.308C736.771 575.96 737.091 575.077 734.868 577.214C731.992 577.373 729.259 577.571 726.528 576.538C719.662 573.94 704.361 567.596 703.351 559.347C703.837 557.11 704.354 556.942 706.208 555.352Z"/><path fill="#616161" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M859.65 93.2116C861.365 93.7071 874.565 103.599 877.163 105.283C895.471 117.151 914.302 131.469 932.805 142.723L380.67 463.194L222.357 555.471C188.649 574.909 154.378 593.689 121.187 613.983C118.568 615.584 118.076 616.239 115.666 615.655C91.4549 598.361 65.7243 581.334 41.1063 564.473C48.0179 560.173 57.108 555.336 64.3181 551.185L122.889 517.534L350.607 386.197C520.316 288.254 688.719 189.186 859.65 93.2116Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M811.797 77.6227C829.227 78.2349 838.757 81.2249 853.447 90.359C817.495 108.799 776.147 133.728 740.498 154.079L512.515 285.725L239.825 443.644C179.643 478.303 117.287 513.093 57.7702 548.585L37.7528 560.049C25.7713 544.982 23.0862 532.467 36.4147 516.968C45.4604 506.45 64.7845 497.124 76.9363 490.154L132.206 458.238L295.315 364.073L606.183 183.909L718.359 119.382C733.43 110.786 748.655 102.216 763.673 93.5524C780.285 83.9691 792.381 78.8536 811.797 77.6227Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1338.12 464.556C1339.76 471.772 1325.9 486.742 1320.33 490.207C1313.14 494.678 1305.33 499.169 1297.98 503.414L1244.09 533.833L1089.55 622.993L593.037 910.515C571.488 922.752 537.442 925.981 514.703 913.64C502.47 907.002 488.5 896.428 476.77 888.336L406.144 839.196L256.809 736.167L123.547 644.238L70.6681 607.943C57.5625 598.927 37.4812 587.934 29.8121 574.277C28.0185 569.49 27.4902 567.155 26.9498 562.118C37.9678 572.775 50.817 581.317 63.4023 590.028L100.327 615.677L258.961 724.868L387.861 813.891C410.299 829.422 432.17 845.428 455.089 860.374C474.08 872.597 492.496 887.594 511.807 899.104C532.199 911.259 569.819 910.356 590.482 899.583C605.135 891.944 619.663 882.735 633.971 874.515L722.916 823.578L1035.32 641.778L1239.98 523.884L1296.55 491.535C1315.12 480.815 1321.41 479.201 1338.12 464.556Z"/></svg>'},{type:"zwischenrechnung",label:"Zwischenrechnung",color:"#7a6a4a",textColor:"#F5E5C8",backgroundStyle:"radial-gradient(ellipse at center, #8A7A5A 0%, #7a6a4a 30%, #6A5A3A 70%, #5A4A2A 100%)"}];for(let y=0;y<Math.min(T.length,M.length);y++){const S=T[y],qe=M[y];qe.content={isPaymentButton:!0,paymentType:S.type,label:S.label,color:S.color,icon:S.icon,textColor:S.textColor,backgroundStyle:S.backgroundStyle},L("DEBUG",`Assigned payment button: ${S.label} at row ${qe.rowIndex}, col ${qe.columnIndex}`)}}let Te,ae=D();gt(()=>(L("INFO","SelectionArea mounted, setting up resize observer"),n(ae)&&(Te=new ResizeObserver(f=>{for(let h of f)w(_,h.contentRect.width),w($,h.contentRect.height)}),Te.observe(n(ae)),setTimeout(()=>{w(_,n(ae).clientWidth),w($,n(ae).clientHeight)},100)),()=>Te?.disconnect())),Ce.subscribe(f=>{v=f.isConnected,f.lastMessage?.command==="getCategoriesResponse"&&(f.lastMessage.status==="success"&&Array.isArray(f.lastMessage.payload)?(w(c,f.lastMessage.payload),w(o,n(c).length>0?"":"No categories found.")):w(o,"Error: Could not load categories from backend.")),f.lastMessage?.command==="getItemsByCategoryResponse"&&(f.lastMessage.status==="success"&&Array.isArray(f.lastMessage.payload)?(w(u,f.lastMessage.payload),w(g,"products"),w(o,n(u).length>0?"":"No products found in this category.")):w(o,"Error: Could not load products from backend."))}),gt(()=>{setTimeout(()=>{v?(w(o,"Loading categories..."),Ce.send({command:"getCategories"})):w(o,"Error: Not connected to backend.")},500)}),gt(()=>{const f=()=>{L("INFO","Auto-collapse completed, returning to categories"),w(g,"categories"),p=null,Ft.set("order")};return window.addEventListener("autoCollapseComplete",f),()=>{window.removeEventListener("autoCollapseComplete",f)}});let j=D([]);function ve(f){const h=f.detail.data;h&&h.id&&(p=h,w(o,"Loading products..."),Ce.send({command:"getItemsByCategory",payload:{categoryId:h.id}}))}function Ie(f){const h=f.detail.data;h&&h.id&&Oe.addItem(h.id,1,1)}function be(){w(g,"categories"),p=null,w(u,[]),w(o,"")}function Re(){w(d,n(d)==="6-6-6"?"4-4-4":"6-6-6")}function Je(){L("INFO","Time settings accessed"),l7.resetTimeOffset(),L("INFO","Time offset reset - using client time")}function Nt(f){const h=f.toLocaleTimeString("de-DE",{hour:"2-digit",minute:"2-digit"}),M=f.getDate().toString().padStart(2,"0"),T=(f.getMonth()+1).toString().padStart(2,"0"),y=f.getFullYear();return`${h}
${M}.${T}
${y}`}function Pt(f){L("INFO",`Payment method selected: ${f}`);let h;if(Oe.subscribe(M=>h=M)(),h.total<=0){L("WARNING","Cannot process payment: Order total is zero");return}if(f==="bar"||f==="karte"){const M={type:f==="bar"?"Bar":"Karte",amount:h.total};Oe.finishOrder(M),L("SUCCESS",`Payment processed: ${M.type} - ${M.amount.toFixed(2)}€`)}else f==="zwischenrechnung"&&(L("INFO","Interim receipt requested"),console.log("Interim receipt requested"))}async function Xt(){let f;Oe.subscribe(S=>f=S)();const h=f.items&&f.items.length>0,M=f.metadata&&f.metadata.table,T=f.status==="active",y=f.transactionId;if(T&&y&&h&&M){L("INFO",`Collapsing order with table ${M} without time update`);try{await Oe.parkCurrentOrder(M,1,!1),L("SUCCESS","Order collapsed successfully"),await Vt.refresh()}catch(S){throw L("ERROR",`Failed to collapse order: ${S.message}`),S}}else{if(T&&y&&h&&!M)throw L("WARNING","Order has items but no table - forcing table assignment"),new Error("FORCE_TABLE_ASSIGNMENT");y&&(L("INFO","Resetting empty order"),Oe.resetOrder())}}async function Kt(){Ft.set("order");let f;Oe.subscribe(S=>f=S)();const h=f.items&&f.items.length>0,M=f.metadata&&f.metadata.table,T=f.status==="active",y=f.transactionId;if(T&&y&&(h||M)){L("INFO","Collapsing current order and returning to start position");try{await Xt(),Oe.resetOrder(),w(g,"categories"),p=null,L("INFO","Returned to start position")}catch(S){if(S.message==="FORCE_TABLE_ASSIGNMENT"){L("INFO","Forcing table assignment for order with items (will auto-collapse)"),We.activateTableEntryWithAutoCollapse();return}else L("ERROR",`Failed to handle table click: ${S.message}`)}}else if(y)L("INFO","Activating pinpad for table number entry"),We.activateTableEntry();else{L("INFO","No active order - initializing new order for table entry");try{await Oe.initializeOrder(1,{}),L("INFO","Order initialized, activating pinpad for table number entry"),We.activateTableEntry()}catch(S){L("ERROR",`Failed to initialize order: ${S.message}`)}}}function N7(f){const{data:h,mouseX:M,mouseY:T}=f.detail;h&&!h.isBackButton&&(w(C,h),w(b,M),w(k,T),w(E,!0))}function P7(){w(E,!1),w(C,null)}function Z7(f){const{item:h}=f.detail;console.log("Edit item:",h);const M=h.category_names?"Category":"Product";L("INFO",`Edit requested for: ${h.id} - ${M}`)}function tt(f){const h=n(d)==="6-6-6"?"hex":"rect",M=f.type.includes("half"),T=f.type.includes("left")?"left":f.type.includes("right")?"right":"";let y,S;return n(d)==="6-6-6"?(y=M?n(X)/2-se/2:n(X),S=n(F)):(y=f.width||n(J),S=f.height||n(G)),{shape:h,side:T,width:y,height:S}}function D7(f){if(f.isPinpadTrigger)return{isPinpadTrigger:!0};if(f.isTableButton)return{icon:'<?xml version="1.0" encoding="utf-8" ?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="96" viewBox="0 0 128 96"><path fill="#312E2B" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M657.249 45.5326C661.809 44.9168 674.909 47.1424 679.872 47.8092L732.69 55.4381C800.705 65.1855 868.927 73.974 936.595 85.9405C1052.09 106.364 1167.06 129.61 1280.79 158.382C1293.38 161.569 1309.98 164.895 1321.49 170.599C1324.6 172.14 1323.03 212.195 1322.96 216.805C1317.16 219.727 1306.52 222.701 1300.01 224.708L1257.97 237.319L1130.3 276.416L899.334 347.199L803.807 376.657C787.511 381.667 770.045 387.867 753.759 391.908L753.502 400.777C773.208 410.24 765.714 426.758 751.438 436.493C754.672 454.83 760.404 477.222 766.292 495.043C778.312 531.425 788.232 547.55 775.428 586.479C793.644 611.173 788.351 632.852 778.653 658.961C787.232 666.586 790.02 670.215 791.077 681.45C816.727 679.381 846.371 680.664 871.117 688.624C896.232 697.171 921.595 711.801 943.908 726.18C987.586 754.326 1018.17 778.997 1072.77 768.261C1079.02 771.023 1095.27 781.56 1100.36 786.271C1100.42 792.121 1102.19 817.606 1098.13 820.178C1090.59 824.961 1075.24 828.435 1066.09 830.014C1026.48 836.849 984.219 830.616 947.21 815.373C903.854 796.249 890.566 784.975 842.244 781.116C874.83 831.877 906.209 889.241 960.618 920.012C970.24 925.454 980.474 930.082 990.275 935.297C991.235 941.66 992.421 969.949 989.016 974.859C982.424 979.02 920.144 989.34 910.409 990.417C891.68 982.492 859.397 965.44 844.008 953.414C822.81 936.804 809.128 922.88 792.581 901.291C771.86 874.258 756.399 849.065 728.483 828.685C709.892 832.319 688.586 833.255 669.549 831.452C646.125 829.234 618.374 825.196 598.494 811.371C593.269 807.737 589.282 802.843 585.24 798.042C553.887 805.691 525.245 819.378 497.608 835.771C474.784 849.308 452.002 863.701 427.523 874.18C398.834 886.461 367.611 893.439 336.763 897.587C325.42 899.112 313.771 899.376 302.513 900.919C297.191 897.145 279.362 881.142 273.369 875.976C272.239 864.432 272.049 850.606 272.646 839.051C272.945 833.27 288.443 833.361 293.319 832.373C329.846 824.972 357.628 805.289 386.466 782.888C410.121 764.513 433.906 747.931 459.941 733.052C460.128 730.331 460.85 706.908 463.218 706.014C467.046 704.569 477.641 704.496 482.581 704.061C512.165 701.457 535.516 683.606 561.036 670.641C571.404 665.423 582.207 666.893 593.593 660.02C579.677 635.479 573.135 610.932 594.816 588.27C582.616 563.27 588.1 529.223 598.913 504.722C611.77 475.589 613.546 463.845 614.222 432.534C598.269 422.101 596.589 405.793 614.366 396.46C614.916 389.423 615.173 383.967 615.187 376.913C601.03 371.777 575.26 366.981 559.569 363.156L455.12 337.098L149.251 259.442L78.6884 241.856C70.8122 239.899 47.2998 234.635 41.3126 231.387C41.1346 216.556 41.2485 201.692 41.3079 186.857C52.606 182.381 74.5142 177.545 86.9381 174.175L188.572 147.241C344.279 107.555 499.183 74.6893 657.249 45.5326Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M420.229 124.166C424.763 124.387 448.286 130.465 454.175 131.795L556.452 155.95L957.321 252.581C949.04 255.627 938.05 258.529 929.375 261.058L886.853 273.626L854.033 283.277C845.312 285.83 836.648 289.668 827.72 287.599C816.05 284.384 803.289 281.652 791.4 278.686L695.251 254.949L425.023 187.912L321.344 162.553C310.289 159.791 298.633 157.77 287.78 154.656C291.796 153.246 300.364 151.569 304.85 150.555L337.183 143.199C362.773 137.305 394.744 128.962 420.229 124.166Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M265.311 160.166C271.96 159.128 330.655 174.855 340.205 177.175L614.2 245.123L754.377 279.532L791.082 288.479C798.826 290.304 808.42 292.26 815.884 294.598C798.173 298.797 777.535 306.024 759.539 310.801C751.938 312.819 725.345 320.341 719.054 323.255L708.348 320.687L340.92 233.906C278.558 219.097 214.755 204.895 152.712 189.304C178.812 181.738 205.403 175.185 231.74 168.482C242.918 165.638 254.014 162.53 265.311 160.166Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M559.563 94.147C564.323 93.0834 660.812 115.531 674.236 118.506L1032.02 198.855C1052.72 203.552 1074.42 207.6 1094.86 212.553C1086.19 214.072 1075.33 217.458 1066.87 220.121C1037.65 229.314 1007.69 237.298 978.575 246.67C975.46 247.822 967.588 244.868 963.832 244.007C919.197 233.783 874.677 223.11 830.203 212.212L620.593 161.84L486.932 129.495C472.482 126.135 458.327 122.4 443.789 119.363C482.366 111.803 520.981 102.191 559.563 94.147Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M663.851 71.5367C665.361 71.3618 679.991 73.6973 682.831 74.1066L737.389 81.9234C870.666 100.961 1003 122.298 1134.39 151.955C1166.22 159.141 1198.22 165.349 1230.05 172.81L1135.38 200.78C1109.48 208.026 1113.44 210.356 1086.54 204.395L1054.04 197.176L929.57 168.933L577.539 90.2681C586.12 88.0049 598.001 85.7609 606.831 83.8393L663.851 71.5367Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M52.4513 194.985L436.98 287.312L600.468 326.447C638.618 335.571 678.926 345.626 717.219 353.656C717.103 366.111 717.561 379.259 717.876 391.766C706.809 388.47 691.336 385.371 679.717 382.553L609.544 365.177L396.545 311.727L183.856 257.687C140.964 246.728 95.9731 233.944 52.5878 225.461L52.4513 194.985Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1310.72 180.02L1312.21 180.469C1313.6 183.901 1312.7 204.674 1312.59 209.673L972.38 314.284L809.82 364.294C783.127 372.669 754.979 381.051 728.641 390.189L727.572 390.487L726.69 389.944C725.828 385.97 726.31 359.443 726.343 353.678C780.964 338.681 833.379 322.736 887.61 306.745L1135.88 232.703L1254.47 197.077C1273.01 191.51 1292.19 185.212 1310.72 180.02Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M620.114 722.96C621.643 722.623 620.891 722.602 622.444 723.12C622.867 725.606 622.77 728.103 622.741 730.616C622.549 747.337 622.764 764.048 622.959 780.768C574.546 786.74 534.079 802.224 492.118 826.937C470.122 839.891 454.766 850.731 430.89 861.276C391.069 878.863 355.524 885.432 312.749 890.15C311.688 890.079 311.162 889.92 310.105 889.696C308.486 886.724 309.07 870.789 309.026 866.203C324.133 863.927 337.868 861.939 352.201 856.167C380.696 844.692 405.167 824.332 429.815 806.373C466.157 779.894 502.481 755.26 544.832 739.046C570.655 729.159 593.12 726.328 620.114 722.96Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M755.632 719.582C759.625 719.872 768.079 724.301 771.796 726.34C819.586 752.549 842.732 804.289 872.235 847.142C890.079 873.06 910.745 897.364 935.687 916.069C947.219 924.716 960.753 930.875 973.602 936.757C959.182 938.338 932.528 943.624 918.021 946.509L912.07 947.576C834.474 912.334 812.96 855.779 766.927 789.626C750.539 766.074 724.326 742.584 700.665 726.352C718.289 725.658 738.197 722.499 755.632 719.582Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M821.485 710.951C852.221 708.347 884.956 714.537 913.942 725.293C972.374 746.977 1021.52 805.461 1087.66 797.013C1087.77 802.462 1087.59 807.786 1087.45 813.229C1076.76 817.434 1064.81 820.253 1053.41 821.475C1042.39 823.549 1026.8 822.585 1015.73 821.763C980.762 819.165 951.792 807.816 920.817 791.886C894.666 778.436 866.437 771.502 836.685 771.166C825.545 759.691 814.844 746.427 802.755 735.623C797.587 731.005 791.851 727.062 786.278 722.925L789.31 713.634C798.939 711.881 811.533 711.47 821.485 710.951Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M95.0261 182.731C116.32 188.557 143.894 194.249 165.886 199.507L336.593 239.863C463.935 270.042 589.06 301.282 717.095 328.91C716.776 335.187 716.731 340.867 716.734 347.147L693.992 341.791L236.058 231.946L124.738 205.043C108.661 201.222 80.3098 195.452 65.5004 190.665C75.2858 188.495 85.3474 185.473 95.0261 182.731Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1242.09 176.022C1246.73 175.263 1270.04 181.6 1275.54 183.259C1254.38 190.189 1230.21 196.641 1208.62 203.142L1064.07 246.452L750.487 339.919L725.918 347.386C725.795 341.295 725.242 334.403 724.878 328.261C746.736 321.377 770.936 314.995 793.127 308.485L933.459 267.212L1242.09 176.022Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M695.761 732.899C698.958 734.483 712.611 744.804 715.668 747.23C729.167 757.941 744.621 772.529 755.221 786.186C787.884 828.27 809.688 877.966 848.808 915.216C866.973 932.513 884.689 942.08 906.427 953.803L906.598 978.022C900.462 975.576 890.438 969.456 884.299 966.347C846.518 947.216 820.24 921.727 795.688 887.524C783.05 869.918 767.037 848.738 751.184 833.937C734.45 818.313 717.172 808.794 696.339 799.489C696.318 777.179 696.242 755.209 695.761 732.899Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M721.095 444.994C721.74 445.951 722.488 454.614 722.652 456.155C726.459 492.003 735.831 527.197 736.827 563.335C737.231 577.963 735.255 592.56 733.562 607.055C722.914 610.092 708.005 611.509 697.122 612.546L680.464 612.967C680.5 557.644 681.317 502.652 682.432 447.351C696.986 447.433 706.687 446.824 721.095 444.994Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M588.97 703.586C592.193 702.961 593.261 703.162 596.019 704.836C602.414 708.718 608.959 712.255 615.652 715.589C587.132 719.987 564.868 722.86 537.899 733.847C487.857 754.234 447.162 785.188 403.854 816.655C374.626 837.891 351.185 853.806 314.422 857.743L307.052 858.553C302.182 853.699 294.161 848.511 288.373 843.907C329.143 834.493 345.626 825.568 379.086 800.995C405.009 781.956 434.016 759.932 461.361 743.611C498.258 721.589 546.592 708.861 588.97 703.586Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M656.567 55.6023L657.409 56.0937C658.357 58.7556 658.624 62.7661 658.951 65.7059C648.279 68.4296 634.069 70.7138 622.84 73.1663L548.785 89.7786L421.401 116.86C365.061 129.132 307.868 142.451 251.912 156.318L189.659 172.309C176.034 175.866 154.816 180.662 142.643 186.858C135.351 185.074 127.925 183.428 120.601 181.743L109.615 178.989C138.051 170.406 167.393 163.831 196.055 156.061C269.859 136.053 343.689 119.588 418.358 103.459L572.15 71.6785C600.203 66.1278 628.345 60.0544 656.567 55.6023Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M641.252 442.601C651.714 444.866 665.945 446.234 676.615 446.787C674.816 501.128 674.068 558.424 674.324 612.834C668.364 612.485 664.376 612.049 658.469 611.15C649.594 610.454 637.87 606.792 629.491 604.056C614.818 567.2 630.007 517.652 637.813 480.931C640.232 469.556 641.017 454.215 641.252 442.601Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M779.771 683.251L780.189 683.675C782.095 688.866 779.558 711.114 778.917 718.025C773.337 715.781 763.388 710.909 757.152 709.766C754.879 709.349 750.562 710.192 748.108 710.627C728.234 714.151 708.361 716.06 688.207 717.135C687.095 728.218 687.256 743.7 687.278 754.971L687.426 804.224C674.376 804.095 628.242 800.449 618.913 792.637L619.421 791.906C623.154 791.049 628.538 791.264 632.492 791.258L632.413 764.037L632.055 714.12C616.543 703.199 603.123 701.101 591.994 688.284L592.961 686.224L591.622 687.785L592.656 686.119C598.33 688.363 604.868 693.598 610.447 695.701C653.524 711.939 743.875 715.997 779.771 683.251Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M664.251 55.7541C678.423 56.86 695.972 59.9207 710.308 62.0055L786.469 72.8571C956.427 96.3677 1125.44 129.586 1291.79 171.529C1294.06 172.1 1299.71 173.229 1301.11 174.721L1299.5 175.508C1294.67 177.05 1289.66 178.259 1284.75 179.518C1239.2 166.941 1193.07 157.955 1146.99 147.874C1077.42 132.657 1006.92 117.785 936.707 105.858C880.631 96.3334 823.473 88.363 767.235 79.4483C733.541 74.1072 699.31 70.5312 665.388 65.1981L664.251 55.7541Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M741.293 440.823L742.032 441.489C743.797 453.106 745.759 463.677 748.938 475.167C759.976 515.06 783.511 554.87 759.018 595.046C757.125 598.151 753.202 599.511 749.999 600.849L739.398 605.053C747.375 570.283 741.722 537.06 736.002 502.546C732.709 482.673 729.837 463.831 727.609 443.81C732.443 442.945 736.55 441.983 741.293 440.823Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M740.782 627.401L742.483 627.433C743.589 628.955 743.434 634.97 743.514 637.103C744.102 652.789 740.595 665.161 732.34 678.439C714.667 682.864 699.742 683.749 681.667 683.92C681.008 683.885 680.289 683.622 679.619 683.435C677.903 679.541 678.966 642.68 679.046 635.734C701.614 635.101 719.044 633.384 740.782 627.401Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M616.749 624.704C634.624 630.932 653.104 633.848 671.905 635.496C671.874 642.688 673.212 680.551 671.078 683.5C652.601 680.996 644.274 679.981 626.619 673.917C624.77 670.297 622.135 666.382 620.119 662.516C613.933 650.652 614.449 637.569 616.749 624.704Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M623.958 437.215C627.785 438.603 631.93 439.914 635.811 441.219C634.967 495.424 605.538 545.766 622.048 601.195C620.497 600.763 618.368 599.559 616.879 598.795C590.594 580.935 596.423 537.379 607.437 512.274C620.805 481.804 623.782 469.698 623.958 437.215Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M771.255 666.621C774.318 668.48 775.015 669.241 777.545 671.722C758.119 712.073 629.311 705.553 597.329 681.511C590.028 673.756 594.335 671.366 601.551 667.225C617.676 686.827 679.013 692.009 703.192 689.554C723.014 687.542 757.739 682.458 771.255 666.621Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M768.644 596.376C770.632 596.972 771.032 598.024 771.772 599.683C771.556 603.803 768.539 607.312 765.202 609.468C726.979 634.172 636.377 636.608 600.992 607.958C598.683 604.721 596.916 601.74 599.454 597.963C603.874 596.325 605.189 600.445 608.42 602.563C643.104 625.302 739.083 626.124 768.644 596.376Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M976.922 944.167C978.571 943.955 978.602 943.792 980.078 944.455C982.004 947.947 981.067 962.735 981.002 967.555L919.234 978.759C917.852 979.071 917.917 979.012 916.51 978.736C914.399 974.99 915.197 959.904 915.249 954.984C933.902 952.829 958.336 947.841 976.922 944.167Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M614.17 407.026C615.452 407.807 619.189 411.832 620.817 412.992C623.518 414.918 628.808 417.37 632.018 418.571C665.01 430.299 704.507 429.811 737.862 419.912C747.567 417.032 748.197 412.212 752.712 410.336L754.126 411.177C755.726 414.35 755.053 417.322 754.164 420.527C732.62 444.282 651.417 440.182 624.027 426.407C615.395 422.066 609.366 416.936 614.17 407.026Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M774.412 609.189C781.051 615.742 773.659 642.773 770.556 650.932C764.339 667.277 758.257 668.853 743.354 675.297C742.389 674.107 744.728 668.486 745.413 666.631C750.508 652.823 750.557 639.171 748.648 624.721C758.268 621.135 767.664 617.17 774.412 609.189Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M641.258 383.544C653.465 386.229 664.999 388.938 677.105 392.038C677.243 401.961 677.199 411.457 677.055 421.365C665.818 420.931 651.853 417.985 640.94 415.364L641.258 383.544Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M596.678 795.928C608.545 796.203 625.876 804.348 638.695 806.761C655.572 809.937 672.5 811.399 689.66 811.139C696.737 811.032 711.109 816.536 715.42 821.118C687.452 824.996 615.436 820.02 596.678 795.928Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M580.188 675.508L581.46 675.494C583.776 678.273 579.785 685.082 585.455 694.253C577.261 696.485 561.604 698.03 551.751 700.191C523.131 706.471 501.262 713.801 474.825 725.257C473.354 726.018 472.844 726.487 471.227 726.194C469.77 723.937 470.91 718.362 471.224 715.376C492.853 715.385 519.52 707.057 538.103 696.08C552.368 687.655 563.264 678.408 580.188 675.508Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M683.607 393.549L719.562 400.983C719.59 405.052 720.527 413.769 719.288 417.675C719.028 418.492 718.198 418.433 717.016 418.771C704.695 420.821 696.355 421.265 683.742 421.799C683.389 412.768 683.05 402.52 683.607 393.549Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M801.597 690.948C829.327 688.55 865.078 696.285 890.612 707.203C886.863 706.625 882.157 705.512 878.369 704.73C845.464 699.93 823.801 700.398 790.465 703.779C790.687 699.892 790.686 695.733 790.748 691.815L801.597 690.948Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M593.423 609.771C594.502 610.503 597.482 613.409 599.077 614.602C603.189 617.681 606.383 619.284 610.893 621.565L610.763 622.069C606.498 639.309 608.892 654.749 617.826 669.801C615.262 669.181 613.141 667.974 610.769 666.802C599.251 648.997 586.795 632.152 593.423 609.771Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1070.51 779.664C1075.74 780.699 1085.68 785.983 1090.57 788.493C1077.83 790.82 1069.98 790.063 1057.59 787.916C1050.56 786.337 1041.41 784.569 1035.15 781.26C1046.42 781.142 1059.43 781.246 1070.51 779.664Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M282.9 852.231C286.022 853.329 296.217 861.873 299.229 864.317L299.261 884.393C295.513 882.17 286.596 873.322 283.246 870.092C283.284 864.045 283.102 858.268 282.9 852.231Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M624.936 379.015L635.404 381.942C634.891 390.625 635.121 405.552 634.018 413.256C630.293 411.756 626.404 409.313 623.34 406.708C625.179 395.523 625.184 390.478 624.936 379.015Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M743.298 395.403C743.563 395.671 744.025 396.335 744.073 396.699C746.048 411.811 739.731 412.997 727.737 416.59L726.893 416.151C726.136 412.914 726.461 404.344 726.489 400.614C732.119 399.14 737.756 397.208 743.298 395.403Z"/></svg>',onClick:Kt,active:!0,disabled:!1,color:"#3E2723",textColor:"#F5DEB3",backgroundStyle:"radial-gradient(ellipse at center, #4A2F2A 0%, #3E2723 30%, #2E1A16 70%, #1A0F0D 100%)"};if(!f.content)return{disabled:!0};if(f.content.isBackButton)return{icon:"←",onClick:be,active:!0};if(f.content.isLayoutToggle)return{icon:f.content.icon||"",onClick:Re,active:!0,showShape:f.content.showShape};if(f.content.isSmartNavigation)return{icon:"",onClick:q(),active:!0,showShape:"double-arrow-down"};if(f.content.isTimeButton)return{label:Nt(i()),onClick:Je,active:!0,color:"#2c2c2e",textColor:"#666",customStyle:"font-size: 12px; font-weight: 600; line-height: 1.2; white-space: pre-line; text-align: center;"};if(f.content.isPaymentButton){const y=s().total>0&&s().status==="active";return{label:f.content.label,onClick:y?()=>Pt(f.content.paymentType):void 0,active:y,disabled:!y,paymentButton:!0,color:y?f.content.color:"#666",icon:f.content.icon,textColor:y?f.content.textColor:void 0,backgroundStyle:y?f.content.backgroundStyle:void 0}}const h=n(g)==="categories",M=h?JSON.parse(f.content.category_names).de||"Unnamed":JSON.parse(f.content.display_names).menu.de||"Unnamed Product",T=h?ve:Ie;return{label:M,data:f.content,onClick:T,active:!0}}Me(()=>(n(g),n(_),n($),n(d),n(re),n(U),n(X),n(F),n(ee),n(V),n(K),n(J),n(G)),()=>{if(n(g),n(_)>0&&n($)>0&&n(d)==="6-6-6"){L("DEBUG",`6-6-6 CALC: Container=${n(_)}x${n($)}px`);const f=R(n(_),n($),I,3/4,Q,z,!0);w(re,f.columns),w(U,f.rows),w(X,f.buttonWidth),w(F,f.buttonHeight),w(ee,f.layout),L("INFO",`6-6-6 RESULT (${n(ee)}): ${n(re)}×${n(U)} (${n(X).toFixed(1)}×${n(F).toFixed(1)}px)`)}else if(n(_)>0&&n($)>0&&n(d)==="4-4-4"){L("DEBUG",`4-4-4 CALC: Container=${n(_)}x${n($)}px`);const f=R(n(_),n($),W,3/4,te,ie,!1);w(V,f.columns),w(K,f.rows),w(J,f.buttonWidth),w(G,f.buttonHeight),w(ee,f.layout),L("INFO",`4-4-4 RESULT: ${n(V)}×${n(K)} (${n(J).toFixed(1)}×${n(G).toFixed(1)}px)`)}else w(re,1),w(X,I),w(V,1),w(J,W),w(G,W)}),Me(()=>(n(_),n($),n(d),n(re),n(U),n(ee),n(X),n(F),n(V),n(K)),()=>{n(_)>0&&n($)>0&&(n(d)==="6-6-6"&&n(re)>0&&n(U)>0?(L("DEBUG",`REBUILDING GRID (${n(ee)}): ${n(re)}×${n(U)} (${n(X).toFixed(1)}×${n(F).toFixed(1)})`),w(N,ce())):n(d)==="4-4-4"&&n(V)>0&&n(K)>0&&w(N,ce()))}),Me(()=>(n(N),s()),()=>{n(N).length>0&&s()&&w(N,[...n(N)])}),Me(()=>(n(N),n(g),n(c),n(u)),()=>{n(N).length>0&&(n(g)==="categories"&&n(c).length>=0||n(g)==="products"&&n(u).length>=0)&&ye()}),Me(()=>(n(N),n(d),n(K),n(U)),()=>{const f=[],h=new Map;n(N).forEach(T=>{h.has(T.rowIndex)||h.set(T.rowIndex,[]),h.get(T.rowIndex).push(T)});const M=n(d)==="4-4-4"?n(K):n(U);for(let T=0;T<M;T++)h.has(T)&&f.push(h.get(T).sort((y,S)=>y.columnIndex-S.columnIndex));w(j,f)}),Jt(),Lt();var rt=Xr(),Ge=m(rt);{var u7=f=>{var h=zr(),M=m(h),T=m(M);Rr(T,{onClose:()=>We.deactivate()}),P(f,h)};Y(Ge,f=>{l(),x(()=>l().isActive)&&f(u7)})}var Qt=A(Ge,2);jr(Qt,{get item(){return n(C)},get x(){return n(b)},get y(){return n(k)},get visible(){return n(E)},$$events:{close:P7,edit:Z7}});var B7=A(Qt,2),d7=m(B7);{var q7=f=>{var h=Gr(),M=m(h);ne(()=>H(M,n(o))),P(f,h)},U7=f=>{var h=Jr();let M;xt(h,5,()=>n(j),h5,(T,y)=>{var S=Yr();let qe;xt(S,5,()=>n(y),Xe=>`${Xe.id}-${n(d)}-${n(X)||n(J)}-${n(F)||n(G)}`,(Xe,he)=>{var f7=w7(),W7=ht(f7);{var je=Ae=>{var $e=kt(()=>tt(n(he)));At(Ae,St(()=>n($e),{$$events:{click:()=>We.activate("general",null,null)},children:(O,ut)=>{P1(O)},$$slots:{default:!0}}))},H7=Ae=>{var $e=w7();const O=ke(()=>(n(he),x(()=>D7(n(he)))));var ut=ht($e);{var _e=De=>{var xe=kt(()=>tt(n(he)));At(De,St(()=>n(xe),{$$events:{click:()=>We.activate("general",null,null)},children:(Ne,x1)=>{P1(Ne)},$$slots:{default:!0}}))},e7=(De,xe)=>{{var Ne=Zt=>{var V7=kt(()=>tt(n(he)));At(Zt,St(()=>n(V7),{get label(){return Z(n(O)),x(()=>n(O).label)},get active(){return Z(n(O)),x(()=>n(O).active)},get disabled(){return Z(n(O)),x(()=>n(O).disabled)},get color(){return Z(n(O)),x(()=>n(O).color)},get icon(){return Z(n(O)),x(()=>n(O).icon)},get textColor(){return Z(n(O)),x(()=>n(O).textColor)},get backgroundStyle(){return Z(n(O)),x(()=>n(O).backgroundStyle)},$$events:{click(...j7){n(O).onClick?.apply(this,j7)}}}))},x1=(Zt,V7)=>{{var j7=Dt=>{var z7=kt(()=>tt(n(he)));At(Dt,St(()=>n(z7),{get label(){return Z(n(O)),x(()=>n(O).label)},get active(){return Z(n(O)),x(()=>n(O).active)},get disabled(){return Z(n(O)),x(()=>n(O).disabled)},get color(){return Z(n(O)),x(()=>n(O).color)},get textColor(){return Z(n(O)),x(()=>n(O).textColor)},get backgroundStyle(){return Z(n(O)),x(()=>n(O).backgroundStyle)},$$events:{click(...G7){n(O).onClick?.apply(this,G7)}}}))},b5=(Dt,z7)=>{{var G7=Bt=>{var Y7=kt(()=>tt(n(he)));At(Bt,St(()=>n(Y7),{disabled:!0}))},x5=(Bt,Y7)=>{{var w5=qt=>{var J7=kt(()=>tt(n(he)));At(qt,St(()=>n(J7),{get icon(){return Z(n(O)),x(()=>n(O).icon)},get active(){return Z(n(O)),x(()=>n(O).active)},get showShape(){return Z(n(O)),x(()=>n(O).showShape)},get color(){return Z(n(O)),x(()=>n(O).color)},get textColor(){return Z(n(O)),x(()=>n(O).textColor)},get backgroundStyle(){return Z(n(O)),x(()=>n(O).backgroundStyle)},$$events:{click(...X7){n(O).onClick?.apply(this,X7)}}}))},E5=(qt,J7)=>{{var X7=K7=>{var L5=kt(()=>tt(n(he)));At(K7,St(()=>n(L5),{get label(){return Z(n(O)),x(()=>n(O).label)},get data(){return Z(n(O)),x(()=>n(O).data)},get active(){return Z(n(O)),x(()=>n(O).active)},$$events:{click(...k5){n(O).onClick?.apply(this,k5)},secondaryaction:N7}}))};Y(qt,K7=>{Z(n(O)),x(()=>n(O).label)&&K7(X7)},J7)}};Y(Bt,qt=>{Z(n(O)),x(()=>n(O).icon!==void 0||n(O).showShape)?qt(w5):qt(E5,!1)},Y7)}};Y(Dt,Bt=>{Z(n(O)),x(()=>n(O).disabled)?Bt(G7):Bt(x5,!1)},z7)}};Y(Zt,Dt=>{Z(n(O)),x(()=>n(O).label&&!n(O).data)?Dt(j7):Dt(b5,!1)},V7)}};Y(De,Zt=>{Z(n(O)),x(()=>n(O).paymentButton)?Zt(Ne):Zt(x1,!1)},xe)}};Y(ut,De=>{Z(n(O)),x(()=>n(O).isPinpadTrigger)?De(_e):De(e7,!1)})}P(Ae,$e)};Y(W7,Ae=>{n(he),x(()=>n(he).isPinpadTrigger)?Ae(je):Ae(H7,!1)})}P(Xe,f7)}),ne(Xe=>qe=zt(S,1,"button-row svelte-gp7a2r",null,qe,Xe),[()=>({"hex-row":n(d)==="6-6-6","rect-row":n(d)==="4-4-4"})],ke),P(T,S)}),ne(T=>{M=zt(h,1,"grid-container-unified svelte-gp7a2r",null,M,T),$7(h,`
             --optimal-hex-height: ${n(F)??""}px; 
             --hex-vertical-padding: 6px;
             --rect-vertical-padding: 6px;
           `)},[()=>({hex:n(d)==="6-6-6",rect:n(d)==="4-4-4"})],ke),P(f,h)};Y(d7,f=>{n(o)?f(q7):f(U7,!1)})}Rt(rt,f=>w(ae,f),()=>n(ae)),P(e,rt),ct(),a()}function Qr(){const{subscribe:e,set:t,update:r}=et({status:"idle",pendingTransactions:[],companyInfo:null,error:null});Ce.subscribe(i=>{if(i.lastMessage?.command==="pendingTransactions"&&i.lastMessage.payload?.transactions){const l=i.lastMessage.payload.transactions;l.length>0&&(L("INFO",`Received ${l.length} pending transactions for recovery.`),t({status:"awaiting_resolution",pendingTransactions:l,companyInfo:null,error:null}))}if(i.lastMessage?.command==="initialAppData"&&i.lastMessage.payload?.companyInfo){const l=i.lastMessage.payload.companyInfo;L("INFO","Received company information for startup confirmation."),r(c=>({...c,status:"awaiting_confirmation",companyInfo:l,error:null}))}if(i.lastMessage?.command==="resolvePendingTransactionResponse"){const l=i.lastMessage;if(l.status==="success"){const c=l.payload.transactionId,u=l.payload.action;L("INFO",`Transaction ${c} successfully ${u}.`),r(o=>({...o,pendingTransactions:o.pendingTransactions.filter(v=>v.id!==c),status:o.pendingTransactions.length>1?"awaiting_resolution":"idle",error:null}))}else{const c=l.payload?.error||"Unknown error";L("ERROR",`Failed to resolve transaction: ${c}`),r(u=>({...u,status:"awaiting_resolution",error:c}))}}});async function a(){L("INFO","User confirmed company information - proceeding to main application."),r(i=>({...i,status:"idle",companyInfo:null}))}async function s(i,l,c=1){L("INFO",`Attempting to resolve transaction ${i} with action: ${l}`),r(o=>({...o,status:"resolving",error:null}));let u;if(Ce.subscribe(o=>u=o)(),!u||!u.connected){L("ERROR","WebSocket not connected, cannot resolve transaction"),r(o=>({...o,status:"awaiting_resolution",error:"WebSocket connection not available"}));return}try{const o=await Ce.send({command:"resolvePendingTransaction",payload:{transactionId:i,resolution:l,userId:c}});o.error&&(L("ERROR",`WebSocket error: ${o.error}`),r(v=>({...v,status:"awaiting_resolution",error:o.error})))}catch(o){L("ERROR",`Failed to send resolution command: ${o.message}`),r(v=>({...v,status:"awaiting_resolution",error:o.message}))}}return{subscribe:e,resolveTransaction:s,confirmNoPending:a}}const Mt=Qr();var en=B('<tr><td class="svelte-o31k8w"> </td><td class="svelte-o31k8w"> </td><td class="svelte-o31k8w"> </td><td class="actions svelte-o31k8w"><button class="btn-fiscalize svelte-o31k8w" title="Завершить и фискализировать этот чек.">Фискализировать</button> <button class="btn-cancel svelte-o31k8w" title="Сторнировать (отменить) этот чек. Это фискальная операция.">Сторнировать</button> <button class="btn-postpone svelte-o31k8w" title="Отложить решение на потом. Чек будет показан снова при следующем запуске.">Отложить</button></td></tr>'),tn=B('<div class="transactions-section svelte-o31k8w"><h3 class="svelte-o31k8w">⚠️ Незавершенные чеки</h3> <p>Обнаружены незавершенные чеки с предыдущей сессии:</p> <div class="transaction-list"><table class="svelte-o31k8w"><thead><tr><th class="svelte-o31k8w">ID Чека</th><th class="svelte-o31k8w">Сумма</th><th class="svelte-o31k8w">Позиций</th><th class="svelte-o31k8w">Действия</th></tr></thead><tbody></tbody></table></div> <div class="main-actions svelte-o31k8w"><button class="btn-postpone-all svelte-o31k8w" title="Подтвердить время и отложить решение по всем чекам">🕐 Подтвердить время и отложить все чеки</button></div></div>'),rn=B('<div class="company-info-small svelte-o31k8w"><div class="company-name svelte-o31k8w"> </div> <div class="branch-info svelte-o31k8w"> </div></div>'),nn=B('<!> <div class="main-actions svelte-o31k8w"><button class="btn-confirm svelte-o31k8w" title="Подтвердить время и начать работу">🕐 Подтвердить время и начать работу</button></div>',1),an=B('<p class="error svelte-o31k8w"> </p>'),sn=B('<div class="modal-overlay svelte-o31k8w"><div class="modal-content svelte-o31k8w"><div class="time-confirmation-section svelte-o31k8w"><h2 class="svelte-o31k8w">🕐 Подтверждение времени системы</h2> <div class="time-display-large svelte-o31k8w"><div class="current-time svelte-o31k8w"> </div> <div class="current-date svelte-o31k8w"> </div></div></div> <!> <!></div></div>');function ln(e,t){ot(t,!1);const[r,a]=F7(),s=()=>Qe(Mt,"$recoveryStore",r),i=()=>Qe(b1,"$currentTime",r);function l(){Mt.confirmNoPending()}function c(){s().pendingTransactions.forEach(E=>{Mt.resolveTransaction(E.id,"postpone",1)}),setTimeout(()=>{Mt.confirmNoPending()},500)}function u(d){return d.toLocaleTimeString("de-DE",{hour:"2-digit",minute:"2-digit",second:"2-digit"})}function o(d){return d.toLocaleDateString("de-DE",{weekday:"long",day:"2-digit",month:"long",year:"numeric"})}Lt();var v=w7(),g=ht(v);{var p=d=>{var E=sn(),C=m(E),b=m(C),k=A(m(b),2),_=m(k),$=m(_),N=A(_,2),q=m(N),I=A(b,2);{var W=z=>{var ie=tn(),R=A(m(ie),4),X=m(R),F=A(m(X));xt(F,5,()=>s().pendingTransactions,J=>J.id,(J,G)=>{var V=en(),K=m(V),ee=m(K),ce=A(K),ue=m(ce),de=A(ce),we=m(de),le=A(de),ye=m(le),Se=A(ye,2),Ze=A(Se,2);ne(ge=>{H(ee,n(G).id),H(ue,`${ge??""} €`),H(we,n(G).items.length)},[()=>n(G).total_amount.toFixed(2)],ke),oe("click",ye,()=>Mt.resolveTransaction(n(G).id,"fiscalize",1)),oe("click",Se,()=>Mt.resolveTransaction(n(G).id,"cancel",1)),oe("click",Ze,()=>Mt.resolveTransaction(n(G).id,"postpone",1)),P(J,V)});var re=A(R,2),U=m(re);oe("click",U,c),P(z,ie)},se=(z,ie)=>{{var R=X=>{var F=nn(),re=ht(F);{var U=V=>{var K=rn(),ee=m(K),ce=m(ee),ue=A(ee,2),de=m(ue);ne(()=>{H(ce,s().companyInfo.companyName||"ecKasse"),H(de,s().companyInfo.branchName||"")}),P(V,K)};Y(re,V=>{s().companyInfo&&V(U)})}var J=A(re,2),G=m(J);oe("click",G,l),P(X,F)};Y(z,X=>{s().status==="awaiting_confirmation"&&X(R)},ie)}};Y(I,z=>{s().status==="awaiting_resolution"?z(W):z(se,!1)})}var Q=A(I,2);{var te=z=>{var ie=an(),R=m(ie);ne(()=>H(R,`Ошибка: ${s().error??""}`)),P(z,ie)};Y(Q,z=>{s().error&&z(te)})}ne((z,ie)=>{H($,z),H(q,ie)},[()=>u(i()),()=>o(i())],ke),P(d,E)};Y(g,d=>{(s().status==="awaiting_resolution"||s().status==="awaiting_confirmation")&&d(p)})}P(e,v),ct(),a()}var on=B('<main class="pos-grid svelte-b8b2uv"><!> <div class="grid-item-display svelte-b8b2uv"><!></div> <div class="grid-selection-area svelte-b8b2uv"><!></div></main>');function cn(e){let t=D();function r(){n(t)&&(n(t).getIsAtBottom()?n(t).cycleViews():n(t).scrollToBottom())}var a=on(),s=m(a);ln(s,{});var i=A(s,2),l=m(i);Rt(Lr(l,{$$legacy:!0}),o=>w(t,o),()=>n(t));var c=A(i,2),u=m(c);Kr(u,{handleSmartAction:r}),P(e,a)}window.onerror=function(e,t,r,a,s){return L("ERROR","Unhandled Frontend Exception",{type:"window.onerror",message:e,source:t,lineno:r,colno:a,error:s?s.stack:"N/A"}),!0};window.addEventListener("unhandledrejection",e=>{L("ERROR","Unhandled Promise Rejection",{type:"unhandledrejection",reason:e.reason?e.reason.message||e.reason:"No reason provided",stack:e.reason?e.reason.stack:"N/A"})});y6(cn,{target:document.getElementById("app")});


--- File: /packages/client-desktop/src/renderer/dist/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ecKasse - Svelte UI</title>
    <script type="module" crossorigin src="/assets/index-D7hF3OpR.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-Bgt0YSOv.css">
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>

--- File: /packages/client-desktop/src/renderer/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ecKasse - Svelte UI</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

--- File: /packages/client-desktop/src/renderer/package.json ---

{
  "name": "@eckasse/renderer-ui",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^6.0.0",
    "svelte": "^5.35.6",
    "vite": "^7.0.4"
  }
}


--- File: /packages/client-desktop/src/renderer/src/App.svelte ---

<script>
  import ConsoleView from './ConsoleView.svelte';
  import SelectionArea from './SelectionArea.svelte';
  import RecoveryModal from './lib/components/RecoveryModal.svelte';
  import { currentView } from './lib/viewStore.js';
  
  let consoleViewComponent;
  
  // Smart button handler - scroll down or cycle views (universal logic for all panels)
  function handleSmartAction() {
    if (consoleViewComponent) {
      const currentIsAtBottom = consoleViewComponent.getIsAtBottom();
      
      if (currentIsAtBottom) {
        consoleViewComponent.cycleViews();
      } else {
        consoleViewComponent.scrollToBottom();
      }
    }
  }
</script>

<main class="pos-grid">
  <RecoveryModal />
  <div class="grid-item-display">
    <ConsoleView bind:this={consoleViewComponent} />
  </div>
  <div class="grid-selection-area">
    <SelectionArea {handleSmartAction} />
  </div>
</main>

<style>
  .pos-grid {
    display: grid;
    grid-template-columns: 350px 1fr;
    grid-template-rows: 1fr; /* Single row spanning full height */
    height: 100vh;
    width: 100vw;
    gap: 4px;
    padding: 4px;
    box-sizing: border-box;
    background-color: #333;
  }

  .pos-grid > div {
    border-radius: 8px;
    overflow: hidden;
  }

  .grid-item-display {
    grid-row: 1 / 2;
    grid-column: 1 / 2;
  }

  .grid-selection-area {
    grid-row: 1 / 2;
    grid-column: 2 / 3;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/ConsoleView.svelte ---

<script>
  import { afterUpdate, onMount } from 'svelte';
  import { logEntries, addLog } from './lib/logStore.js';
  import { orderStore } from './lib/orderStore.js';
  import { receiptsStore } from './lib/receiptsStore.js';
  import { currentView } from './lib/viewStore.js';
  import { pinpadStore } from './lib/pinpadStore.js';
  import ReceiptFeed from './lib/components/ReceiptFeed.svelte';
  import ParkedOrdersDisplay from './lib/components/ParkedOrdersDisplay.svelte';
  

  let agentScrollElement;
  let ordersScrollElement;
  let receiptsScrollElement;
  let isAtBottom = false; // Track if current panel is scrolled to bottom - start as false until we verify
  let isAutoScrolling = false; // Flag to prevent infinite scroll loops
  let hasInitializedScroll = false; // Flag to track if initial scroll was done

  // Track the last activated view to determine cycle order
  let lastActivatedView = 'order'; // Default to order as the initial view
  
  // Track if we switched to receipts after payment (to auto-expand latest receipt)
  let autoExpandLatestReceipt = false;
  
  // Track previous order status to detect transitions
  let previousOrderStatus = $orderStore.status;
  
  // Track order changes for scroll behavior
  let previousItemsCount = $orderStore.items.length;
  let previousTransactionId = $orderStore.transactionId;
  let previousTable = $orderStore.metadata?.table;
  
  // Auto-switch to receipts after transaction is finished and then reset
  $: {
    // Detect when order status changes from 'finished' to 'idle' (auto-reset happened)
    if (previousOrderStatus === 'finished' && $orderStore.status === 'idle') {
      lastActivatedView = 'receipts'; // Update last activated view for automatic switch
      autoExpandLatestReceipt = true; // Flag to auto-expand latest receipt
      currentView.set('receipts');
      receiptsStore.refresh(); // Refresh receipts to show the latest transaction
      
      // Force scroll to bottom after switching to receipts (like other tabs)
      setTimeout(() => {
        if (receiptsScrollElement) {
          receiptsScrollElement.scrollTop = receiptsScrollElement.scrollHeight;
          checkScrollPosition(); // Update scroll position tracking
        }
      }, 300); // Increased delay to allow receipts to load
    }
    previousOrderStatus = $orderStore.status;
  }

  // Watch for receipts data changes and recalculate scroll position
  $: if ($receiptsStore.receipts && receiptsScrollElement && $currentView === 'receipts') {
    setTimeout(() => {
      checkScrollPosition(); // Recalculate after data changes
    }, 100);
  }

  // Initialize scroll position on mount
  onMount(() => {
    // Wait for DOM to be ready and then initialize scroll
    setTimeout(() => {
      if (!hasInitializedScroll) {
        scrollToBottom();
        checkScrollPosition();
        hasInitializedScroll = true;
      }
    }, 200); // Longer timeout to ensure content is loaded
  });

  // Check and fix scroll position when switching panels (only if not already scrolling)
  afterUpdate(() => {
    if (!isAutoScrolling) {
      let currentScrollElement = null;
      if ($currentView === 'order') currentScrollElement = ordersScrollElement;
      else if ($currentView === 'agent') currentScrollElement = agentScrollElement;
      else if ($currentView === 'receipts') currentScrollElement = receiptsScrollElement;
      
      if (currentScrollElement) {
        setTimeout(() => {
          if (currentScrollElement && !isAutoScrolling) {
            checkScrollPosition(); // First check actual position
            
            // Only scroll if we're actually not at bottom
            if (!isAtBottom) {
                isAutoScrolling = true;
              currentScrollElement.scrollTop = currentScrollElement.scrollHeight;
              
              // Reset flag after scroll completes
              setTimeout(() => {
                isAutoScrolling = false;
                checkScrollPosition(); // Final check
                }, 100);
            } else {
              }
          }
        }, 50);
      }
    }
  });
  
  // Auto-scroll orders to bottom only on meaningful changes
  $: {
    if ($currentView === 'order' && ordersScrollElement) {
      const currentItemsCount = $orderStore.items.length;
      const currentTransactionId = $orderStore.transactionId;
      const currentTable = $orderStore.metadata?.table;
      
      // Scroll only on specific changes:
      // 1. Items added/removed
      // 2. Order switched (transaction ID changed)
      // 3. Table assigned/changed
      const shouldScroll = 
        currentItemsCount !== previousItemsCount ||
        currentTransactionId !== previousTransactionId ||
        currentTable !== previousTable;
      
      if (shouldScroll) {
        setTimeout(() => {
          if (ordersScrollElement) {
            ordersScrollElement.scrollTop = ordersScrollElement.scrollHeight;
          }
        }, 100);
      }
      
      // Update tracking variables
      previousItemsCount = currentItemsCount;
      previousTransactionId = currentTransactionId;
      previousTable = currentTable;
    }
  }

  const agentMessages = [
    { timestamp: '10:30', type: 'user', message: 'Найди товар Кофе' },
    { timestamp: '10:30', type: 'agent', message: 'Поиск товара "Кофе"... Найден товар: Кофе Эспрессо - 2.50€' },
    { timestamp: '10:31', type: 'user', message: 'Создай товар Капучино цена 3.00 категория Напитки' },
    { timestamp: '10:31', type: 'agent', message: 'Создаю товар "Капучино" с ценой 3.00€ в категории "Напитки"... Товар успешно создан.' },
    { timestamp: '10:32', type: 'user', message: 'Покажи все товары в категории Напитки' },
    { timestamp: '10:32', type: 'agent', message: 'Товары в категории "Напитки":\n- Кофе Эспрессо - 2.50€\n- Капучино - 3.00€\n- Американо - 2.00€' },
  ];

  function selectView(viewId) {
    lastActivatedView = viewId; // Update the last activated view
    
    // Reset auto-expand flag when manually switching views
    if (viewId !== 'receipts') {
      autoExpandLatestReceipt = false;
    }
    
    currentView.set(viewId);
  }
  
  // Function to check if current panel is at bottom
  function checkScrollPosition() {
    if (!isAutoScrolling) {
      let currentScrollElement = null;
      if ($currentView === 'order') currentScrollElement = ordersScrollElement;
      else if ($currentView === 'agent') currentScrollElement = agentScrollElement;
      else if ($currentView === 'receipts') currentScrollElement = receiptsScrollElement;
      
      // Debug info removed
      
      if (currentScrollElement) {
        const threshold = 1; // 1px threshold for "at bottom" - more precise
        const scrollTop = currentScrollElement.scrollTop;
        const clientHeight = currentScrollElement.clientHeight;
        const scrollHeight = currentScrollElement.scrollHeight;
        const isNearBottom = scrollTop + clientHeight >= scrollHeight - threshold;
        
        // Debug removed
        
        isAtBottom = isNearBottom;
      } else {
        // No scroll element
        // For panels without scrolling (like receipts), consider them always "at bottom"
        isAtBottom = true;
      }
    }
  }
  
  // Function to scroll current panel to bottom
  function scrollToBottom() {
    let currentScrollElement = null;
    if ($currentView === 'order') currentScrollElement = ordersScrollElement;
    else if ($currentView === 'agent') currentScrollElement = agentScrollElement;
    else if ($currentView === 'receipts') currentScrollElement = receiptsScrollElement;
    
    if (currentScrollElement) {
      currentScrollElement.scrollTop = currentScrollElement.scrollHeight;
      isAtBottom = true;
    }
  }
  
  // Function to cycle through views with dynamic order based on last activated view
  function cycleViews() {
    // Define specific cycle orders based on last activated view
    let cycle;
    
    switch (lastActivatedView) {
      case 'order':
        cycle = ['order', 'receipts', 'agent'];
        break;
      case 'receipts':
        cycle = ['receipts', 'order', 'agent'];  // receipts -> order -> agent -> receipts
        break;
      case 'agent':
        cycle = ['agent', 'order', 'receipts'];
        break;
      default:
        cycle = ['order', 'receipts', 'agent'];
    }
    
    // Find current view in the cycle and get the next one
    const currentIndex = cycle.indexOf($currentView);
    const nextIndex = (currentIndex + 1) % cycle.length;
    const nextViewId = cycle[nextIndex];
    
    // Reset auto-expand flag when cycling away from receipts
    if ($currentView === 'receipts' && nextViewId !== 'receipts') {
      autoExpandLatestReceipt = false;
    }
    
    // DON'T update lastActivatedView when cycling - only update on manual/automatic activation
    currentView.set(nextViewId);
  }
  
  // Getter functions for external access
  function getIsAtBottom() {
    return isAtBottom;
  }
  
  // Export functions for use by SelectionArea
  export { scrollToBottom, cycleViews, getIsAtBottom };
</script>

<div class="console-view">

  <!-- Content area -->
  <div class="content-area">
    {#if $currentView === 'order'}
      <div class="view-content order-view">
        <!-- Combined orders container -->
        <div class="orders-stack" bind:this={ordersScrollElement} on:scroll={() => !isAutoScrolling && checkScrollPosition()}>
          <!-- Parked Orders Section (stacked above active order) -->
          <div class="parked-orders-section">
            <ParkedOrdersDisplay />
          </div>
          
          <!-- Active Order Section (always at bottom) -->
          <div class="active-order-section">
            <div class="order-content">
              <!-- Fixed header at top -->
              <h2><span class="order-number">Order №{$orderStore.transactionId || '...'}</span>{#if $orderStore.metadata?.table || ($pinpadStore.isActive && $pinpadStore.mode === 'table')} <span class="table-number">#{$pinpadStore.isActive && $pinpadStore.mode === 'table' ? $pinpadStore.liveValue : $orderStore.metadata?.table}</span>{/if}</h2>
              {#if $pinpadStore.errorMessage}
                <div class="pinpad-error-message">
                  {$pinpadStore.errorMessage}
                </div>
              {/if}
              <!-- Scrollable items area -->
              <div class="scrollable-items-content">
                <ul class="item-list">
                  {#each $orderStore.items as item (item.id)}
                    <li>
                      <span class="qty">{item.quantity}x</span>
                      <span class="name">{item.display_names ? ( (typeof item.display_names === 'string' ? JSON.parse(item.display_names) : item.display_names).menu.de || 'N/A') : 'Loading...'}</span>
                      <span class="price">{item.total_price.toFixed(2)}€</span>
                    </li>
                  {/each}
                </ul>
              </div>
              <!-- Flexible spacer to push total to bottom when there's extra space -->
              <div class="spacer"></div>
              <!-- Fixed total at bottom -->
              <div class="total">
                <span>Total:</span>
                <span class="price">{$orderStore.total.toFixed(2)}€</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    {:else if $currentView === 'receipts'}
      <div class="view-content receipts-view">
        <div class="receipts-stack" bind:this={receiptsScrollElement} on:scroll={() => !isAutoScrolling && checkScrollPosition()}>
          <ReceiptFeed autoExpandLatest={autoExpandLatestReceipt} />
        </div>
      </div>
    {:else if $currentView === 'agent'}
      <div class="view-content">
        <div class="scroll-content" bind:this={agentScrollElement} on:scroll={() => !isAutoScrolling && checkScrollPosition()}>
          <div class="agent-messages">
            {#each agentMessages as message}
              <div class="agent-message" class:user={message.type === 'user'} class:agent={message.type === 'agent'}>
                <span class="message-timestamp">{message.timestamp}</span>
                <span class="message-type">{message.type === 'user' ? 'User' : 'Agent'}</span>
                <div class="message-content">{message.message}</div>
              </div>
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>
</div>

<style>
  .console-view {
    background-color: #2c2c2e;
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    height: 100%;
    box-sizing: border-box;
  }


  .content-area {
    flex-grow: 1;
    overflow: hidden;
  }

  .view-content {
    padding: 15px;
    height: 100%;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
  }

  .view-content.order-view {
    padding: 8px;
  }

  .view-content.receipts-view {
    padding: 8px;
  }

  .orders-stack {
    height: 100%;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow-y: auto;
    
    /* Hide scrollbar for Chrome, Safari and Opera */
    &::-webkit-scrollbar {
      display: none;
    }
    
    /* Hide scrollbar for IE, Edge and Firefox */
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .receipts-stack {
    height: 100%;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow-y: auto;
    
    /* Hide scrollbar for Chrome, Safari and Opera */
    &::-webkit-scrollbar {
      display: none;
    }
    
    /* Hide scrollbar for IE, Edge and Firefox */
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .parked-orders-section {
    flex-shrink: 0;
    margin-bottom: 8px;
    /* Stack above active order - will grow upward */
    display: flex;
    flex-direction: column-reverse;
  }

  .active-order-section {
    flex: 1 0 300px; /* grow to fill available space, but min 300px */
    display: flex;
    flex-direction: column;
    /* Active order always at bottom */
  }

  .order-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .scrollable-items-content {
    /* Don't grow to fill all space - only grow as needed for content */
    flex: 0 1 auto;
    overflow-y: auto;
    min-height: 0;
    margin-bottom: 16px;
    
    /* Hide scrollbar for Chrome, Safari and Opera */
    &::-webkit-scrollbar {
      display: none;
    }
    
    /* Hide scrollbar for IE, Edge and Firefox */
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .spacer {
    /* This spacer will grow to fill available space, pushing total to bottom */
    flex-grow: 1;
    min-height: 0;
  }

  .active-order-section h2 {
    margin: 0 0 16px 0;
    font-size: 24px;
    color: #e0e0e0;
    flex-shrink: 0;
  }

  .scroll-content {
    flex-grow: 1;
    overflow-y: auto;
    min-height: 0;
    
    /* Hide scrollbar for Chrome, Safari and Opera */
    &::-webkit-scrollbar {
      display: none;
    }
    
    /* Hide scrollbar for IE, Edge and Firefox */
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  /* Order and Receipt styles */
  .item-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .item-list li {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    border-bottom: 1px dashed #666;
    padding-bottom: 8px;
  }

  .qty {
    font-weight: bold;
    margin-right: 10px;
    color: #d32f2f; /* Red color matching receipts */
  }

  .name {
    flex-grow: 1;
  }

  .price {
    font-weight: bold;
    color: #4CAF50; /* Green color for all prices */
  }

  .order-number {
    color: #4a69bd; /* Purple color matching receipts */
  }

  .total {
    border-top: 2px solid #e0e0e0;
    padding-top: 10px;
    font-size: 1.5em;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
  }

  .receipt-footer {
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid #666;
    text-align: center;
    color: #aaa;
  }

  /* Logs styles */
  .log-entries {
    font-family: monospace;
    font-size: 14px;
  }

  .log-entry {
    display: flex;
    margin-bottom: 8px;
    padding: 4px;
    border-radius: 4px;
    background-color: #333;
  }

  .log-entry.error {
    background-color: #4a1a1a;
    border-left: 3px solid #d32f2f;
  }

  .log-entry.debug {
    background-color: #1a1a4a;
    border-left: 3px solid #2196f3;
  }

  .log-timestamp {
    color: #888;
    margin-right: 8px;
    min-width: 128px;
  }

  .log-level {
    font-weight: bold;
    margin-right: 8px;
    min-width: 48px;
  }

  .log-message {
    flex-grow: 1;
  }

  /* Agent styles */
  .agent-messages {
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-height: 100%;
    justify-content: flex-end;
  }

  .agent-message {
    padding: 12px;
    border-radius: 8px;
    max-width: 85%;
  }

  .agent-message.user {
    align-self: flex-end;
    background-color: #4a69bd;
    color: white;
  }

  .agent-message.agent {
    align-self: flex-start;
    background-color: #444;
    color: #e0e0e0;
  }

  .message-timestamp {
    font-size: 12px;
    color: #aaa;
    margin-right: 8px;
  }

  .message-type {
    font-weight: bold;
    font-size: 13px;
    margin-bottom: 4px;
    display: block;
  }

  .message-content {
    white-space: pre-wrap;
    line-height: 1.4;
  }

  h2 {
    margin: 0 0 16px 0;
    font-size: 24px;
    color: #e0e0e0;
  }

  .table-number {
    color: #CD853F;
    font-weight: bold;
  }

  .pinpad-error-message {
    background-color: #4a1a1a;
    border: 1px solid #d32f2f;
    border-radius: 4px;
    padding: 8px 12px;
    margin: 8px 0;
    color: #ffcdd2;
    font-size: 14px;
    font-weight: 500;
    text-align: center;
  }

</style>

--- File: /packages/client-desktop/src/renderer/src/SelectionArea.svelte ---

<script>
  import { onMount } from 'svelte';
  import { wsStore } from './lib/wsStore.js';
  import { addLog } from './lib/logStore.js';
  import { orderStore } from './lib/orderStore.js';
  import { parkedOrdersStore } from './lib/parkedOrdersStore.js';
  import { currentView as consoleView } from './lib/viewStore.js';
  import { currentTime, timeStore } from './lib/timeStore.js';
  import UniversalButton from './lib/components/UniversalButton.svelte';
  import Pinpad from './lib/components/Pinpad.svelte';
  import PinpadPreview from './lib/components/PinpadPreview.svelte';
  import ContextMenu from './lib/components/ContextMenu.svelte';
  import { pinpadStore } from './lib/pinpadStore.js';
  import BetrugerCapIcon from './lib/components/BetrugerCapIcon.svelte';

  let categories = [];
  let products = [];
  let status = 'Initializing...';
  let isConnected = false;
  let currentView = 'categories'; // 'categories' or 'products'
  let selectedCategory = null;
  let layoutType = '6-6-6'; // '6-6-6' or '4-4-4'
  
  // Context menu state
  let contextMenuVisible = false;
  let contextMenuItem = null;
  let contextMenuX = 0;
  let contextMenuY = 0;
  
  let containerWidth = 0;
  let containerHeight = 0;
  let gridCells = []; // Persistent grid structure
  
  // Smart action prop from parent
  export let handleSmartAction = () => {};

  // --- DYNAMIC LAYOUT CONSTANTS (in px units) ---
  const MIN_HEX_WIDTH = 160; // minimum button size for touch
  const MIN_RECT_SIZE = 160; // Minimum size for rectangles
  
  // Separate gap constants for different purposes
  const HEX_BUTTON_GAP = 6; // 6px - gap between hex buttons (was 0.4rem = 6.4px)
  const HEX_EDGE_GAP = 6; // current HEX_GAP value - gap at edges for hex calculations  
  const RECT_GAP = 6; // gap for rectangular layout
  const HEX_VERTICAL_PADDING = 6; // vertical padding (top/bottom) for 6-6-6 mosaic
  const RECT_VERTICAL_PADDING = 6; // vertical padding (top/bottom) for 4-4-4 layout
  
  // --- SHARED GRID CALCULATION FUNCTION ---
  /**
   * Calculates optimal grid layout (columns, rows, button dimensions) for both hexagonal and rectangular button grids.
   * 
   * IMPORTANT: This function ensures that both 6-6-6 (hexagonal) and 4-4-4 (rectangular) layouts have the SAME 
   * number of columns and rows when given identical container dimensions. The `hasOverlap` parameter affects 
   * ONLY the final button height calculation, NOT the grid dimensions.
   * 
   * ALGORITHM LOGIC:
   * 
   * STEP 1 - COLUMN CALCULATION (identical for all layouts):
   * - Calculate maximum possible columns that fit in container width
   * - Each column needs: minButtonSize + buttonGap
   * - If calculated button width >= minButtonSize: use max columns
   * - Otherwise: reduce columns by 1 and recalculate button width
   * - This ensures buttons are never smaller than minimum touch-friendly size
   * 
   * STEP 2 - ROW CALCULATION (uses hexagon logic for consistency):
   * - ALWAYS uses hexagon overlap formula to determine NUMBER of rows, regardless of hasOverlap parameter
   * - Effective row height = targetButtonHeight * 0.75 + buttonGap (hex formula with 75% overlap)
   * - This ensures identical row count for both hex and rect layouts
   * - Calculates how many rows fit using hex overlap constraints
   * - If calculated height is too small: reduce rows by 1
   * 
   * STEP 3 - BUTTON HEIGHT CALCULATION (respects hasOverlap parameter):
   * - For hexagons (hasOverlap=true): uses overlap formula with 75% height per additional row
   *   Formula: (availableHeight - (rows-1) * gap) / (1 + (rows-1) * 0.75)
   * - For rectangles (hasOverlap=false): uses simple division without overlap
   *   Formula: (availableHeight - (rows-1) * gap) / rows
   * - This allows hexagons to have overlapping visual rows while rectangles have clean separation
   * 
   * WHY THIS APPROACH:
   * - Ensures visual consistency: same number of interactive elements in both layouts
   * - Optimizes for aspect ratio: tries to get buttons as close to target ratio as possible
   * - Respects minimum sizes: never creates buttons smaller than touch-friendly minimum
   * - Handles different rendering: hexagons can overlap visually, rectangles cannot
   * 
   * @param {number} containerWidth - Available width in pixels
   * @param {number} containerHeight - Available height in pixels  
   * @param {number} minButtonSize - Minimum button width/height for touch usability
   * @param {number} targetAspectRatio - Desired height/width ratio (e.g., 3/4 for 4:3 aspect)
   * @param {number} buttonGap - Gap between buttons in pixels
   * @param {number} verticalPadding - Top/bottom padding in pixels
   * @param {boolean} hasOverlap - Whether buttons overlap (true for hex, false for rect)
   * @returns {Object} {columns, rows, buttonWidth, buttonHeight}
   */
  function calculateOptimalGrid(containerWidth, containerHeight, minButtonSize, targetAspectRatio, buttonGap, verticalPadding, hasOverlap = false) {
    const availableWidth = containerWidth;
    const availableHeight = containerHeight - 2 * verticalPadding;
    
    // Universal layout testing functions for both hex and rect
    function testSymmetricalLayout(cols) {
        const buttonWidth = (availableWidth - (cols + 1) * buttonGap) / cols;
        if (buttonWidth < minButtonSize) return null;

        const targetButtonHeight = buttonWidth * targetAspectRatio;
        let effectiveRowHeight = targetButtonHeight * 0.75 + buttonGap;
        let maxPossibleRows = Math.floor(availableHeight / effectiveRowHeight);
        
        let hexCalculatedHeight = (availableHeight - (maxPossibleRows - 1) * buttonGap) / (1 + (maxPossibleRows - 1) * 0.75);
        const minButtonHeight = buttonWidth * (targetAspectRatio * 0.7);
        
        let optimalRows;
        if (hexCalculatedHeight >= minButtonHeight && maxPossibleRows > 0) {
          optimalRows = maxPossibleRows;
        } else {
          optimalRows = Math.max(1, maxPossibleRows - 1);
        }
        
        // Button height calculation depends on hasOverlap (rendering type)
        let calculatedButtonHeight;
        if (hasOverlap) {
            // Hex-style overlapping calculation
            if (optimalRows > 0) {
                calculatedButtonHeight = (availableHeight - (optimalRows - 1) * buttonGap) / (1 + (optimalRows - 1) * 0.75);
            } else {
                calculatedButtonHeight = Math.max(availableHeight, minButtonHeight);
            }
        } else {
            // Rect-style non-overlapping calculation
            if (optimalRows > 0) {
                calculatedButtonHeight = (availableHeight - (optimalRows - 1) * buttonGap) / optimalRows;
            } else {
                calculatedButtonHeight = Math.max(availableHeight, minButtonHeight);
            }
        }

        return {
            columns: cols,
            rows: optimalRows,
            buttonWidth,
            buttonHeight: calculatedButtonHeight,
            layout: 'symmetrical'
        };
    }

    function testAsymmetricalLayout(cols) {
        const buttonWidth = (availableWidth - (cols + 1) * buttonGap) / (cols + 0.5);
        if (buttonWidth < minButtonSize) return null;

        const targetButtonHeight = buttonWidth * targetAspectRatio;
        let effectiveRowHeight = targetButtonHeight * 0.75 + buttonGap;
        let maxPossibleRows = Math.floor(availableHeight / effectiveRowHeight);
        
        let hexCalculatedHeight = (availableHeight - (maxPossibleRows - 1) * buttonGap) / (1 + (maxPossibleRows - 1) * 0.75);
        const minButtonHeight = buttonWidth * (targetAspectRatio * 0.7);
        
        let optimalRows;
        if (hexCalculatedHeight >= minButtonHeight && maxPossibleRows > 0) {
          optimalRows = maxPossibleRows;
        } else {
          optimalRows = Math.max(1, maxPossibleRows - 1);
        }
        
        // Button height calculation depends on hasOverlap (rendering type)
        let calculatedButtonHeight;
        if (hasOverlap) {
            // Hex-style overlapping calculation
            if (optimalRows > 0) {
                calculatedButtonHeight = (availableHeight - (optimalRows - 1) * buttonGap) / (1 + (optimalRows - 1) * 0.75);
            } else {
                calculatedButtonHeight = Math.max(availableHeight, minButtonHeight);
            }
        } else {
            // Rect-style non-overlapping calculation
            if (optimalRows > 0) {
                calculatedButtonHeight = (availableHeight - (optimalRows - 1) * buttonGap) / optimalRows;
            } else {
                calculatedButtonHeight = Math.max(availableHeight, minButtonHeight);
            }
        }

        return {
            columns: cols,
            rows: optimalRows,
            buttonWidth,
            buttonHeight: calculatedButtonHeight,
            layout: 'asymmetrical'
        };
    }

    // Universal algorithm: test different column counts and find the best layout
    let bestLayout = null;
    let maxCols = Math.floor((availableWidth - buttonGap) / minButtonSize);

    for (let cols = 1; cols <= maxCols; cols++) {
        const symm = testSymmetricalLayout(cols);
        const asymm = testAsymmetricalLayout(cols);

        // Choose the best layout for both hex and rect using same logic
        const candidates = [symm, asymm].filter(l => l !== null);
        for (const candidate of candidates) {
            if (!bestLayout) {
                bestLayout = candidate;
            } else {
                // Prioritize the layout that fits more columns
                if (candidate.columns > bestLayout.columns) {
                    bestLayout = candidate;
                } else if (candidate.columns === bestLayout.columns) {
                    // If column count is equal, prefer asymmetrical for density,
                    // or the one with slightly larger buttons if the layout is the same
                    if (candidate.layout === 'asymmetrical' && bestLayout.layout === 'symmetrical') {
                        bestLayout = candidate;
                    } else if (candidate.buttonWidth > bestLayout.buttonWidth) {
                        bestLayout = candidate;
                    }
                }
            }
        }
    }

    return bestLayout || {
        columns: 1,
        rows: 1,
        buttonWidth: Math.max(minButtonSize, availableWidth - 2 * buttonGap),
        buttonHeight: Math.max(minButtonSize, availableHeight),
        layout: 'symmetrical'
    };
  }

  // Dynamic width and height calculated based on container size
  let optimalHexWidth = MIN_HEX_WIDTH;
  let optimalHexHeight = 7.5625 * 16; // Default height
  let itemsPerRow = 1;
  let totalRows = 1;
  
  // Variables for 4-4-4 rectangular grid layout
  let rectButtonWidth = MIN_RECT_SIZE; // calculated rectangular button width
  let rectButtonHeight = MIN_RECT_SIZE; // calculated rectangular button height
  let rectItemsPerRow = 1; // Dynamic: calculated columns
  let rectTotalRows = 1; // Dynamic: calculated rows

  let chosenLayout = 'symmetrical';

  // --- REACTIVE CALCULATIONS ---
  $: {
    let _ = currentView; // Add dependency on currentView
    if (containerWidth > 0 && containerHeight > 0 && layoutType === '6-6-6') {
      addLog('DEBUG', `6-6-6 CALC: Container=${containerWidth}x${containerHeight}px`);
      
      const hexGrid = calculateOptimalGrid(
        containerWidth, 
        containerHeight, 
        MIN_HEX_WIDTH, 
        3/4, // hex aspect ratio
        HEX_EDGE_GAP, 
        HEX_VERTICAL_PADDING, 
        true // has overlap
      );
      
      itemsPerRow = hexGrid.columns;
      totalRows = hexGrid.rows;
      optimalHexWidth = hexGrid.buttonWidth;
      optimalHexHeight = hexGrid.buttonHeight;
      chosenLayout = hexGrid.layout;
      
      addLog('INFO', `6-6-6 RESULT (${chosenLayout}): ${itemsPerRow}×${totalRows} (${optimalHexWidth.toFixed(1)}×${optimalHexHeight.toFixed(1)}px)`);
    } else if (containerWidth > 0 && containerHeight > 0 && layoutType === '4-4-4') {
      addLog('DEBUG', `4-4-4 CALC: Container=${containerWidth}x${containerHeight}px`);
      
      const rectGrid = calculateOptimalGrid(
        containerWidth, 
        containerHeight, 
        MIN_RECT_SIZE, 
        3/4, // start with same target ratio as hex
        RECT_GAP, 
        RECT_VERTICAL_PADDING, 
        false // no overlap for rectangles
      );
      
      rectItemsPerRow = rectGrid.columns;
      rectTotalRows = rectGrid.rows;
      rectButtonWidth = rectGrid.buttonWidth;
      rectButtonHeight = rectGrid.buttonHeight;
      chosenLayout = rectGrid.layout;

      addLog('INFO', `4-4-4 RESULT: ${rectItemsPerRow}×${rectTotalRows} (${rectButtonWidth.toFixed(1)}×${rectButtonHeight.toFixed(1)}px)`);
    } else {
      itemsPerRow = 1;
      optimalHexWidth = MIN_HEX_WIDTH;
      rectItemsPerRow = 1;
      rectButtonWidth = MIN_RECT_SIZE;
      rectButtonHeight = MIN_RECT_SIZE;
    }
  }
  
  // Build persistent grid structure when container size OR layout parameters change
  $: {
    if (containerWidth > 0 && containerHeight > 0) {
      if (layoutType === '6-6-6' && itemsPerRow > 0 && totalRows > 0) {
        addLog('DEBUG', `REBUILDING GRID (${chosenLayout}): ${itemsPerRow}×${totalRows} (${optimalHexWidth.toFixed(1)}×${optimalHexHeight.toFixed(1)})`);
        gridCells = buildGridStructure();
      } else if (layoutType === '4-4-4' && rectItemsPerRow > 0 && rectTotalRows > 0) {
        gridCells = buildGridStructure();
      }
    }
  }
  
  // Update grid content when grid structure changes OR when data/view changes OR when order state changes
  $: {
    if (gridCells.length > 0 && (
      (currentView === 'categories' && categories.length >= 0) ||
      (currentView === 'products' && products.length >= 0)
    )) {
      updateGridContent();
    }
  }
  
  // Force grid content update when order state changes (for payment button reactivity)
  $: {
    if (gridCells.length > 0 && $orderStore) {
      // This will trigger re-rendering of payment buttons when order state changes
      gridCells = [...gridCells];
    }
  }
  
  function buildGridStructure() {
    const cells = [];
    
    if (layoutType === '6-6-6') {
      for (let rowIndex = 0; rowIndex < totalRows; rowIndex++) {
        buildHoneycombRow(cells, rowIndex, chosenLayout);
      }
    } else if (layoutType === '4-4-4') {
      buildRectGridLayout(cells, chosenLayout);
    }
    
    // Designate the bottom-left full button as the Pinpad trigger
    if (cells.length > 0) {
        let potentialTriggers = cells.filter(c => c.type === 'full' || c.type === 'rect-grid');
        if (potentialTriggers.length > 0) {
            potentialTriggers.sort((a,b) => (b.rowIndex - a.rowIndex) || (a.columnIndex - b.columnIndex));
            potentialTriggers[0].isPinpadTrigger = true;
        }
    }

    // Designate the leftmost button of the second-to-last row as the Table button
    if (cells.length > 0) {
        // Find the second-to-last row (предпоследний ряд)
        const maxRowIndex = Math.max(...cells.map(c => c.rowIndex));
        const secondToLastRowIndex = maxRowIndex - 1;
        
        let potentialTableButtons = cells.filter(c => 
            (c.type === 'full' || c.type === 'rect-grid') && 
            c.rowIndex === secondToLastRowIndex
        );
        
        if (potentialTableButtons.length > 0) {
            // Sort by column (left first) 
            potentialTableButtons.sort((a,b) => a.columnIndex - b.columnIndex);
            potentialTableButtons[0].isTableButton = true;
        }
    }

    return cells;
  }
  
  function buildHoneycombRow(cells, rowIndex, layoutType) {
    const isOddRow = rowIndex % 2 === 1;

    if (layoutType === 'symmetrical') {
        const fullButtonsInRow = isOddRow ? itemsPerRow : itemsPerRow - 1;
        if (fullButtonsInRow < 0) return; // Avoid creating rows with negative buttons

        if (!isOddRow) {
            cells.push({ id: `half-start-${rowIndex}`, type: 'left-half', content: null, rowIndex, columnIndex: 0 });
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ id: `full-${rowIndex}-${i}`, type: 'full', content: null, rowIndex, columnIndex: i + 1 });
            }
            cells.push({ id: `half-end-${rowIndex}`, type: 'right-half', content: null, rowIndex, columnIndex: fullButtonsInRow + 1 });
        } else {
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ id: `full-${rowIndex}-${i}`, type: 'full', content: null, rowIndex, columnIndex: i });
            }
        }
    } else { // Asymmetrical
        const fullButtonsInRow = itemsPerRow;
        if (!isOddRow) {
            cells.push({ id: `half-start-${rowIndex}`, type: 'left-half', content: null, rowIndex, columnIndex: 0 });
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ id: `full-${rowIndex}-${i}`, type: 'full', content: null, rowIndex, columnIndex: i + 1 });
            }
        } else {
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ id: `full-${rowIndex}-${i}`, type: 'full', content: null, rowIndex, columnIndex: i });
            }
            cells.push({ id: `half-end-${rowIndex}`, type: 'right-half', content: null, rowIndex, columnIndex: fullButtonsInRow });
        }
    }
  }
  
  
  function buildRectGridLayout(cells, layoutType) {
    // Build rectangular grid with alternating full/half rows like honeycomb
    for (let rowIndex = 0; rowIndex < rectTotalRows; rowIndex++) {
      buildRectRow(cells, rowIndex, layoutType);
    }
  }
  
  function buildRectRow(cells, rowIndex, layoutType) {
    const isOddRow = rowIndex % 2 === 1;

    if (layoutType === 'symmetrical') {
        const fullButtonsInRow = isOddRow ? rectItemsPerRow : rectItemsPerRow - 1;
        if (fullButtonsInRow < 0) return; // Avoid creating rows with negative buttons

        if (!isOddRow) {
            cells.push({ 
                id: `rect-half-start-${rowIndex}`, 
                type: 'left-half-rect', 
                content: null, 
                rowIndex, 
                columnIndex: 0,
                width: rectButtonWidth / 2 - RECT_GAP / 2,
                height: rectButtonHeight
            });
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ 
                    id: `rect-full-${rowIndex}-${i}`, 
                    type: 'rect-grid', 
                    content: null, 
                    rowIndex, 
                    columnIndex: i + 1,
                    width: rectButtonWidth,
                    height: rectButtonHeight
                });
            }
            cells.push({ 
                id: `rect-half-end-${rowIndex}`, 
                type: 'right-half-rect', 
                content: null, 
                rowIndex, 
                columnIndex: fullButtonsInRow + 1,
                width: rectButtonWidth / 2 - RECT_GAP / 2,
                height: rectButtonHeight
            });
        } else {
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ 
                    id: `rect-full-${rowIndex}-${i}`, 
                    type: 'rect-grid', 
                    content: null, 
                    rowIndex, 
                    columnIndex: i,
                    width: rectButtonWidth,
                    height: rectButtonHeight
                });
            }
        }
    } else { // Asymmetrical
        const fullButtonsInRow = rectItemsPerRow;
        if (!isOddRow) {
            cells.push({ 
                id: `rect-half-start-${rowIndex}`, 
                type: 'left-half-rect', 
                content: null, 
                rowIndex, 
                columnIndex: 0,
                width: rectButtonWidth / 2 - RECT_GAP / 2,
                height: rectButtonHeight
            });
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ 
                    id: `rect-full-${rowIndex}-${i}`, 
                    type: 'rect-grid', 
                    content: null, 
                    rowIndex, 
                    columnIndex: i + 1,
                    width: rectButtonWidth,
                    height: rectButtonHeight
                });
            }
        } else {
            for (let i = 0; i < fullButtonsInRow; i++) {
                cells.push({ 
                    id: `rect-full-${rowIndex}-${i}`, 
                    type: 'rect-grid', 
                    content: null, 
                    rowIndex, 
                    columnIndex: i,
                    width: rectButtonWidth,
                    height: rectButtonHeight
                });
            }
            cells.push({ 
                id: `rect-half-end-${rowIndex}`, 
                type: 'right-half-rect', 
                content: null, 
                rowIndex, 
                columnIndex: fullButtonsInRow,
                width: rectButtonWidth / 2 - RECT_GAP / 2,
                height: rectButtonHeight
            });
        }
    }
  }
  
  function clearGridContent() {
    gridCells.forEach(cell => {
      cell.content = null;
    });
  }
  
  function updateGridContent() {
    addLog('DEBUG', `updateGridContent called with ${gridCells.length} grid cells`);
    if (gridCells.length === 0) {
      addLog('DEBUG', 'No grid cells, skipping updateGridContent');
      return;
    }
    clearGridContent();
    
    // Always initialize system buttons first
    initializeSystemButtons(gridCells);
    
    if (currentView === 'categories') {
      populateWithCategories(gridCells, categories);
    } else {
      populateWithProducts(gridCells, products);
    }
    gridCells = [...gridCells];
  }
  
  function initializeSystemButtons(grid) {
    addLog('DEBUG', `initializeSystemButtons called with ${grid.length} cells`);
    
    // Add smart navigation to bottommost left half button (always visible)
    const leftHalfCells = grid.filter(cell => 
      cell.type === 'left-half' || cell.type === 'left-half-rect'
    );
    if (leftHalfCells.length > 0) {
      leftHalfCells.sort((a, b) => b.rowIndex - a.rowIndex); // Sort descending to get bottom first
      const bottomLeftHalfCell = leftHalfCells[0];
      bottomLeftHalfCell.content = { isSmartNavigation: true };
    }

    // Add layout toggle to topmost right half button (always visible)
    const rightHalfCells = grid.filter(cell => 
      cell.type === 'right-half' || cell.type === 'right-half-rect'
    );
    if (rightHalfCells.length > 0) {
      rightHalfCells.sort((a, b) => a.rowIndex - b.rowIndex);
      const topRightHalfCell = rightHalfCells[0];
      topRightHalfCell.content = { 
        isLayoutToggle: true, 
        icon: '', 
        showShape: layoutType === '6-6-6' ? 'rect' : 'hex'
      };
      
      // Add time display to bottommost right half button (always visible)
      if (rightHalfCells.length > 1) {
        rightHalfCells.sort((a, b) => b.rowIndex - a.rowIndex); // Sort descending to get bottom first
        const bottomRightHalfCell = rightHalfCells[0];
        bottomRightHalfCell.content = { isTimeButton: true };
      }
    }

    // Designate the Betruger Cap button - rightmost full button in second-to-last row
    const maxRowIndex = Math.max(...grid.map(cell => cell.rowIndex));
    addLog('DEBUG', `Max row index: ${maxRowIndex}`);
    
    if (maxRowIndex > 1) {
        const targetRowIndex = maxRowIndex - 1;
        const targetRowCells = grid.filter(cell => 
            cell.rowIndex === targetRowIndex && 
            (cell.type === 'full' || cell.type === 'rect-grid') &&
            !cell.content // Only assign to empty cells
        );
        
        addLog('DEBUG', `Found ${targetRowCells.length} cells for Betruger Cap in row ${targetRowIndex}`);
        
        if (targetRowCells.length > 0) {
            targetRowCells.sort((a, b) => b.columnIndex - a.columnIndex); // Sort right-to-left
            targetRowCells[0].content = { 
              isBetrugerCap: true,
              label: 'AI',
              color: '#8A2BE2',
              icon: '🤖'
            };
            addLog('DEBUG', `Assigned Betruger Cap to row ${targetRowCells[0].rowIndex}, col ${targetRowCells[0].columnIndex}`);
        }
    }

    // Add keyboard toggle button - second from left in last row
    const lastRowCells = grid.filter(cell => 
        cell.rowIndex === maxRowIndex && 
        (cell.type === 'full' || cell.type === 'rect-grid') &&
        !cell.content // Only assign to empty cells
    );
    
    addLog('DEBUG', `Found ${lastRowCells.length} cells for keyboard button in row ${maxRowIndex}`);
    
    if (lastRowCells.length > 1) {
        lastRowCells.sort((a, b) => a.columnIndex - b.columnIndex); // Sort left-to-right
        lastRowCells[1].content = { 
          isKeyboardToggle: true,
          label: 'KB',
          color: '#FF6347',
          icon: '⌨️'
        };
        addLog('DEBUG', `Assigned keyboard toggle to row ${lastRowCells[1].rowIndex}, col ${lastRowCells[1].columnIndex}`);
    }
  }
  
  function populateWithCategories(grid, categories) {
    // Find bottom row full buttons and assign payment functions from right to left
    assignPaymentButtons(grid);
    
    let categoryIndex = 0;
    for (const cell of grid) {
      if (categoryIndex >= categories.length) break;
      if ((cell.type === 'full' || cell.type === 'rect-grid') && !cell.isPinpadTrigger && !cell.content) {
        cell.content = categories[categoryIndex];
        categoryIndex++;
      }
    }
  }
  
  function populateWithProducts(grid, products) {
    // Add back button to second topmost left half button (since first is now system button)
    const leftHalfCells = grid.filter(cell => 
      (cell.type === 'left-half' || cell.type === 'left-half-rect') && !cell.content
    );
    if (leftHalfCells.length > 0) {
      leftHalfCells.sort((a, b) => a.rowIndex - b.rowIndex);
      const leftHalfCell = leftHalfCells[0];
      leftHalfCell.content = { isBackButton: true, icon: '←' };
    }

    // Find bottom row full buttons and assign payment functions from right to left
    assignPaymentButtons(grid);
    
    let productIndex = 0;
    for (const cell of grid) {
      if (productIndex >= products.length) break;
      if ((cell.type === 'full' || cell.type === 'rect-grid') && !cell.isPinpadTrigger && !cell.content) {
        cell.content = products[productIndex];
        productIndex++;
      }
    }
  }

  function assignPaymentButtons(grid) {
    // Find all full buttons in the bottom row, excluding the Pinpad and Table triggers
    const maxRowIndex = Math.max(...grid.map(cell => cell.rowIndex));
    const bottomRowFullButtons = grid.filter(cell => 
      cell.rowIndex === maxRowIndex && 
      (cell.type === 'full' || cell.type === 'rect-grid') && 
      !cell.isPinpadTrigger &&
      !cell.isTableButton &&
      !cell.content // Don't overwrite already assigned buttons
    );
    
    addLog('DEBUG', `Found ${bottomRowFullButtons.length} bottom row buttons for payment assignment`);
    
    // Sort by column index from right to left (descending)
    bottomRowFullButtons.sort((a, b) => b.columnIndex - a.columnIndex);
    
    // Payment buttons in priority order (right to left) - muted professional colors
    const paymentButtons = [
      { type: 'bar', label: 'Bar', color: '#5a7a5a', icon: '<?xml version="1.0" encoding="utf-8" ?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="96" viewBox="0 0 128 96"><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M860.049 42.5451C863.174 42.624 864.396 43.2157 867.135 44.649C899.278 61.4706 930.616 79.3737 962.241 97.0455L1140.06 196.515L1235.83 249.392C1244.2 254.024 1279.17 272.625 1283.9 277.585C1282.44 280.57 1281.27 282.302 1279.45 285.063C1282.58 292.135 1296.05 322.182 1296.51 327.834C1294.74 332.438 1289.84 335.037 1285.72 337.876C1288.3 345.822 1294.55 360.167 1297.81 368.289C1294.05 372.162 1290.61 374.451 1286.23 377.548C1289.54 386.869 1295.46 400.922 1297.78 409.853C1294.56 413.357 1291.61 414.85 1287.52 417.236C1290.52 427.181 1296.24 437.43 1299.15 447.79C1295.53 451.696 1291.99 453.323 1287.39 455.808C1291.55 465.344 1300.2 486.142 1302.74 495.595C1300.26 497.252 1297.58 498.606 1294.99 500.086C1280.56 508.342 1266.12 516.628 1251.85 525.174L1139.03 593.407L784.062 803.333L568.699 931.564C544.412 945.804 520.233 960.147 496.127 974.691C493.279 976.409 490.339 977.962 487.355 979.433C482.346 976.418 477.284 972.61 472.507 969.184C419.655 931.492 366.284 906.945 308.516 877.93C246.547 846.805 187.533 807.107 130.367 768.004C109.446 753.693 89.6758 737.836 69.6562 722.326C67.6909 720.788 66.5047 719.127 66.4393 716.66C68.933 711.97 79.7318 705.333 84.8102 701.638C80.3582 697.5 66.4077 688.821 65.9928 683.839C67.4568 679.274 79.8188 670.984 84.5252 667.263C62.3668 647.79 57.3531 652.544 84.8764 632.52C60.2719 609.41 57.851 620.244 83.8486 596.689C61.5012 576.407 56.2767 581.092 83.5163 559.902C78.7788 555.355 65.7634 547.292 65.5365 541.128C66.4298 538.823 67.721 538.009 69.9547 536.831C110.119 515.654 150.867 494.877 189.936 471.676L442.039 318.543C574.814 237.077 708.69 156.693 833.113 62.8355C842.043 56.0988 850.441 48.3397 860.049 42.5451Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M437.354 362.52C440.468 362.724 453.229 370.573 456.645 372.576C456.248 411.173 470.048 437.93 496.698 465.191C535.474 505.015 587.787 528.835 640.955 542.632C663.451 548.469 686.655 552.888 709.82 554.963C713.453 555.288 721.068 555.741 724.211 556.957C735.116 561.174 750.44 569.728 760.561 574.97C753.804 579.772 739.809 587.316 732.134 591.946L669.659 629.727L529.807 716.115C509.311 728.821 489.035 740.492 468.5 753.531L460.175 748.22C380.381 698.429 296.612 654.368 217.514 603.59C191.072 586.615 156.144 564.027 132.384 544.176C159.606 527.584 189.257 513.528 216.644 496.662C246.139 478.497 276.856 461.286 306.409 443.286L437.354 362.52Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M432.603 379.871C433.645 380.086 437.093 381.244 437.144 382.487C438.791 442.392 490.02 487.403 537.337 514.789C596.404 549.752 662.499 562.556 729.71 570.091C731.937 570.341 734.147 574.935 729.179 577.671C716.909 584.428 704.675 592.104 692.723 599.379L602.992 654.239C577.877 669.443 547.915 688.824 522.338 702.561C519.263 701.134 515.523 698.889 512.498 697.182C481.961 681.362 440.641 679.265 407.87 688.789C406.567 688.288 404.507 687.394 403.295 686.669C374.494 669.436 345.564 652.574 316.516 635.765L261.137 604.086C252.052 598.921 242.711 593.921 233.779 588.521C231.308 587.027 230.306 586.046 229.463 583.32C230.908 581.26 234.513 577.718 236.32 576.107C255.415 559.082 260.677 539.318 247.048 516.743C244.349 512.273 239.119 505.351 238.102 500.399C241.624 496.163 261.502 486.587 267.152 483.284C323.079 450.594 379.073 416.312 432.603 379.871Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M427.755 394.648C428.427 395.385 433.323 416.495 434.744 420.094C459.781 483.513 526.563 524.948 587.468 548.864C624.138 563.264 672.331 572.498 712.153 577.016C695.782 588.268 673.468 600.738 656.112 611.431L521.867 692.386C519.632 690.964 516.728 689.382 514.39 688.03C486.171 672.098 440.303 671.74 409.318 679.477C354.86 647.196 298.177 613.73 242.73 583.323C268.545 554.332 271.645 536.924 249.926 503.745C274.308 489.403 298.626 475.702 322.89 460.996C358.43 439.456 392.74 416.944 427.755 394.648Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M420.928 529.557C440.364 527.204 462.006 533.996 478.231 544.432C505.824 562.18 515.928 600.707 474.606 607.832C454.695 610.962 434.049 605.236 417.133 593.494C402.754 583.514 382.618 560.384 395.572 541.734C401.072 533.816 411.655 530.807 420.928 529.557Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M422.396 537.572C439.811 536.323 454.996 540.394 470.629 549.858C482.293 556.92 499.445 575.18 490.349 590.521C487.135 595.941 479.225 598.025 473.215 599.15C451.773 602.522 429.989 593.983 414.337 579.352C406.313 571.858 395.794 557.307 403.413 546.275C407.534 540.308 415.724 538.43 422.396 537.572Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M431.608 541.652C444.113 540.518 460.635 548.703 470.113 556.27C487.388 570.061 493.855 594.7 463.692 595.478C440.635 595.539 414.37 580.096 409.069 556.385C412.156 543.961 420.397 542.15 431.608 541.652Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M430.903 549.572C448.069 550.417 469.541 559.747 476.043 577.382C478.355 583.655 470.553 586.503 465.732 587.494C449.066 587.673 424.543 577.138 418.728 559.024C416.76 552.894 426.122 550.234 430.903 549.572Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M863.232 87.2873C868.567 89.6681 886.32 100.38 892.447 103.717L979.224 151.934L1114.89 227.794L1173.27 260.337C1186.49 267.632 1202.25 275.698 1214.72 283.907C1209 289.833 1199.51 297.299 1193.06 302.539C1171.88 319.752 1149.38 334.848 1126.86 350.222C1068.59 390.001 1009.09 427.414 948.803 464.056C943.611 467.224 938.593 470.196 933.305 473.202C924.501 468.621 915.791 464.102 907.108 459.282C906.201 449.664 904.907 440.279 901.844 431.01C875.061 354.618 788.264 311.126 715.725 289.766C690.219 282.255 665.241 278.117 639.239 274.945C635.813 274.527 610.758 260.836 605.986 258.388C614.148 253.38 622.098 248.137 630.126 242.907C691.186 203.12 754.381 166.396 813.541 123.77C830.223 111.75 846.473 99.1284 863.232 87.2873Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M815.169 143.23C820.01 143.65 833.17 150.547 839.172 152.369C874.725 163.16 897.612 162.491 932.11 152.143C942.359 156.464 964.128 169.229 974.479 174.967L1058.24 221.96L1094.81 242.726C1100.33 245.843 1112.84 252.545 1117.13 256.195C1117.34 260.585 1105.49 276.929 1103.32 286.649C1100.24 300.451 1104.41 311.66 1113.37 322.128C1115.87 325.056 1119.01 327.92 1121.01 331.197C1121.62 332.201 1122.93 334.597 1122.42 335.804C1120.61 340.094 970.753 433.542 952.784 444.112C947.193 447.448 933.215 456.755 927.395 457.038C922.096 455.492 923.587 449.148 922.925 444.574C919.499 423.328 908.247 398.45 894.432 382.153C832.481 309.078 733.877 272.032 640.4 263.141C638.522 262.962 635.673 262.607 634.669 260.853C633.123 258.153 634.219 255.542 636.744 253.994C643.855 249.564 651.066 245.211 658.22 240.808L696.671 216.774C735.109 192.526 776.172 165.946 815.169 143.23Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M816.101 153.267C820.938 154.455 832.096 159.798 838.708 161.788C869.421 171.029 899.584 172.361 930.24 162.219C947.297 169.696 972.382 184.596 989.162 193.882C1028.19 215.481 1066.9 238.259 1106.14 259.543C1088.09 286.126 1087.98 309.936 1111.16 333.263C1060.03 366.162 1007.49 400.291 955.796 431.906L931.939 446.143C927.207 420.913 921.429 401.986 905.252 381.29C844.52 303.595 746.727 268.758 652.988 254.98C663.751 247.371 676.39 240.21 687.734 233.247C730.593 206.94 772.911 178.996 816.101 153.267Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M888.123 236.906C907.271 234.803 932.137 243.119 947.369 254.887C974.635 275.953 981.482 312.727 938.595 317.809C918.294 320.264 896.142 310.455 880.077 298.717C851.933 278.153 845.179 241.729 888.123 236.906Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M890.004 245.573C937.28 239.841 993.388 301.88 937.771 309.217C918.326 309.468 904.878 305.036 888.766 294.023C866.822 279.023 851.144 250.275 890.004 245.573Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M892.847 249.501C931.261 247.398 982.077 294.562 935.937 303.868C890.274 305.892 849.093 257.039 892.847 249.501Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M891.042 258.136C909.921 256.863 934.938 267.401 943.991 285.485C946.571 290.639 940.383 294.001 936.192 295.279C918.197 296.181 894.229 286.385 884.441 270.486C880.864 264.675 886.294 260.418 891.042 258.136Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M569.917 250.985C600.071 265.336 632.286 283.54 662.879 298.923C711.717 323.48 766.327 347.323 809.98 379.871C826.232 391.988 846.064 414.687 853.035 433.848C854.302 437.33 855.088 441.13 857.422 443.983C863.801 446.774 872.064 451.533 878.336 455.01C902.214 468.252 927.647 480.196 951.405 493.459C908.132 517.066 865.758 544.694 822.8 569.044C814.508 573.744 806.127 579.048 798.227 584.4C766.533 568.817 735.905 551.346 704.091 536.024C702.171 535.099 698.985 533.607 697.306 532.481C673.358 521.726 648.07 509.769 624.496 498.22C583.418 478.096 532.775 457.445 510.864 414.593C506.97 406.225 502.743 397.162 503.534 387.804C476.645 373.018 448.813 356.935 421.883 342.599L528.917 276.068C542.309 267.916 556.415 258.63 569.917 250.985Z"/><defs><linearGradient id="gradient_0" gradientUnits="userSpaceOnUse" x1="544.67743" y1="255.5813" x2="738.42389" y2="525.00348"><stop offset="0" stop-color="#F8EB90"/><stop offset="1" stop-color="#FFFFD2"/></linearGradient></defs><path fill="url(#gradient_0)" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M569.917 250.985C600.071 265.336 632.286 283.54 662.879 298.923C711.717 323.48 766.327 347.323 809.98 379.871C826.232 391.988 846.064 414.687 853.035 433.848C854.302 437.33 855.088 441.13 857.422 443.983C853.575 445.243 804.676 422.223 797.335 418.71C769.583 376.013 706.172 385.172 664.305 394.727C652.184 388.193 632.718 378.227 621.721 370.91C630.035 366.065 667.548 352.436 670.579 347.151C671.017 346.386 671.238 346.007 670.935 345.145C669.188 340.164 647.653 329.692 642.244 327.013C624.624 331.338 598.901 338.381 584.078 349.222C575.251 344.602 566.965 339.622 557.836 335.447C552.574 339.326 538.585 346.698 539.551 353.13C542.187 357.322 555.973 363.928 561.107 366.698C549.376 382.992 546.393 398.072 555.473 416.545C553.228 416.274 550.212 415.039 547.914 414.849C535.217 413.802 523.166 411.107 510.864 414.593C506.97 406.225 502.743 397.162 503.534 387.804C476.645 373.018 448.813 356.935 421.883 342.599L528.917 276.068C542.309 267.916 556.415 258.63 569.917 250.985Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.335 418.71C804.676 422.223 853.575 445.243 857.422 443.983C863.801 446.774 872.064 451.533 878.336 455.01C902.214 468.252 927.647 480.196 951.405 493.459C908.132 517.066 865.758 544.694 822.8 569.044C814.508 573.744 806.127 579.048 798.227 584.4C766.533 568.817 735.905 551.346 704.091 536.024C702.171 535.099 698.985 533.607 697.306 532.481L697.873 532.018C700.327 526.361 701.065 520.78 700.101 514.628C703.495 512.657 713.957 509.832 718.378 508.193C735.602 501.808 750.436 496.233 765.745 486.115C774.383 490.846 783.039 495.918 791.597 500.82C819.215 485.313 812.782 481.683 789.782 468.353C793.85 464.364 796.947 461.728 799.157 456.387C804.272 444.025 801.874 430.64 797.335 418.71Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M510.864 414.593C523.166 411.107 535.217 413.802 547.914 414.849C550.212 415.039 553.228 416.274 555.473 416.545C580.97 454.453 635.267 440.421 671.257 430.401C687.885 439.97 712.836 453.889 728.216 464.596C705.104 476.524 685.157 483.456 658.974 481.774C653.66 481.432 648.928 480.59 647.24 485.37C648.235 489.553 662.656 496.087 666.635 498.036C673.281 501.292 693.907 515.244 700.101 514.628C701.065 520.78 700.327 526.361 697.873 532.018L697.306 532.481C673.358 521.726 648.07 509.769 624.496 498.22C583.418 478.096 532.775 457.445 510.864 414.593Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M640.185 336.046C642.83 335.508 653.255 343.434 656.336 345.46C645.76 350.701 612.377 362.37 605.617 369.018C605.368 369.963 605.028 370.443 605.403 371.393C606.759 374.84 655.877 401.06 662.736 404.42C676.979 400.771 688.966 397.925 703.859 396.505C730.277 393.985 759.902 396.222 781.406 413.504C787.341 418.274 788.821 423.006 790.903 427.556C799.425 446.176 777.023 464.451 777.514 469.565C780.218 473.679 794.229 481.385 799.309 484.577C796.768 487.06 794.581 488.468 791.672 490.483C782.636 486.244 773.886 479.946 765.086 476.211C760.594 478.571 754.374 482.673 750.07 484.872C741.459 489.272 702.648 507.972 695.517 503.867C688.167 499.397 681.096 495.283 673.599 491.064C693.635 488.397 712.157 482.521 730.623 474.385C734.361 472.738 745.292 469.144 744.592 464.398C739.087 458.429 682.333 426.511 671.894 420.729C641.877 428.698 610.614 440.045 580.05 426.53C566.213 420.412 559.105 408.835 559.609 393.973C560.034 381.437 568.245 374.725 573.232 364.366C570.541 360.45 558.019 354.151 552.879 350.762C554.682 349.216 556.807 347.722 558.729 346.299C566.619 349.644 575.646 355.465 583.82 359.403C606.463 345.801 614.955 343.283 640.185 336.046Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M722.101 411.605C737.772 411.348 758.748 414.519 764.527 431.839C767.317 440.202 765.15 455.657 755.317 458.84C752.4 459.784 743.566 453.412 740.728 451.599C726.943 442.578 704.381 431.65 690.422 421.497C689.301 420.681 689.132 419.302 689.298 417.982C693.653 413.301 715.287 412.062 722.101 411.605Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M710.515 421.038C727.155 419.458 767.026 420.763 753.881 448.036C753.467 448.009 753.052 447.982 752.638 447.955C747.23 443.878 711.218 424.966 709.383 421.771L710.515 421.038Z"/><path fill="#473736" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M591.602 375.857C597.22 376.002 638.908 399.26 645.236 404.957C646.316 405.929 645.976 406.073 645.946 407.497C643.067 410.968 637.218 411.321 632.606 412.183C619.004 414.782 595.21 419.653 585.345 407.827C576.495 397.218 582.398 383.484 591.602 375.857Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M593.621 385.939C597.317 387.28 623.862 401.502 627.032 403.761C626.254 405.165 624.38 405.444 622.523 406.143C608.472 409.297 578.03 407.704 593.621 385.939Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M958.26 500.59C958.309 500.625 958.368 500.65 958.407 500.696C962.834 505.853 957.008 663.434 960.509 688.464C950.668 693.822 939.461 701.527 929.263 707.407L808.704 777.941C808.442 778.033 807.839 777.914 807.504 777.878C806.214 772.473 807.171 739.691 807.157 732.541L806.953 588.7L905.241 531.681C923.167 521.165 940.027 510.784 958.26 500.59Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M412.322 347.92C416.816 350.025 423.761 354.119 428.31 356.61C422.313 361.097 411.451 367.39 404.908 371.418L360.596 398.714C302.781 434.608 244.266 469.314 185.486 503.604C172.48 511.191 159.621 518.247 146.399 525.395C137.481 530.216 125.773 535.714 117.759 541.377C116.952 547.239 127.828 553.362 132.282 556.711C210.683 615.672 296.46 661.42 380.672 711.072L437.39 745.031C447.127 750.877 458.251 757.912 468.159 763.233C475.752 760.476 490.892 750.508 498.41 745.867L544.998 717.293C619.75 671.852 694.616 623.998 770.082 580.078C775.451 582.717 781.943 586.585 787.255 589.575L761.206 604.833C722.229 627.901 683.446 652.216 644.859 675.97L559.799 727.884C528.141 747.473 492.014 771.026 459.842 789.273C447.919 780.414 435.816 772.359 423.345 764.354C324.641 700.998 216.927 652.431 123.988 580.014C109.003 568.338 91.9762 556.103 78.3558 542.954C90.0386 536.171 103.574 529.531 115.655 523.282C177.727 491.173 236.95 454.856 296.607 418.571L412.322 347.92Z"/><path fill="#FCF7C3" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M861.831 52.5308C864.57 53.4612 866.642 54.7966 869.163 56.1524C895.556 70.3495 921.356 85.7755 947.671 100.079L1230.57 257.315C1243.69 264.517 1256.59 272.149 1269.71 279.217C1175.6 356.192 1064.94 422.527 962.281 487.861C955.8 484.64 949.585 481.389 943.198 477.985C957.053 471.093 969.852 462.305 983.014 454.139C1002.69 441.928 1022.29 429.641 1041.75 417.075C1091.21 385.124 1141.82 353.315 1188.62 317.456C1196.79 310.96 1204.7 304.43 1212.88 297.641C1214.61 296.561 1229.81 283.569 1227.54 281.605C1214.93 270.713 1176.54 251.32 1163.95 244.234L1006.02 155.809L910.312 102.616C896.349 94.9347 875.909 82.8363 861.902 76.4106C848.931 86.0075 836.038 95.7336 823.008 105.255C772.056 142.483 717.854 176.355 664.456 209.85L618.677 238.899C611.474 243.382 602.599 249.25 595.166 252.922L579.38 244.973C586.064 239.989 596.866 233.954 604.242 229.447C694.042 174.577 778.363 116.742 861.831 52.5308Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1270.8 289.893C1272.96 292.825 1283.87 319.801 1286.62 325.591C1278.17 331.226 1270.07 337.936 1261.81 343.912C1187.3 397.796 1108.04 445.022 1030.56 494.428C1013.74 505.152 996.892 515.727 979.854 526.156L969.058 532.999L969.14 493.949C1015.46 466.402 1064.52 434.21 1109.86 404.585C1162.52 370.179 1222.97 330.276 1270.8 289.893Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M91.6453 638.482C103.953 646.879 115.372 656.633 127.826 665.029C166.574 690.715 206.543 715.44 246.478 739.271C296.476 769.107 349.931 793.164 399.496 823.956C424.004 839.181 444.342 855.915 466.744 873.715C468.112 879.395 469.588 884.456 471.626 889.956C472.58 892.531 473.366 894.901 471.384 897.008C468.81 897.241 466.72 895.563 464.34 894.178C445.231 882.901 427.416 872.021 407.602 861.914C357.452 836.333 306.383 813.11 258.107 783.947C236.427 770.85 215.516 755.041 195.065 740.053C155.645 711.164 115.611 680.647 77.7347 649.719C80.709 646.876 88.1036 641.359 91.6453 638.482Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M796.964 594.669C797.903 595.624 797.706 628.46 797.791 632.87C758.677 654.126 713.854 682.432 675.547 705.861L564.05 773.108L502.681 810.522C496.455 814.362 480.297 825.458 474.689 827.69C473.102 826.709 473.456 826.243 472.719 823.847C470.606 814.956 467.488 805.868 464.666 797.139L626.169 698.15C682.708 663.228 739.441 627.95 796.964 594.669Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.044 747.362C798.209 749.044 797.339 779.545 797.277 784.393C774.596 798.797 748.409 813.318 725.074 827.162L584.117 911.18L516.906 951.046C512.152 953.879 495.739 964.606 491.921 965.861C490.855 964.386 490.673 962.102 490.285 960.157C487.96 952.624 485.662 942.556 483.859 934.791C510.263 920.072 538.617 901.898 564.811 886.326L797.044 747.362Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1278.83 460.526C1280.31 461.728 1289.87 487.117 1291.76 491.296C1273.36 503.483 1250.57 515.042 1231.25 527.038C1147.83 578.839 1061.93 627.476 978.162 678.58L969.392 683.776L969.349 650.115C1071.39 586.385 1178.34 525.899 1278.83 460.526Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M90.6621 566.012C94.2425 567.739 115.922 585.196 120.908 588.956C144.752 606.934 168.463 623.812 193.672 639.907C279.732 694.853 371.914 737.515 455.181 796.902C457.255 805.975 461.882 818.644 464.919 827.744L456.302 821.837C437.304 809.215 412.935 793.127 392.689 783.515C308.973 743.771 230.258 701.308 157.306 643.444C130.213 621.955 102.537 601.283 76.0478 578.105C81.1274 573.239 85.0668 570.269 90.6621 566.012Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1276.97 343.922C1278.24 345.07 1284.96 362.277 1286.21 365.269C1271.33 378.179 1252.43 390.146 1236.17 401.458C1196.88 428.81 1155.67 452.679 1114.91 477.692C1068.35 506.266 1022.13 535.903 975.567 564.486L969.426 568.438L969.312 543.759C987.076 531.966 1006.12 521.007 1024.2 509.396C1097.52 462.302 1172.29 417.417 1244.13 368.024C1255.34 360.312 1265.94 351.871 1276.97 343.922Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M92.073 707.244C96.827 710.25 108.054 720.177 113.454 724.178C125.763 733.665 138.563 742.511 151.197 751.557C252.777 824.288 368.724 870.892 474.29 936.516C477.145 945.066 480.447 956.714 482.505 965.345L474.413 959.924C417.838 916.715 348.082 889.14 285.76 855.459C260.338 841.719 233.831 825.241 209.48 809.701C165.084 781.369 120.105 750.32 78.5487 717.975C82.4679 714.298 87.7255 710.538 92.073 707.244Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1278.91 423.435C1281.04 425.688 1286.56 441.72 1287.81 445.22C1260.55 459.216 1226.9 483.491 1199.93 499.704L976.397 634.607L969.635 638.524L969.638 614.354C976.112 610.606 983.222 605.713 989.667 601.682L1025.65 579.519L1125.76 517.752C1156.88 498.516 1189.21 480.238 1220.42 461.007C1240.34 448.74 1259.36 436.262 1278.91 423.435Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1277.32 383.851C1279.11 386.469 1285.26 403.4 1286.42 406.966C1247.12 436.113 1197.35 463.842 1155.47 489.164C1094.9 525.782 1034.48 562.538 974.788 600.595L969.632 604.061C969.216 595.803 969.345 587.057 969.34 578.749C985.442 569.917 1003.34 558.104 1019.1 548.208L1096.43 499.974C1157.19 462.339 1219.68 426.187 1277.32 383.851Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.018 644.025C798.153 645.984 797.717 664.168 797.697 667.478L490.319 853.219C488.322 854.41 484.175 857.184 481.944 856.791L481.351 855.179L476.3 837.531C550.982 790.866 627.053 746.037 702.297 700.274C733.407 681.354 765.234 661.666 797.018 644.025Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M796.144 713.972C797.169 714.023 796.659 713.897 797.588 714.689C798.143 720.767 797.863 729.708 797.825 736.041C782.372 746.246 763.437 756.647 747.252 766.178L704.245 792.073C685.865 802.946 667.108 813.601 648.921 824.75L528.827 896.917L497.329 915.851C494.328 917.646 483.987 924.921 481.059 923.763C479.578 917.212 478.162 912.409 476.125 905.996C491.621 896.09 507.834 886.696 523.541 877.046L668.598 789.446L744.023 744.402C761.137 734.168 778.593 723.339 796.144 713.972Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M797.64 679.311C798.227 682.105 797.864 697.514 797.82 701.35C786.406 709.726 763.622 722.011 750.562 729.739L665.998 780.086C647.975 790.673 485.471 890.39 480.91 890.217L480.102 888.511C478.566 883.691 476.899 878.8 475.309 873.988C489.856 863.025 514.844 848.467 530.871 838.655L631.938 777.669L723.655 722.582C747.011 708.427 773.636 691.801 797.64 679.311Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M91.5519 673.89C94.0596 674.424 103.861 682.738 106.766 684.98L136.633 707.935C143.937 713.582 151.332 719.396 158.81 724.823C198 753.261 236.647 783.513 279.107 806.966C319.861 829.477 362.019 848.87 403.394 870.089C425.017 881.179 445.701 894.414 466.887 906.253L472.42 924.781L462.864 918.825C442.691 905.435 423.47 895.715 402.129 884.387L315.476 838.814C229.524 793.403 152.982 746.575 77.734 684.331C81.0255 681.446 87.818 676.674 91.5519 673.89Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M90.3191 603.13C92.5802 603.689 114.003 621.952 118.142 624.953C179.105 672.678 242.2 718.726 311.635 753.489C335.205 765.524 359.003 776.963 382.617 788.933C395.682 795.556 407.921 803.048 420.577 810.087C436.39 818.88 451.715 831.588 467.306 839.637C468.645 843.999 475.978 862.421 471.238 864.567C468.558 864.134 467.138 862.414 465.033 860.548C460.124 856.525 455.213 852.33 450.246 848.404C394.909 804.664 330.579 776.139 269.507 741.688C222.574 715.213 175.837 685.643 130.831 655.876C112.798 643.948 93.8019 627.776 76.7684 614.098C80.6892 610.639 86.155 606.482 90.3191 603.13Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M661.488 287.464C666.79 287.508 683.545 291.363 689.038 292.6C735.859 303.144 783.592 321.731 823.292 349.114C849.832 367.42 877.716 395.337 890.122 425.594C893.947 434.925 896.091 444.606 897.907 454.483C890.221 451.644 871.851 440.831 863.779 436.415C836.913 363.545 745.72 332.104 682.551 298.555C675.873 295.009 668.394 291.864 662.044 287.825L661.488 287.464Z"/><path fill="#C3DEA2" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M466.427 378.102C473.667 381.407 486.484 389.411 494.354 393.581L495.094 396.757C506.731 448.249 551.905 472.032 595.063 494.104C629.895 511.917 665.547 527.413 700.781 544.266C700.963 544.388 701.145 544.509 701.327 544.631C701.124 544.64 700.921 544.649 700.718 544.658C613.241 536.538 468.049 479.249 466.427 378.102Z"/></svg>' },        // muted green
      { type: 'karte', label: 'Karte', color: '#4a5a7a', backgroundStyle: 'radial-gradient(ellipse at center, #5A6A8A 0%, #4a5a7a 30%, #3A4A6A 70%, #2A3A5A 100%)', icon: '<?xml version="1.0" encoding="utf-8" ?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="96" viewBox="0 0 128 96"><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M807.317 68.2765C820.431 67.1691 839.986 70.5919 851.168 77.146C871.678 89.1672 892.165 104.257 911.939 117.564L1058.95 217.842L1251.96 348.212L1305.11 383.997C1324.51 397.057 1348.69 408.252 1349.32 435.089C1349.98 463.165 1349.57 484.093 1323.01 500.326C1309.22 508.749 1294.33 516.538 1280.14 524.698L1187.81 577.679L969.575 704.01L725.739 844.823L635.963 896.542C611.948 910.372 588.598 928.335 560.366 930.79C544.542 932.596 524.547 929.561 510.257 922.328C502.731 918.519 493.633 911.938 486.43 907.014L445.147 878.285L326.803 796.265L137.69 665.856L69.5758 619.048C57.5273 610.719 46.0634 602.385 33.5897 593.767C14.6332 580.671 14.3808 550.176 18.0428 529.767C22.2786 506.161 54.0385 492.179 73.8552 480.614L173.588 423.356L475.458 248.277L683.605 128.121L741.28 95.2464C764.06 82.331 780.246 70.693 807.317 68.2765Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M936.748 147.946L937.77 147.891C942.322 150.05 964.642 165.687 970.563 169.585C1003.05 190.969 1035.2 213.353 1067.43 235.177L1243.46 354.268C1268.75 371.322 1294.36 387.897 1319.63 404.988C1334.95 415.342 1346.56 432.664 1336.1 450.727C1327.38 465.775 1313.25 471.674 1298.83 479.793C1289.65 484.984 1280.42 490.214 1271.27 495.454L1162.81 557.59L850.887 737.966L673.514 841.046L618.993 872.441C586.839 891.265 570.187 905.144 529.877 896.119C512.311 890.821 495.623 876.782 480.303 866.465L388.562 803.416L122.035 619.757L656.364 309.793L840.708 203.156C872.355 184.879 904.869 165.554 936.748 147.946Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1161.77 370.492C1173.22 372.496 1241.89 425.373 1258.54 433.493C1260.14 434.273 1266.07 438.028 1265.86 440.095C1258.27 445.232 1250.27 449.417 1242.35 454.007L1193.99 481.788L1046.72 566.731L555.865 847.933C552.887 846.965 529.695 830.843 524.649 827.513L477.564 796.522C472.543 793.186 452.343 781.095 451.831 776.897C453.513 774.571 455.582 773.347 458.048 771.919L1161.77 370.492Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M857.797 551.203C857.939 551.182 858.079 551.139 858.223 551.14C860.445 551.148 946.229 609.038 952.579 614.614C938.402 622.454 924.084 631.09 909.953 639.14L781.27 713.125L687.953 766.285C643.976 791.506 599.469 817.572 555.24 842.242C523.233 820.465 490.085 799.52 458.339 777.647L857.797 551.203Z"/><path fill="#6E8CB8" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1217.5 413.246C1221.19 414.057 1251.71 435.529 1256.75 439.034C1248.63 445.038 1229.83 455.136 1220.38 460.515L1161.49 494.461L957.758 611.648C947.806 603.009 929.553 591.892 917.834 584.298C927.179 578.035 942.554 570.31 952.873 564.431L1025.25 523.034L1217.5 413.246Z"/><path fill="#6E8CB8" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1162.36 376.583C1171.49 381.779 1183.81 390.4 1192.99 396.42C1177.54 404.066 1160 414.692 1144.91 423.314L1070.17 465.987L894.011 566.571C891.947 567.092 867.851 550.574 863.441 548.007C871.109 543.134 879.848 538.019 887.836 533.616C980.128 482.739 1070.04 427.356 1162.36 376.583Z"/><path fill="#BB6970" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1197.45 399.952C1199.96 399.929 1210.55 407.508 1213.43 409.42L913.375 580.978C911.734 580.31 899.704 572.175 897.439 570.669L1063.8 475.702L1149.75 426.579C1164.68 418.132 1182.32 407.534 1197.45 399.952Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M403.688 544.292C422.838 543.09 438.409 553.924 452.99 564.812C463.405 572.589 496.507 595.156 497.777 607.636C498.196 611.753 495.33 615.907 492.773 618.907C480.135 633.735 414.255 669.516 394.805 677.039C386.235 680.355 377.249 682.668 368.077 683.399C358.89 683.961 349.562 683.63 340.79 680.584C327.058 675.816 298.294 652.776 286.017 642.535C279.066 636.737 272.499 630.504 271.734 620.975C271.215 614.514 273.249 609.964 277.439 605.163C288.357 592.656 360.191 555.78 377.803 549.499C386.236 546.492 394.793 544.946 403.688 544.292Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M337.742 576.219C346.772 575.546 361.015 575.433 369.847 576.735C369.951 579.148 369.783 583.536 369.721 586.084C369.455 596.973 381.251 595.7 388.422 598.989C392.034 600.645 396.912 606.146 400.654 608.063C408.915 612.267 419.427 614.316 426.474 620.492C430.098 623.668 428.337 633.161 428.299 637.752C428.274 640.922 428.925 649.356 427.07 651.198C418.968 650.405 406.333 649.673 398.939 647.192C383.865 642.135 378.86 623.473 364.379 619.127C361.236 618.184 356.37 617.851 352.992 617.554C347.327 612.725 341.196 607.678 335.915 602.493C336.827 595.865 336.08 581.149 337.742 576.219Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M330.815 577.94L331.302 578.112C332.32 579.827 331.25 599.789 331.127 603.389C325.927 606.537 282.158 630.279 280.339 630.224C277.885 626.526 277.439 624.288 276.45 620.075C278.573 609.07 285.196 603.516 294.628 598.127C306.617 591.277 318.694 584.555 330.815 577.94Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M487.135 599.276C488.907 599.828 489.531 600.732 490.574 602.232C495.569 609.229 489.776 616.365 484.197 620.758C470.147 631.822 453.914 640.267 438.317 648.879C436.506 649.928 435.772 650.262 433.824 651.043L433.196 650.414C432.769 643.478 433.367 633.859 433.621 626.71C451.117 618.788 469.432 607.797 487.135 599.276Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M354.705 622.14C365.643 623.422 367.96 624.22 374.597 633.284C357.443 642.898 340.347 652.2 322.922 661.308L321.28 661.904C316.675 660.586 308.097 653.455 304.077 650.299C320.701 640.868 338.483 631.732 354.705 622.14Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M424.264 552.584C428.813 553.574 438.947 560.892 443.095 563.738C431.172 571.74 405.87 583.995 392.142 591.766C387.563 594.419 378.19 592.975 375.457 588.009C375.009 587.196 375.215 580.419 375.24 579.074C389.534 572.77 411.124 560.655 424.264 552.584Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M447.098 567.329C451.663 569.704 460.007 576.853 464.147 580.284C446.747 588.653 428.209 599.82 411.084 607.412C403.323 604.314 399.456 602.179 393.781 596.158C411.2 587.447 429.797 576.692 447.098 567.329Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M376.8 637.927C380.222 638.53 388.1 647.192 390.908 650.021C383.596 654.755 373.86 659.224 366.207 663.747C361.749 666.382 346.148 676.185 342.056 676.04C335.014 672.888 331.573 670.65 325.514 666.231C339.278 657.494 362.113 645.85 376.8 637.927Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M332.477 608.607C335.914 608.905 345.535 617.557 348.755 620.181C333.936 627.447 315.504 638.131 300.662 646.066C297.215 645.946 287.745 637.47 284.629 634.881C298.693 626.213 317.752 616.448 332.477 608.607Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M467.892 583.145C471.002 584.059 480.517 592.964 483.348 595.513C467.525 604.337 450.136 612.207 433.654 621.357L433.171 621.219C427.803 615.11 425.31 613.343 417.71 610.041C434.18 600.767 451.322 592.533 467.892 583.145Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M397.303 652.26C403.955 654.29 418.448 655.141 425.874 655.688C411.237 665.107 395.646 672.341 378.85 676.82C368.915 679.041 360.224 678.731 350.175 678.495C365.632 669.319 382.029 661.232 397.303 652.26Z"/><path fill="#C0BEB0" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M399.472 549.54C402.797 549.185 414.827 547.907 416.524 550.577C414.558 554.173 382.431 569.829 375.596 574.404C372.386 572.747 371.461 572.38 367.988 571.389C358.755 570.256 352.31 570.798 343.11 571.432C359.595 561.618 380.463 552.638 399.472 549.54Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M564.117 631.48C579.235 631.18 622.042 655.383 593.894 664.699C581.903 664.931 560.467 653.865 555.151 642.198C552.485 636.346 559.567 632.964 564.117 631.48Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M562.219 636.708C572.862 635.691 584.042 642.372 592.282 648.534C596.748 651.873 598.161 655.388 594.46 659.66C586.069 659.902 577.83 655.436 570.83 651.166C565.408 647.857 557.21 643.451 562.219 636.708Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M530.637 648.756C544.383 647.853 561.14 657.341 569.293 668.326C573.625 674.161 569.131 678.826 564.033 681.732C555.621 683.184 548.141 679.416 541.056 675.143C531.811 669.567 514.196 658.012 530.637 648.756Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M531.836 653.41C534.123 653.307 537.731 653.079 539.713 653.966C546.712 657.099 571.427 667.226 562.233 677.358C553.226 677.743 532.034 666.602 529.594 657.634C529.993 654.903 529.795 655.813 531.836 653.41Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M851.436 469.541C868.316 470.058 906.808 496.956 876.056 502.507C859.509 502.018 821.368 475.885 851.436 469.541Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M850.489 474.607C858.276 474.498 880.683 485.282 881.34 493.553C880.168 496.139 880.546 495.329 877.818 497.145C873.036 497.524 870.609 497.149 866.237 494.958C860.231 491.947 847.062 486.209 846.724 478.412C848.015 475.731 847.515 476.631 850.489 474.607Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M756.101 522.058C771.474 520.96 812.567 545.356 786.698 554.743C774.983 555.124 763.571 547.697 754.361 540.774C744.992 533.731 743.537 526.419 756.101 522.058Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M756.136 526.772C765.275 526.513 789.215 537.089 788.899 546.93C788.013 549.137 787.49 549.222 785.346 550.562C777.681 549.855 753.405 538.383 752.749 530.09C753.885 527.717 753.586 528.431 756.136 526.772Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M816.511 488.171C831.922 485.578 872.059 508.75 849.173 520.201C835.941 521.342 817.97 511.387 810.423 500.61C806.416 494.889 811.696 490.556 816.511 488.171Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M817.516 492.68C824.622 492.135 830.726 494.28 836.569 498.179C842.255 501.973 854.332 507.42 849.022 515.215C844.474 515.74 841.537 515.647 837.271 513.788C830.291 510.747 817.544 504.871 815.397 496.96C815.829 494.175 815.599 495.12 817.516 492.68Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M643.316 586.097C656.231 585.523 674.192 594.698 681.348 605.71C685.378 611.911 678.78 616.173 673.737 618.31C662.418 618.958 647.768 610.206 639.395 602.833C631.268 595.675 633.789 589.64 643.316 586.097Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M645.188 590.631C653.318 590.912 677.042 601.163 676.339 610.233C674.719 612.71 675.409 611.865 672.352 613.511C664.154 613.196 640.883 602.429 640.952 593.924C642.003 591.89 642.999 591.711 645.188 590.631Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M594.482 614.119C604.796 613.551 611.909 618.856 620.44 623.94C630.485 629.926 640.941 640.994 624.197 647.302C610.664 646.464 567.48 625.857 594.482 614.119Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M593.591 619.401C602.762 618.293 624.92 629.032 627.083 637.678C626.56 640.5 626.964 639.437 624.699 641.926C615.401 642.594 605.394 636.509 597.874 631.561C592.933 628.309 589.223 624.627 593.591 619.401Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M673.86 568.723C687.236 568.007 704.894 577.332 712.214 588.742C715.811 594.351 710.612 598.771 705.711 600.928C694.765 602.298 684.778 594.921 676.103 589.037C667.381 583.12 660.801 574.355 673.86 568.723Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M674.664 573.363C684.884 572.856 692.409 577.733 700.653 583.216C705.412 586.38 709.809 590.534 705.561 595.886C700.164 596.64 696.573 595.628 691.807 593.09C685.824 589.904 674.477 584.41 672.461 577.63C672.883 574.72 672.43 575.842 674.664 573.363Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M786.467 505.422C799.353 504.564 817.443 514.055 824.613 524.969C828.486 530.865 822.362 535.062 817.536 537.237C809.002 538.097 801.555 534.295 794.453 529.928C784.679 523.918 770.14 514.488 786.467 505.422Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M788.709 510.142C797.074 510.733 820.221 519.824 819.502 529.273C818.253 531.492 817.706 531.636 815.377 532.764C807.647 532.382 784.324 521.643 784.784 513.043C786.112 511.055 786.38 511.078 788.709 510.142Z"/><path fill="#302E2E" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M705.268 550.776C714.018 549.967 720.774 553.726 728.042 558.223C737.095 563.824 752.572 573.799 736.1 582.101C722.328 585.076 681.774 562.703 705.268 550.776Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M706.208 555.352C713.91 555.225 735.902 565.565 737.506 573.308C736.771 575.96 737.091 575.077 734.868 577.214C731.992 577.373 729.259 577.571 726.528 576.538C719.662 573.94 704.361 567.596 703.351 559.347C703.837 557.11 704.354 556.942 706.208 555.352Z"/><path fill="#616161" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M859.65 93.2116C861.365 93.7071 874.565 103.599 877.163 105.283C895.471 117.151 914.302 131.469 932.805 142.723L380.67 463.194L222.357 555.471C188.649 574.909 154.378 593.689 121.187 613.983C118.568 615.584 118.076 616.239 115.666 615.655C91.4549 598.361 65.7243 581.334 41.1063 564.473C48.0179 560.173 57.108 555.336 64.3181 551.185L122.889 517.534L350.607 386.197C520.316 288.254 688.719 189.186 859.65 93.2116Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M811.797 77.6227C829.227 78.2349 838.757 81.2249 853.447 90.359C817.495 108.799 776.147 133.728 740.498 154.079L512.515 285.725L239.825 443.644C179.643 478.303 117.287 513.093 57.7702 548.585L37.7528 560.049C25.7713 544.982 23.0862 532.467 36.4147 516.968C45.4604 506.45 64.7845 497.124 76.9363 490.154L132.206 458.238L295.315 364.073L606.183 183.909L718.359 119.382C733.43 110.786 748.655 102.216 763.673 93.5524C780.285 83.9691 792.381 78.8536 811.797 77.6227Z"/><path fill="#AAAAAA" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1338.12 464.556C1339.76 471.772 1325.9 486.742 1320.33 490.207C1313.14 494.678 1305.33 499.169 1297.98 503.414L1244.09 533.833L1089.55 622.993L593.037 910.515C571.488 922.752 537.442 925.981 514.703 913.64C502.47 907.002 488.5 896.428 476.77 888.336L406.144 839.196L256.809 736.167L123.547 644.238L70.6681 607.943C57.5625 598.927 37.4812 587.934 29.8121 574.277C28.0185 569.49 27.4902 567.155 26.9498 562.118C37.9678 572.775 50.817 581.317 63.4023 590.028L100.327 615.677L258.961 724.868L387.861 813.891C410.299 829.422 432.17 845.428 455.089 860.374C474.08 872.597 492.496 887.594 511.807 899.104C532.199 911.259 569.819 910.356 590.482 899.583C605.135 891.944 619.663 882.735 633.971 874.515L722.916 823.578L1035.32 641.778L1239.98 523.884L1296.55 491.535C1315.12 480.815 1321.41 479.201 1338.12 464.556Z"/></svg>' },    // muted blue  
      { type: 'zwischenrechnung', label: 'Zwischenrechnung', color: '#7a6a4a', textColor: '#F5E5C8', backgroundStyle: 'radial-gradient(ellipse at center, #8A7A5A 0%, #7a6a4a 30%, #6A5A3A 70%, #5A4A2A 100%)' } // muted orange/brown
    ];
    
    // Assign payment buttons to rightmost available positions
    for (let i = 0; i < Math.min(paymentButtons.length, bottomRowFullButtons.length); i++) {
      const button = paymentButtons[i];
      const cell = bottomRowFullButtons[i];
      
      cell.content = {
        isPaymentButton: true,
        paymentType: button.type,
        label: button.label,
        color: button.color,
        icon: button.icon,
        textColor: button.textColor,
        backgroundStyle: button.backgroundStyle
      };
      
      addLog('DEBUG', `Assigned payment button: ${button.label} at row ${cell.rowIndex}, col ${cell.columnIndex}`);
    }
  }

  let resizeObserver;
  let containerElement;
  
  onMount(() => {
    addLog('INFO', 'SelectionArea mounted, setting up resize observer');
    if (containerElement) {
      resizeObserver = new ResizeObserver(entries => {
        for (let entry of entries) {
          containerWidth = entry.contentRect.width;
          containerHeight = entry.contentRect.height;
        }
      });
      resizeObserver.observe(containerElement);
      
      setTimeout(() => {
        containerWidth = containerElement.clientWidth;
        containerHeight = containerElement.clientHeight;
      }, 100);
    }
    return () => resizeObserver?.disconnect();
  });

  wsStore.subscribe(state => {
    isConnected = state.isConnected;
    if (state.lastMessage?.command === 'getCategoriesResponse') {
      if (state.lastMessage.status === 'success' && Array.isArray(state.lastMessage.payload)) {
        categories = state.lastMessage.payload;
        status = categories.length > 0 ? '' : 'No categories found.';
      } else {
        status = 'Error: Could not load categories from backend.';
      }
    }
    if (state.lastMessage?.command === 'getItemsByCategoryResponse') {
      if (state.lastMessage.status === 'success' && Array.isArray(state.lastMessage.payload)) {
        products = state.lastMessage.payload;
        currentView = 'products';
        status = products.length > 0 ? '' : 'No products found in this category.';
      } else {
        status = 'Error: Could not load products from backend.';
      }
    }
  });

  onMount(() => {
    setTimeout(() => {
      if (isConnected) {
        status = 'Loading categories...';
        wsStore.send({ command: 'getCategories' });
      } else {
        status = 'Error: Not connected to backend.';
      }
    }, 500);
  });

  // Handle auto-collapse completion event
  onMount(() => {
    const handleAutoCollapseComplete = () => {
      addLog('INFO', 'Auto-collapse completed, returning to categories');
      currentView = 'categories';
      selectedCategory = null;
      consoleView.set('order'); // Switch back to order view
    };

    window.addEventListener('autoCollapseComplete', handleAutoCollapseComplete);

    // Cleanup on component destroy
    return () => {
      window.removeEventListener('autoCollapseComplete', handleAutoCollapseComplete);
    };
  });

  let gridRows = [];
  $: {
    const rows = [];
    const rowMap = new Map();
    gridCells.forEach(cell => {
      if (!rowMap.has(cell.rowIndex)) rowMap.set(cell.rowIndex, []);
      rowMap.get(cell.rowIndex).push(cell);
    });
    const maxRows = layoutType === '4-4-4' ? rectTotalRows : totalRows;
    for (let i = 0; i < maxRows; i++) {
      if (rowMap.has(i)) rows.push(rowMap.get(i).sort((a, b) => a.columnIndex - b.columnIndex));
    }
    gridRows = rows;
  }

  function handleCategoryClick(event) {
    const categoryData = event.detail.data;
    if (categoryData && categoryData.id) {
      selectedCategory = categoryData;
      status = 'Loading products...';
      wsStore.send({ 
        command: 'getItemsByCategory', 
        payload: { categoryId: categoryData.id } 
      });
    }
  }

  function handleProductClick(event) {
    const productData = event.detail.data;
    if (productData && productData.id) {
      // Always call addItem - it will handle initialization automatically
      orderStore.addItem(productData.id, 1, 1);
    }
  }

  function goBackToCategories() {
    currentView = 'categories';
    selectedCategory = null;
    products = [];
    status = '';
  }
  
  function toggleLayoutType() {
    layoutType = layoutType === '6-6-6' ? '4-4-4' : '6-6-6';
  }

  function handleTimeClick() {
    addLog('INFO', 'Time settings accessed');
    timeStore.resetTimeOffset();
    addLog('INFO', 'Time offset reset - using client time');
  }

  function formatTime(date) {
    const time = date.toLocaleTimeString('de-DE', {
      hour: '2-digit',
      minute: '2-digit'
    });
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    
    return `${time}\n${day}.${month}\n${year}`;
  }

  function handlePaymentClick(paymentType) {
    addLog('INFO', `Payment method selected: ${paymentType}`);
    
    // Get current order state
    let currentOrderState;
    orderStore.subscribe(state => currentOrderState = state)();
    
    if (currentOrderState.total <= 0) {
      addLog('WARNING', 'Cannot process payment: Order total is zero');
      return;
    }
    
    if (paymentType === 'bar' || paymentType === 'karte') {
      // Process payment through orderStore
      const paymentData = { 
        type: paymentType === 'bar' ? 'Bar' : 'Karte', 
        amount: currentOrderState.total 
      };
      orderStore.finishOrder(paymentData);
      addLog('SUCCESS', `Payment processed: ${paymentData.type} - ${paymentData.amount.toFixed(2)}€`);
    } else if (paymentType === 'zwischenrechnung') {
      // Interim receipt - just log for now
      addLog('INFO', 'Interim receipt requested');
      console.log('Interim receipt requested');
    }
  }

  // Единая функция сворачивания текущего заказа
  async function collapseCurrentOrder() {
    let currentOrderState;
    orderStore.subscribe(state => currentOrderState = state)();
    
    const hasItems = currentOrderState.items && currentOrderState.items.length > 0;
    const hasTable = currentOrderState.metadata && currentOrderState.metadata.table;
    const isActive = currentOrderState.status === 'active';
    const hasActiveTransaction = currentOrderState.transactionId;
    
    if (isActive && hasActiveTransaction && hasItems && hasTable) {
      // Есть активный заказ с товарами и столом - паркуем БЕЗ обновления времени
      addLog('INFO', `Collapsing order with table ${hasTable} without time update`);
      try {
        await orderStore.parkCurrentOrder(hasTable, 1, false); // updateTimestamp = false
        addLog('SUCCESS', 'Order collapsed successfully');
        await parkedOrdersStore.refresh();
      } catch (error) {
        addLog('ERROR', `Failed to collapse order: ${error.message}`);
        throw error;
      }
    } else if (isActive && hasActiveTransaction && hasItems && !hasTable) {
      // Есть заказ с товарами но БЕЗ стола - ПРИНУДИТЕЛЬНО требуем присвоение стола
      addLog('WARNING', 'Order has items but no table - forcing table assignment');
      throw new Error('FORCE_TABLE_ASSIGNMENT');
    } else if (hasActiveTransaction) {
      // Есть активный заказ без товаров - просто сбрасываем
      addLog('INFO', 'Resetting empty order');
      orderStore.resetOrder();
    }
  }

  async function handleTableClick() {
    // Always switch to orders view first
    consoleView.set('order');
    
    // Get current order state
    let currentOrderState;
    orderStore.subscribe(state => currentOrderState = state)();
    
    const hasItems = currentOrderState.items && currentOrderState.items.length > 0;
    const hasTable = currentOrderState.metadata && currentOrderState.metadata.table;
    const isActive = currentOrderState.status === 'active';
    const hasActiveTransaction = currentOrderState.transactionId;
    
    if (isActive && hasActiveTransaction && (hasItems || hasTable)) {
      // Есть активный заказ - сворачиваем и возвращаемся к стартовому состоянию
      addLog('INFO', 'Collapsing current order and returning to start position');
      try {
        await collapseCurrentOrder();
        
        // Возврат к стартовому состоянию кассы
        orderStore.resetOrder();
        currentView = 'categories';
        selectedCategory = null;
        addLog('INFO', 'Returned to start position');
      } catch (error) {
        if (error.message === 'FORCE_TABLE_ASSIGNMENT') {
          // Заказ с товарами но без стола - принудительно открываем пинпад с автосворачиванием
          addLog('INFO', 'Forcing table assignment for order with items (will auto-collapse)');
          pinpadStore.activateTableEntryWithAutoCollapse();
          return; // Не возвращаемся к стартовому состоянию, ждем присвоения стола
        } else {
          addLog('ERROR', `Failed to handle table click: ${error.message}`);
        }
      }
    } else if (!hasActiveTransaction) {
      // Нет активного заказа - инициализируем новый неинициализированный заказ для ввода стола
      addLog('INFO', 'No active order - initializing new order for table entry');
      try {
        await orderStore.initializeOrder(1, {});
        addLog('INFO', 'Order initialized, activating pinpad for table number entry');
        pinpadStore.activateTableEntry();
      } catch (error) {
        addLog('ERROR', `Failed to initialize order: ${error.message}`);
      }
    } else {
      // Активный заказ без товаров и стола - открываем пинпад для ввода стола
      addLog('INFO', 'Activating pinpad for table number entry');
      pinpadStore.activateTableEntry();
    }
  }

  function handleGeminiClick() {
    consoleView.set('agent');
    pinpadStore.activateAlphaInput(
      (inputValue) => {
        // TODO: Send inputValue to the Gemini agent
        addLog('INFO', `User input for Gemini: ${inputValue}`);
      },
      () => {
        addLog('INFO', 'Gemini input cancelled.');
      }
    );
  }

  function handleKeyboardToggle() {
    if ($pinpadStore.isActive) {
      pinpadStore.deactivate();
      addLog('INFO', 'Keyboard closed');
    } else {
      pinpadStore.activateAlphaInput(
        (inputValue) => {
          addLog('INFO', `Keyboard input: ${inputValue}`);
        },
        () => {
          addLog('INFO', 'Keyboard input cancelled.');
        }
      );
      addLog('INFO', 'Keyboard opened');
    }
  }

  function handleSecondaryAction(event) {
    const { data, mouseX, mouseY } = event.detail;
    if (data && !data.isBackButton) {
      contextMenuItem = data;
      contextMenuX = mouseX;
      contextMenuY = mouseY;
      contextMenuVisible = true;
    }
  }

  function handleContextMenuClose() {
    contextMenuVisible = false;
    contextMenuItem = null;
  }

  function handleContextMenuEdit(event) {
    const { item } = event.detail;
    console.log('Edit item:', item);
    // TODO: Implement edit functionality - open edit dialog/modal
    // For now, just log the item to console
    const itemType = item.category_names ? 'Category' : 'Product';
    addLog('INFO', `Edit requested for: ${item.id} - ${itemType}`);
  }

  // Universal button rendering function
  function getButtonProps(cell) {
    const shape = layoutType === '6-6-6' ? 'hex' : 'rect';
    const isHalf = cell.type.includes('half');
    const side = cell.type.includes('left') ? 'left' : (cell.type.includes('right') ? 'right' : '');
    
    let width, height;
    if (layoutType === '6-6-6') {
      width = isHalf ? optimalHexWidth / 2 - HEX_BUTTON_GAP / 2 : optimalHexWidth;
      height = optimalHexHeight;
    } else {
      width = cell.width || rectButtonWidth;
      height = cell.height || rectButtonHeight;
    }
    
    return { shape, side, width, height };
  }

  function getButtonContent(cell) {
    if (cell.isPinpadTrigger) return { isPinpadTrigger: true };
    if (cell.isTableButton) {
      return { 
        icon: `<?xml version="1.0" encoding="utf-8" ?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="128" height="96" viewBox="0 0 128 96"><path fill="#312E2B" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M657.249 45.5326C661.809 44.9168 674.909 47.1424 679.872 47.8092L732.69 55.4381C800.705 65.1855 868.927 73.974 936.595 85.9405C1052.09 106.364 1167.06 129.61 1280.79 158.382C1293.38 161.569 1309.98 164.895 1321.49 170.599C1324.6 172.14 1323.03 212.195 1322.96 216.805C1317.16 219.727 1306.52 222.701 1300.01 224.708L1257.97 237.319L1130.3 276.416L899.334 347.199L803.807 376.657C787.511 381.667 770.045 387.867 753.759 391.908L753.502 400.777C773.208 410.24 765.714 426.758 751.438 436.493C754.672 454.83 760.404 477.222 766.292 495.043C778.312 531.425 788.232 547.55 775.428 586.479C793.644 611.173 788.351 632.852 778.653 658.961C787.232 666.586 790.02 670.215 791.077 681.45C816.727 679.381 846.371 680.664 871.117 688.624C896.232 697.171 921.595 711.801 943.908 726.18C987.586 754.326 1018.17 778.997 1072.77 768.261C1079.02 771.023 1095.27 781.56 1100.36 786.271C1100.42 792.121 1102.19 817.606 1098.13 820.178C1090.59 824.961 1075.24 828.435 1066.09 830.014C1026.48 836.849 984.219 830.616 947.21 815.373C903.854 796.249 890.566 784.975 842.244 781.116C874.83 831.877 906.209 889.241 960.618 920.012C970.24 925.454 980.474 930.082 990.275 935.297C991.235 941.66 992.421 969.949 989.016 974.859C982.424 979.02 920.144 989.34 910.409 990.417C891.68 982.492 859.397 965.44 844.008 953.414C822.81 936.804 809.128 922.88 792.581 901.291C771.86 874.258 756.399 849.065 728.483 828.685C709.892 832.319 688.586 833.255 669.549 831.452C646.125 829.234 618.374 825.196 598.494 811.371C593.269 807.737 589.282 802.843 585.24 798.042C553.887 805.691 525.245 819.378 497.608 835.771C474.784 849.308 452.002 863.701 427.523 874.18C398.834 886.461 367.611 893.439 336.763 897.587C325.42 899.112 313.771 899.376 302.513 900.919C297.191 897.145 279.362 881.142 273.369 875.976C272.239 864.432 272.049 850.606 272.646 839.051C272.945 833.27 288.443 833.361 293.319 832.373C329.846 824.972 357.628 805.289 386.466 782.888C410.121 764.513 433.906 747.931 459.941 733.052C460.128 730.331 460.85 706.908 463.218 706.014C467.046 704.569 477.641 704.496 482.581 704.061C512.165 701.457 535.516 683.606 561.036 670.641C571.404 665.423 582.207 666.893 593.593 660.02C579.677 635.479 573.135 610.932 594.816 588.27C582.616 563.27 588.1 529.223 598.913 504.722C611.77 475.589 613.546 463.845 614.222 432.534C598.269 422.101 596.589 405.793 614.366 396.46C614.916 389.423 615.173 383.967 615.187 376.913C601.03 371.777 575.26 366.981 559.569 363.156L455.12 337.098L149.251 259.442L78.6884 241.856C70.8122 239.899 47.2998 234.635 41.3126 231.387C41.1346 216.556 41.2485 201.692 41.3079 186.857C52.606 182.381 74.5142 177.545 86.9381 174.175L188.572 147.241C344.279 107.555 499.183 74.6893 657.249 45.5326Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M420.229 124.166C424.763 124.387 448.286 130.465 454.175 131.795L556.452 155.95L957.321 252.581C949.04 255.627 938.05 258.529 929.375 261.058L886.853 273.626L854.033 283.277C845.312 285.83 836.648 289.668 827.72 287.599C816.05 284.384 803.289 281.652 791.4 278.686L695.251 254.949L425.023 187.912L321.344 162.553C310.289 159.791 298.633 157.77 287.78 154.656C291.796 153.246 300.364 151.569 304.85 150.555L337.183 143.199C362.773 137.305 394.744 128.962 420.229 124.166Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M265.311 160.166C271.96 159.128 330.655 174.855 340.205 177.175L614.2 245.123L754.377 279.532L791.082 288.479C798.826 290.304 808.42 292.26 815.884 294.598C798.173 298.797 777.535 306.024 759.539 310.801C751.938 312.819 725.345 320.341 719.054 323.255L708.348 320.687L340.92 233.906C278.558 219.097 214.755 204.895 152.712 189.304C178.812 181.738 205.403 175.185 231.74 168.482C242.918 165.638 254.014 162.53 265.311 160.166Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M559.563 94.147C564.323 93.0834 660.812 115.531 674.236 118.506L1032.02 198.855C1052.72 203.552 1074.42 207.6 1094.86 212.553C1086.19 214.072 1075.33 217.458 1066.87 220.121C1037.65 229.314 1007.69 237.298 978.575 246.67C975.46 247.822 967.588 244.868 963.832 244.007C919.197 233.783 874.677 223.11 830.203 212.212L620.593 161.84L486.932 129.495C472.482 126.135 458.327 122.4 443.789 119.363C482.366 111.803 520.981 102.191 559.563 94.147Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M663.851 71.5367C665.361 71.3618 679.991 73.6973 682.831 74.1066L737.389 81.9234C870.666 100.961 1003 122.298 1134.39 151.955C1166.22 159.141 1198.22 165.349 1230.05 172.81L1135.38 200.78C1109.48 208.026 1113.44 210.356 1086.54 204.395L1054.04 197.176L929.57 168.933L577.539 90.2681C586.12 88.0049 598.001 85.7609 606.831 83.8393L663.851 71.5367Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M52.4513 194.985L436.98 287.312L600.468 326.447C638.618 335.571 678.926 345.626 717.219 353.656C717.103 366.111 717.561 379.259 717.876 391.766C706.809 388.47 691.336 385.371 679.717 382.553L609.544 365.177L396.545 311.727L183.856 257.687C140.964 246.728 95.9731 233.944 52.5878 225.461L52.4513 194.985Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1310.72 180.02L1312.21 180.469C1313.6 183.901 1312.7 204.674 1312.59 209.673L972.38 314.284L809.82 364.294C783.127 372.669 754.979 381.051 728.641 390.189L727.572 390.487L726.69 389.944C725.828 385.97 726.31 359.443 726.343 353.678C780.964 338.681 833.379 322.736 887.61 306.745L1135.88 232.703L1254.47 197.077C1273.01 191.51 1292.19 185.212 1310.72 180.02Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M620.114 722.96C621.643 722.623 620.891 722.602 622.444 723.12C622.867 725.606 622.77 728.103 622.741 730.616C622.549 747.337 622.764 764.048 622.959 780.768C574.546 786.74 534.079 802.224 492.118 826.937C470.122 839.891 454.766 850.731 430.89 861.276C391.069 878.863 355.524 885.432 312.749 890.15C311.688 890.079 311.162 889.92 310.105 889.696C308.486 886.724 309.07 870.789 309.026 866.203C324.133 863.927 337.868 861.939 352.201 856.167C380.696 844.692 405.167 824.332 429.815 806.373C466.157 779.894 502.481 755.26 544.832 739.046C570.655 729.159 593.12 726.328 620.114 722.96Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M755.632 719.582C759.625 719.872 768.079 724.301 771.796 726.34C819.586 752.549 842.732 804.289 872.235 847.142C890.079 873.06 910.745 897.364 935.687 916.069C947.219 924.716 960.753 930.875 973.602 936.757C959.182 938.338 932.528 943.624 918.021 946.509L912.07 947.576C834.474 912.334 812.96 855.779 766.927 789.626C750.539 766.074 724.326 742.584 700.665 726.352C718.289 725.658 738.197 722.499 755.632 719.582Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M821.485 710.951C852.221 708.347 884.956 714.537 913.942 725.293C972.374 746.977 1021.52 805.461 1087.66 797.013C1087.77 802.462 1087.59 807.786 1087.45 813.229C1076.76 817.434 1064.81 820.253 1053.41 821.475C1042.39 823.549 1026.8 822.585 1015.73 821.763C980.762 819.165 951.792 807.816 920.817 791.886C894.666 778.436 866.437 771.502 836.685 771.166C825.545 759.691 814.844 746.427 802.755 735.623C797.587 731.005 791.851 727.062 786.278 722.925L789.31 713.634C798.939 711.881 811.533 711.47 821.485 710.951Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M95.0261 182.731C116.32 188.557 143.894 194.249 165.886 199.507L336.593 239.863C463.935 270.042 589.06 301.282 717.095 328.91C716.776 335.187 716.731 340.867 716.734 347.147L693.992 341.791L236.058 231.946L124.738 205.043C108.661 201.222 80.3098 195.452 65.5004 190.665C75.2858 188.495 85.3474 185.473 95.0261 182.731Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1242.09 176.022C1246.73 175.263 1270.04 181.6 1275.54 183.259C1254.38 190.189 1230.21 196.641 1208.62 203.142L1064.07 246.452L750.487 339.919L725.918 347.386C725.795 341.295 725.242 334.403 724.878 328.261C746.736 321.377 770.936 314.995 793.127 308.485L933.459 267.212L1242.09 176.022Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M695.761 732.899C698.958 734.483 712.611 744.804 715.668 747.23C729.167 757.941 744.621 772.529 755.221 786.186C787.884 828.27 809.688 877.966 848.808 915.216C866.973 932.513 884.689 942.08 906.427 953.803L906.598 978.022C900.462 975.576 890.438 969.456 884.299 966.347C846.518 947.216 820.24 921.727 795.688 887.524C783.05 869.918 767.037 848.738 751.184 833.937C734.45 818.313 717.172 808.794 696.339 799.489C696.318 777.179 696.242 755.209 695.761 732.899Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M721.095 444.994C721.74 445.951 722.488 454.614 722.652 456.155C726.459 492.003 735.831 527.197 736.827 563.335C737.231 577.963 735.255 592.56 733.562 607.055C722.914 610.092 708.005 611.509 697.122 612.546L680.464 612.967C680.5 557.644 681.317 502.652 682.432 447.351C696.986 447.433 706.687 446.824 721.095 444.994Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M588.97 703.586C592.193 702.961 593.261 703.162 596.019 704.836C602.414 708.718 608.959 712.255 615.652 715.589C587.132 719.987 564.868 722.86 537.899 733.847C487.857 754.234 447.162 785.188 403.854 816.655C374.626 837.891 351.185 853.806 314.422 857.743L307.052 858.553C302.182 853.699 294.161 848.511 288.373 843.907C329.143 834.493 345.626 825.568 379.086 800.995C405.009 781.956 434.016 759.932 461.361 743.611C498.258 721.589 546.592 708.861 588.97 703.586Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M656.567 55.6023L657.409 56.0937C658.357 58.7556 658.624 62.7661 658.951 65.7059C648.279 68.4296 634.069 70.7138 622.84 73.1663L548.785 89.7786L421.401 116.86C365.061 129.132 307.868 142.451 251.912 156.318L189.659 172.309C176.034 175.866 154.816 180.662 142.643 186.858C135.351 185.074 127.925 183.428 120.601 181.743L109.615 178.989C138.051 170.406 167.393 163.831 196.055 156.061C269.859 136.053 343.689 119.588 418.358 103.459L572.15 71.6785C600.203 66.1278 628.345 60.0544 656.567 55.6023Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M641.252 442.601C651.714 444.866 665.945 446.234 676.615 446.787C674.816 501.128 674.068 558.424 674.324 612.834C668.364 612.485 664.376 612.049 658.469 611.15C649.594 610.454 637.87 606.792 629.491 604.056C614.818 567.2 630.007 517.652 637.813 480.931C640.232 469.556 641.017 454.215 641.252 442.601Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M779.771 683.251L780.189 683.675C782.095 688.866 779.558 711.114 778.917 718.025C773.337 715.781 763.388 710.909 757.152 709.766C754.879 709.349 750.562 710.192 748.108 710.627C728.234 714.151 708.361 716.06 688.207 717.135C687.095 728.218 687.256 743.7 687.278 754.971L687.426 804.224C674.376 804.095 628.242 800.449 618.913 792.637L619.421 791.906C623.154 791.049 628.538 791.264 632.492 791.258L632.413 764.037L632.055 714.12C616.543 703.199 603.123 701.101 591.994 688.284L592.961 686.224L591.622 687.785L592.656 686.119C598.33 688.363 604.868 693.598 610.447 695.701C653.524 711.939 743.875 715.997 779.771 683.251Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M664.251 55.7541C678.423 56.86 695.972 59.9207 710.308 62.0055L786.469 72.8571C956.427 96.3677 1125.44 129.586 1291.79 171.529C1294.06 172.1 1299.71 173.229 1301.11 174.721L1299.5 175.508C1294.67 177.05 1289.66 178.259 1284.75 179.518C1239.2 166.941 1193.07 157.955 1146.99 147.874C1077.42 132.657 1006.92 117.785 936.707 105.858C880.631 96.3334 823.473 88.363 767.235 79.4483C733.541 74.1072 699.31 70.5312 665.388 65.1981L664.251 55.7541Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M741.293 440.823L742.032 441.489C743.797 453.106 745.759 463.677 748.938 475.167C759.976 515.06 783.511 554.87 759.018 595.046C757.125 598.151 753.202 599.511 749.999 600.849L739.398 605.053C747.375 570.283 741.722 537.06 736.002 502.546C732.709 482.673 729.837 463.831 727.609 443.81C732.443 442.945 736.55 441.983 741.293 440.823Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M740.782 627.401L742.483 627.433C743.589 628.955 743.434 634.97 743.514 637.103C744.102 652.789 740.595 665.161 732.34 678.439C714.667 682.864 699.742 683.749 681.667 683.92C681.008 683.885 680.289 683.622 679.619 683.435C677.903 679.541 678.966 642.68 679.046 635.734C701.614 635.101 719.044 633.384 740.782 627.401Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M616.749 624.704C634.624 630.932 653.104 633.848 671.905 635.496C671.874 642.688 673.212 680.551 671.078 683.5C652.601 680.996 644.274 679.981 626.619 673.917C624.77 670.297 622.135 666.382 620.119 662.516C613.933 650.652 614.449 637.569 616.749 624.704Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M623.958 437.215C627.785 438.603 631.93 439.914 635.811 441.219C634.967 495.424 605.538 545.766 622.048 601.195C620.497 600.763 618.368 599.559 616.879 598.795C590.594 580.935 596.423 537.379 607.437 512.274C620.805 481.804 623.782 469.698 623.958 437.215Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M771.255 666.621C774.318 668.48 775.015 669.241 777.545 671.722C758.119 712.073 629.311 705.553 597.329 681.511C590.028 673.756 594.335 671.366 601.551 667.225C617.676 686.827 679.013 692.009 703.192 689.554C723.014 687.542 757.739 682.458 771.255 666.621Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M768.644 596.376C770.632 596.972 771.032 598.024 771.772 599.683C771.556 603.803 768.539 607.312 765.202 609.468C726.979 634.172 636.377 636.608 600.992 607.958C598.683 604.721 596.916 601.74 599.454 597.963C603.874 596.325 605.189 600.445 608.42 602.563C643.104 625.302 739.083 626.124 768.644 596.376Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M976.922 944.167C978.571 943.955 978.602 943.792 980.078 944.455C982.004 947.947 981.067 962.735 981.002 967.555L919.234 978.759C917.852 979.071 917.917 979.012 916.51 978.736C914.399 974.99 915.197 959.904 915.249 954.984C933.902 952.829 958.336 947.841 976.922 944.167Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M614.17 407.026C615.452 407.807 619.189 411.832 620.817 412.992C623.518 414.918 628.808 417.37 632.018 418.571C665.01 430.299 704.507 429.811 737.862 419.912C747.567 417.032 748.197 412.212 752.712 410.336L754.126 411.177C755.726 414.35 755.053 417.322 754.164 420.527C732.62 444.282 651.417 440.182 624.027 426.407C615.395 422.066 609.366 416.936 614.17 407.026Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M774.412 609.189C781.051 615.742 773.659 642.773 770.556 650.932C764.339 667.277 758.257 668.853 743.354 675.297C742.389 674.107 744.728 668.486 745.413 666.631C750.508 652.823 750.557 639.171 748.648 624.721C758.268 621.135 767.664 617.17 774.412 609.189Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M641.258 383.544C653.465 386.229 664.999 388.938 677.105 392.038C677.243 401.961 677.199 411.457 677.055 421.365C665.818 420.931 651.853 417.985 640.94 415.364L641.258 383.544Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M596.678 795.928C608.545 796.203 625.876 804.348 638.695 806.761C655.572 809.937 672.5 811.399 689.66 811.139C696.737 811.032 711.109 816.536 715.42 821.118C687.452 824.996 615.436 820.02 596.678 795.928Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M580.188 675.508L581.46 675.494C583.776 678.273 579.785 685.082 585.455 694.253C577.261 696.485 561.604 698.03 551.751 700.191C523.131 706.471 501.262 713.801 474.825 725.257C473.354 726.018 472.844 726.487 471.227 726.194C469.77 723.937 470.91 718.362 471.224 715.376C492.853 715.385 519.52 707.057 538.103 696.08C552.368 687.655 563.264 678.408 580.188 675.508Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M683.607 393.549L719.562 400.983C719.59 405.052 720.527 413.769 719.288 417.675C719.028 418.492 718.198 418.433 717.016 418.771C704.695 420.821 696.355 421.265 683.742 421.799C683.389 412.768 683.05 402.52 683.607 393.549Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M801.597 690.948C829.327 688.55 865.078 696.285 890.612 707.203C886.863 706.625 882.157 705.512 878.369 704.73C845.464 699.93 823.801 700.398 790.465 703.779C790.687 699.892 790.686 695.733 790.748 691.815L801.597 690.948Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M593.423 609.771C594.502 610.503 597.482 613.409 599.077 614.602C603.189 617.681 606.383 619.284 610.893 621.565L610.763 622.069C606.498 639.309 608.892 654.749 617.826 669.801C615.262 669.181 613.141 667.974 610.769 666.802C599.251 648.997 586.795 632.152 593.423 609.771Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M1070.51 779.664C1075.74 780.699 1085.68 785.983 1090.57 788.493C1077.83 790.82 1069.98 790.063 1057.59 787.916C1050.56 786.337 1041.41 784.569 1035.15 781.26C1046.42 781.142 1059.43 781.246 1070.51 779.664Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M282.9 852.231C286.022 853.329 296.217 861.873 299.229 864.317L299.261 884.393C295.513 882.17 286.596 873.322 283.246 870.092C283.284 864.045 283.102 858.268 282.9 852.231Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M624.936 379.015L635.404 381.942C634.891 390.625 635.121 405.552 634.018 413.256C630.293 411.756 626.404 409.313 623.34 406.708C625.179 395.523 625.184 390.478 624.936 379.015Z"/><path fill="#cd853f" transform="matrix(0.0937729 0 0 0.09375 3.05176e-05 0)" d="M743.298 395.403C743.563 395.671 744.025 396.335 744.073 396.699C746.048 411.811 739.731 412.997 727.737 416.59L726.893 416.151C726.136 412.914 726.461 404.344 726.489 400.614C732.119 399.14 737.756 397.208 743.298 395.403Z"/></svg>`, 
        onClick: handleTableClick, 
        active: true,
        disabled: false,
        color: '#3E2723', // Much darker wood color
        textColor: '#F5DEB3', // Warm beige text
        backgroundStyle: 'radial-gradient(ellipse at center, #4A2F2A 0%, #3E2723 30%, #2E1A16 70%, #1A0F0D 100%)'
      };
    }
    if (!cell.content) return { disabled: true };
    if (cell.content.isBackButton) return { icon: '←', onClick: goBackToCategories, active: true };
    if (cell.content.isLayoutToggle) return { icon: cell.content.icon || '', onClick: toggleLayoutType, active: true, showShape: cell.content.showShape };
    if (cell.content.isSmartNavigation) return { 
      icon: '', 
      onClick: handleSmartAction, 
      active: true, 
      showShape: 'double-arrow-down' 
    };
    if (cell.content.isTimeButton) return { 
      label: formatTime($currentTime), 
      onClick: handleTimeClick, 
      active: true, 
      color: '#2c2c2e',
      textColor: '#666',
      customStyle: 'font-size: 12px; font-weight: 600; line-height: 1.2; white-space: pre-line; text-align: center;'
    };
    if (cell.content.isBetrugerCap) return {
      isBetrugerCap: true,
      label: cell.content.label,
      icon: cell.content.icon,
      color: cell.content.color,
      onClick: handleGeminiClick,
      active: true
    };
    if (cell.content.isKeyboardToggle) return {
      isKeyboardToggle: true,
      label: cell.content.label,
      icon: cell.content.icon, 
      color: cell.content.color,
      onClick: handleKeyboardToggle,
      active: $pinpadStore.isActive
    };
    if (cell.content.isPaymentButton) {
      const hasOrder = $orderStore.total > 0 && $orderStore.status === 'active';
      const buttonProps = { 
        label: cell.content.label, 
        onClick: hasOrder ? () => handlePaymentClick(cell.content.paymentType) : undefined, 
        active: hasOrder, 
        disabled: !hasOrder,
        paymentButton: true,
        color: hasOrder ? cell.content.color : '#666',
        icon: cell.content.icon,
        textColor: hasOrder ? cell.content.textColor : undefined,
        backgroundStyle: hasOrder ? cell.content.backgroundStyle : undefined
      };
      return buttonProps;
    }
    
    // Regular category/product buttons are always enabled (auto-reset handles finished state)
    const isCategory = currentView === 'categories';
    const label = isCategory 
      ? JSON.parse(cell.content.category_names).de || 'Unnamed'
      : JSON.parse(cell.content.display_names).menu.de || 'Unnamed Product';
    const onClick = isCategory ? handleCategoryClick : handleProductClick;
    
    return { 
      label, 
      data: cell.content, 
      onClick,
      active: true
    };
  }
</script>

<div class="selection-area" bind:this={containerElement}>
  
  {#if $pinpadStore.isActive}
    <div class="pinpad-overlay">
      <div class="pinpad-container">
          <Pinpad onClose={() => pinpadStore.deactivate()} />
      </div>
    </div>
  {/if}


  <ContextMenu 
    item={contextMenuItem} 
    x={contextMenuX} 
    y={contextMenuY} 
    visible={contextMenuVisible} 
    on:close={handleContextMenuClose}
    on:edit={handleContextMenuEdit}
  />

  
  <div class="grid-container">
    {#if status}
      <p class="status-message">{status}</p>
    {:else}
      <div class="grid-container-unified" 
           class:hex={layoutType === '6-6-6'} 
           class:rect={layoutType === '4-4-4'} 
           style="
             --optimal-hex-height: {optimalHexHeight}px; 
             --hex-vertical-padding: {HEX_VERTICAL_PADDING}px;
             --rect-vertical-padding: {RECT_VERTICAL_PADDING}px;
           ">
        {#each gridRows as row, rowIndex}
          <div class="button-row" class:hex-row={layoutType === '6-6-6'} class:rect-row={layoutType === '4-4-4'}>
            {#each row as cell (`${cell.id}-${layoutType}-${optimalHexWidth || rectButtonWidth}-${optimalHexHeight || rectButtonHeight}`)}
              {#if cell.isPinpadTrigger}
                <UniversalButton {...getButtonProps(cell)} on:click={() => pinpadStore.activate('general', null, null)}>
                  <PinpadPreview />
                </UniversalButton>
              {:else}
                {@const content = getButtonContent(cell)}
                {#if content.isPinpadTrigger}
                  <UniversalButton {...getButtonProps(cell)} on:click={() => pinpadStore.activate('general', null, null)}>
                    <PinpadPreview />
                  </UniversalButton>
                {:else if content.paymentButton}
                  <UniversalButton {...getButtonProps(cell)} label={content.label} active={content.active} disabled={content.disabled} color={content.color} icon={content.icon} textColor={content.textColor} backgroundStyle={content.backgroundStyle} on:click={content.onClick} />
                {:else if content.isBetrugerCap}
                  <UniversalButton {...getButtonProps(cell)} label={content.label} icon={content.icon} color={content.color} active={content.active} on:click={content.onClick} />
                {:else if content.isKeyboardToggle}
                  <UniversalButton {...getButtonProps(cell)} label={content.label} icon={content.icon} color={content.color} active={content.active} on:click={content.onClick} />
                {:else if content.label && !content.data}
                  <UniversalButton {...getButtonProps(cell)} label={content.label} active={content.active} disabled={content.disabled} color={content.color} textColor={content.textColor} backgroundStyle={content.backgroundStyle} on:click={content.onClick} />
                {:else if content.disabled}
                  <UniversalButton {...getButtonProps(cell)} disabled={true} />
                {:else if content.icon !== undefined || content.showShape}
                  <UniversalButton {...getButtonProps(cell)} icon={content.icon} active={content.active} showShape={content.showShape} color={content.color} textColor={content.textColor} backgroundStyle={content.backgroundStyle} on:click={content.onClick} />
                {:else if content.label}
                  <UniversalButton {...getButtonProps(cell)} label={content.label} data={content.data} active={content.active} on:click={content.onClick} on:secondaryaction={handleSecondaryAction} />
                {/if}
              {/if}
            {/each}
          </div>
        {/each}
      </div>
    {/if}
  </div>
</div>

<style>
  .selection-area {
    background-color: #4a4a4a;
    padding: 0;
    height: 100%;
    box-sizing: border-box;
    overflow: hidden;
    border-radius: 8px;
    position: relative;
    display: flex;
    flex-direction: column;
  }
  
  
  .grid-container {
    flex: 1;
    overflow: hidden;
  }
  
  .status-message {
    color: #fff;
    font-style: italic;
    text-align: center;
    margin: 32px;
  }
  
  .grid-container-unified {
    height: 100%;
    overflow: hidden;
  }
  
  .grid-container-unified.hex {
    padding: var(--hex-vertical-padding, 0px) 0px; 
  }
  
  .grid-container-unified.rect {
    padding: var(--rect-vertical-padding, 6px) 0px;
  }
  
  .button-row {
    display: flex;
    justify-content: center;
    gap: 6px;
    padding: 0;
  }
  
  .button-row.hex-row {
    margin-bottom: calc(-1 * var(--optimal-hex-height, 121px) * 0.25 + 6px);
  }
  
  .button-row.rect-row {
    margin-bottom: 6px;
  }
  
  .button-row.rect-row:last-child {
    margin-bottom: 0;
  }
  
  
  
  .pinpad-overlay {
    position: absolute;
    bottom: 8px;
    left: 8px;
    z-index: 100;
    transform-origin: bottom left;
    animation: expand 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }

  .pinpad-container {
    background-color: rgba(58, 58, 58, 0.95);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    position: relative;
  }
  

  @keyframes expand {
    from {
      transform: scale(0.1);
      opacity: 0;
    }
    to {
      transform: scale(1);
      opacity: 1;
    }
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/app.css ---

/* Set the base font size for the entire application */
html {
  font-size: 16px; /* 1rem = 16px on standard screens */
}

/* Media query for smaller desktop screens or large tablets */
@media (max-width: 1200px) {
  html {
    font-size: 15px;
  }
}

/* Media query for tablets */
@media (max-width: 992px) {
  html {
    font-size: 14px;
  }
}

/* Media query for smaller devices */
@media (max-width: 768px) {
  html {
    font-size: 13px;
  }
}

/* Global styles */
body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

--- File: /packages/client-desktop/src/renderer/src/lib/LayoutManager.svelte ---

<script>
  import { onMount } from 'svelte';
  import { wsStore } from './wsStore.js';

  let layouts = [];
  let selectedLayoutId = null;
  let newLayoutName = '';
  let status = 'Loading layouts...';

  // Subscribe to WebSocket store updates
  $: if ($wsStore.lastMessage) {
    handleWebSocketMessage($wsStore.lastMessage);
  }

  function handleWebSocketMessage(message) {
    if (!message || !message.command) return;

    switch (message.command) {
      case 'listLayoutsResponse':
        if (message.payload && Array.isArray(message.payload) && layouts.length === 0 && status === 'Loading layouts...') {
          if (message.status === 'success') {
            layouts = message.payload;
            const activeLayout = layouts.find(l => l.is_active);
            if (activeLayout) {
              selectedLayoutId = activeLayout.id;
            }
            status = '';
          } else {
            status = 'Error loading layouts.';
          }
        }
        break;
        
      case 'activateLayoutResponse':
        if (message.payload && message.payload.success && message.payload.message && message.payload.message.includes('activated')) {
          status = 'Layout activated successfully!';
          setTimeout(() => {
            status = '';
            loadLayouts(); // Refresh the list
          }, 2000);
        }
        break;
        
      case 'saveLayoutResponse':
        if (message.payload && message.payload.name && status.includes('Saving layout')) {
          status = `Layout "${message.payload.name}" saved successfully!`;
          setTimeout(() => {
            status = '';
            loadLayouts(); // Refresh the list
          }, 2000);
        }
        break;
        
      default:
        // Ignore messages not relevant to LayoutManager
        break;
    }
  }

  function loadLayouts() {
    status = 'Loading layouts...';
    layouts = [];
    selectedLayoutId = null;
    
    if ($wsStore.isConnected) {
      wsStore.send({ command: 'listLayouts' });
    } else {
      status = 'Not connected to server.';
    }
  }

  // Load layouts when component mounts
  onMount(() => {
    // Wait a bit for WebSocket to connect
    setTimeout(() => {
      loadLayouts();
    }, 1000);
  });

  function handleActivateLayout() {
    if (!selectedLayoutId) {
      alert('Please select a layout to activate.');
      return;
    }
    status = `Activating layout ${selectedLayoutId}...`;
    wsStore.send({
      command: 'activateLayout',
      payload: { id: parseInt(selectedLayoutId) }
    });
  }

  function handleSaveLayout() {
    if (!newLayoutName.trim()) {
      alert('Please enter a name for the new layout.');
      return;
    }
    status = `Saving layout as "${newLayoutName}"...`;
    wsStore.send({
      command: 'saveLayout',
      payload: { name: newLayoutName.trim() }
    });
    newLayoutName = ''; // Clear input
  }

  function handleRefresh() {
    loadLayouts();
  }
</script>

<div class="layout-manager">
  <div class="header">
    <h4>Layout Manager</h4>
    <button class="refresh-btn" on:click={handleRefresh} disabled={!$wsStore.isConnected}>
      🔄
    </button>
  </div>
  
  {#if status}
    <p class="status">{status}</p>
  {/if}

  {#if !$wsStore.isConnected}
    <p class="error">Not connected to server. Retrying...</p>
  {:else if layouts.length > 0}
    <div class="control-group">
      <select bind:value={selectedLayoutId}>
        <option value={null} disabled>Select a layout...</option>
        {#each layouts as layout}
          <option value={layout.id}>
            {layout.name} ({new Date(layout.created_at).toLocaleDateString()})
            {layout.is_active ? ' (Active)' : ''}
          </option>
        {/each}
      </select>
      <button on:click={handleActivateLayout} disabled={!selectedLayoutId}>
        Activate
      </button>
    </div>
    
    <div class="control-group">
      <input 
        type="text" 
        placeholder="Name for new layout..." 
        bind:value={newLayoutName}
        maxlength="50"
      />
      <button on:click={handleSaveLayout} disabled={!newLayoutName.trim()}>
        Save Current
      </button>
    </div>
  {:else if status === ''}
    <p class="no-layouts">No layouts found. Save your current setup to create the first layout.</p>
    
    <div class="control-group">
      <input 
        type="text" 
        placeholder="Name for new layout..." 
        bind:value={newLayoutName}
        maxlength="50"
      />
      <button on:click={handleSaveLayout} disabled={!newLayoutName.trim()}>
        Save Current
      </button>
    </div>
  {/if}
</div>

<style>
  .layout-manager {
    padding: 15px;
    border: 1px solid #555;
    border-radius: 8px;
    background-color: #2a2a2a;
    color: #fff;
    margin-bottom: 10px;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }

  .header h4 {
    margin: 0;
    color: #fff;
  }

  .refresh-btn {
    background: none;
    border: 1px solid #555;
    color: #fff;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 12px;
  }

  .refresh-btn:hover:not(:disabled) {
    background-color: #444;
  }

  .refresh-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .control-group {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    align-items: center;
  }

  select, input {
    flex-grow: 1;
    padding: 8px;
    border: 1px solid #555;
    border-radius: 4px;
    background-color: #1a1a1a;
    color: #fff;
  }

  select:focus, input:focus {
    outline: none;
    border-color: #007acc;
  }

  button {
    padding: 8px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    background-color: #007acc;
    color: #fff;
    cursor: pointer;
    white-space: nowrap;
  }

  button:hover:not(:disabled) {
    background-color: #005a9e;
  }

  button:disabled {
    background-color: #444;
    cursor: not-allowed;
    opacity: 0.6;
  }

  .status {
    font-style: italic;
    color: #ccc;
    margin: 8px 0;
    font-size: 14px;
  }

  .error {
    color: #ff6b6b;
    font-style: italic;
    margin: 8px 0;
  }

  .no-layouts {
    color: #ccc;
    font-style: italic;
    margin: 10px 0;
    text-align: center;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/BetrugerCapIcon.svelte ---

<svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%;">
  <defs>
    <filter height="150%" id="sh0" width="150%" x="-0.25" y="-0.25">
      <feConvolveMatrix in="SourceAlpha" result="19y" order="1,17" divisor="6632" kernelMatrix="10 30 77 169 320 527 752 931 1000 931 752 527 320 169 77 30 10"></feConvolveMatrix>
      <feConvolveMatrix result="19x" order="17,1" divisor="6632" kernelMatrix="10 30 77 169 320 527 752 931 1000 931 752 527 320 169 77 30 10"></feConvolveMatrix>
      <feConvolveMatrix in="SourceAlpha" result="49y" order="1,47" divisor="19856" kernelMatrix="15 21 30 42 57 77 101 132 169 212 263 320 384 453 527 603 678 752 820 881 931 968 992 1000 992 968 931 881 820 752 678 603 527 453 384 320 263 212 169 132 101 77 57 42 30 21 15"></feConvolveMatrix>
      <feConvolveMatrix result="49x" order="47,1" divisor="19856" kernelMatrix="15 21 30 42 57 77 101 132 169 212 263 320 384 453 527 603 678 752 820 881 931 968 992 1000 992 968 931 881 820 752 678 603 527 453 384 320 263 212 169 132 101 77 57 42 30 21 15"></feConvolveMatrix>
      <feTurbulence class="seed" result="noise" type="fractalNoise" stitchTiles="stitch" seed="267" baseFrequency="0.06 0.08 " numOctaves="3"></feTurbulence>
      <feMorphology operator="erode" radius="1.2"></feMorphology>
      <feComposite in="noise" operator="arithmetic" k1="0" k2="8" k3="0" k4="-3"></feComposite>
      <feComposite in="49x" result="49noise" operator="arithmetic" k1="0" k2="2" k3="-0.2" k4="-1"></feComposite>
      <feComposite in="49noise" in2="19x" operator="arithmetic" k1="0" k2="0.5" k3="1.5" k4="-1"></feComposite>
      <feDiffuseLighting surfaceScale="2" lighting-color="#fff">
        <feDistantLight azimuth="240" elevation="20"></feDistantLight>
      </feDiffuseLighting>
      <feComposite in2="SourceGraphic" operator="arithmetic" k1="1" k2="0" k3="0" k4="0"></feComposite>
    </filter>
    <filter height="150%" id="sh2" width="150%" x="-0.25" y="-0.25">
      <feConvolveMatrix in="SourceAlpha" order="1,9" divisor="3318" kernelMatrix="10 77 320 752 1000 752 320 77 10"></feConvolveMatrix>
      <feConvolveMatrix order="9,1" divisor="3318" kernelMatrix="10 77 320 752 1000 752 320 77 10"></feConvolveMatrix>
      <feColorMatrix result="obj" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0"></feColorMatrix>
      <feSpecularLighting surfaceScale="1" specularExponent="40">
        <feDistantLight azimuth="240" elevation="20"></feDistantLight>
      </feSpecularLighting>
      <feColorMatrix result="spec" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"></feColorMatrix>
      <feDiffuseLighting in="obj" surfaceScale="1" lighting-color="#fff">
        <feDistantLight azimuth="240" elevation="20"></feDistantLight>
      </feDiffuseLighting>
      <feColorMatrix values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"></feColorMatrix>
      <feComposite in2="SourceGraphic" operator="arithmetic" k1="1.2" k2="0" k3="0.8" k4="0"></feComposite>
      <feComposite in2="spec" operator="arithmetic" k1="0" k2="1" k3="1" k4="0"></feComposite>
      <feDropShadow dx="2" dy="3" stdDeviation="1.5" flood-color="#000" flood-opacity="0.5"></feDropShadow>
    </filter>
    <linearGradient id="svg_66" x1="0" x2="1" y1="0" y2="0">
        <stop offset="0" stop-color="hsl(40, 23%, 35%)"></stop>
        <stop offset="0.4" stop-color="hsl(40, 23%, 60%)"></stop>
        <stop offset="0.65" stop-color="hsl(40, 23%, 70%)"></stop>
        <stop offset="0.75" stop-color="hsl(40, 23%, 60%)"></stop>
        <stop offset="1" stop-color="hsl(40, 23%, 35%)"></stop>
    </linearGradient>
    <circle id="bell" fill="#070" stroke="#030" r="5.5" filter="url(#sh0)"></circle>
    <g id="cap" filter="url(#sh2)">
        <path id="capPath" fill="#070" filter="url(#sh0)" stroke="#030" d="M72,89 C78.6,68 67.2,30.7 89,68 C86.9,37.6 66.91,32 62,61 C58,44.1 67.5,38.8 52,10 C53.6,47 46.91,36.2 45,61 C39.3,43.4 22,46.6 13,43 C32.9,55.8 35.7,66.62 32,89 C35,97.9 68.6,99 72,89 Z"></path>
        <use id="bell1" x="13" y="43" href="#bell"></use>
        <use id="bell2" x="52" y="10" href="#bell"></use>
        <use id="bell3" x="89" y="68" href="#bell"></use>
        <ellipse cx="52.19" cy="90.01" fill="url(#svg_66)" rx="14.76" ry="3.56"></ellipse>
        <path d="M34,86.5C36,82,53.5,81,60,83C54,81,34,81.5,34,86.5Z" fill="none" stroke="hsl(40, 23%, 60%)"></path>
    </g>
  </defs>
  <use href="#cap" />
</svg>

--- File: /packages/client-desktop/src/renderer/src/lib/components/ContextMenu.svelte ---

<script>
  import { onMount, createEventDispatcher } from 'svelte';
  
  export let item = null;
  export let x = 0;
  export let y = 0;
  export let visible = false;

  const dispatch = createEventDispatcher();
  let menuElement;
  let calculatedX = 0;
  let calculatedY = 0;

  onMount(() => {
    function handleClickOutside(event) {
      if (menuElement && !menuElement.contains(event.target)) {
        dispatch('close');
      }
    }

    function handleEscape(event) {
      if (event.key === 'Escape') {
        dispatch('close');
      }
    }

    if (visible) {
      document.addEventListener('click', handleClickOutside);
      document.addEventListener('keydown', handleEscape);
    }

    return () => {
      document.removeEventListener('click', handleClickOutside);
      document.removeEventListener('keydown', handleEscape);
    };
  });

  function formatPrice(price) {
    if (typeof price === 'number') {
      return `€${price.toFixed(2)}`;
    }
    // Check if it's item_price_value field
    if (item && item.item_price_value && typeof item.item_price_value === 'number') {
      return `€${item.item_price_value.toFixed(2)}`;
    }
    return price || 'N/A';
  }

  function parseDisplayNames(displayNamesJson) {
    try {
      const parsed = JSON.parse(displayNamesJson);
      return parsed.menu?.de || parsed.button?.de || parsed.de || 'Unnamed';
    } catch {
      return displayNamesJson || 'Unnamed';
    }
  }

  function parseCategoryNames(categoryNamesJson) {
    try {
      const parsed = JSON.parse(categoryNamesJson);
      return parsed.de || 'Unnamed Category';
    } catch {
      return categoryNamesJson || 'Unnamed Category';
    }
  }

  function parseAdditionalAttributes(attributesJson) {
    try {
      return JSON.parse(attributesJson);
    } catch {
      return {};
    }
  }

  $: isCategory = item && item.category_names;
  $: isProduct = item && item.display_names;
  $: additionalAttrs = isProduct && item.additional_item_attributes ? parseAdditionalAttributes(item.additional_item_attributes) : {};

  // Smart positioning to keep menu on screen
  $: if (visible && menuElement) {
    // Use requestAnimationFrame to ensure the menu is rendered before calculating position
    requestAnimationFrame(() => calculatePosition());
  }

  function calculatePosition() {
    if (!menuElement) return;
    
    const menuRect = menuElement.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // If menu dimensions are not available yet, try again later
    if (menuRect.width === 0 || menuRect.height === 0) {
      setTimeout(() => calculatePosition(), 10);
      return;
    }
    
    const EDGE_PADDING = 10;
    const CURSOR_OFFSET = 10;
    
    // Check if menu is too big for the viewport
    const menuTooWide = menuRect.width > viewportWidth - (EDGE_PADDING * 2);
    const menuTooTall = menuRect.height > viewportHeight - (EDGE_PADDING * 2);
    
    let newX, newY;
    
    if (menuTooWide && menuTooTall) {
      // Menu is too big for screen - center it and make it fit
      newX = EDGE_PADDING;
      newY = EDGE_PADDING;
    } else if (menuTooWide) {
      // Menu is too wide - center horizontally, position vertically around cursor
      newX = EDGE_PADDING;
      newY = y + CURSOR_OFFSET;
      
      // Check vertical bounds
      if (newY + menuRect.height > viewportHeight - EDGE_PADDING) {
        newY = y - menuRect.height - CURSOR_OFFSET;
      }
      if (newY < EDGE_PADDING) {
        newY = EDGE_PADDING;
      }
    } else if (menuTooTall) {
      // Menu is too tall - center vertically, position horizontally around cursor
      newY = EDGE_PADDING;
      newX = x + CURSOR_OFFSET;
      
      // Check horizontal bounds
      if (newX + menuRect.width > viewportWidth - EDGE_PADDING) {
        newX = x - menuRect.width - CURSOR_OFFSET;
      }
      if (newX < EDGE_PADDING) {
        newX = EDGE_PADDING;
      }
    } else {
      // Normal case - menu fits, position around cursor
      // Default position - bottom-right from click point
      newX = x + CURSOR_OFFSET;
      newY = y + CURSOR_OFFSET;
      
      // Check if menu goes off the right edge
      if (newX + menuRect.width > viewportWidth - EDGE_PADDING) {
        newX = x - menuRect.width - CURSOR_OFFSET; // Position to the left of cursor
      }
      
      // Check if menu goes off the bottom edge
      if (newY + menuRect.height > viewportHeight - EDGE_PADDING) {
        newY = y - menuRect.height - CURSOR_OFFSET; // Position above cursor
      }
      
      // Final bounds check
      if (newX < EDGE_PADDING) {
        newX = EDGE_PADDING;
      }
      
      if (newY < EDGE_PADDING) {
        newY = EDGE_PADDING;
      }
    }
    
    calculatedX = newX;
    calculatedY = newY;
  }

  function handleEdit() {
    dispatch('edit', { item });
    dispatch('close'); // Close the context menu after dispatching edit
  }
</script>

{#if visible && item}
  <div 
    class="context-menu" 
    bind:this={menuElement}
    style="left: {calculatedX || x}px; top: {calculatedY || y}px;"
  >
    <div class="menu-header">
      <h3>
        {#if isCategory}
          {parseCategoryNames(item.category_names)}
        {:else if isProduct}
          {parseDisplayNames(item.display_names)}
        {:else}
          Item Details
        {/if}
      </h3>
    </div>
    
    <div class="menu-content">
      {#if isProduct}
        <div class="detail-row">
          <span class="label">Price:</span>
          <span class="value">{formatPrice(item.item_price_value)}</span>
        </div>
        
        {#if additionalAttrs.description}
          <div class="detail-row">
            <span class="label">Description:</span>
            <span class="value">{additionalAttrs.description}</span>
          </div>
        {/if}
        
        {#if additionalAttrs.allergens && additionalAttrs.allergens.length > 0}
          <div class="detail-row">
            <span class="label">Allergens:</span>
            <span class="value">{additionalAttrs.allergens.join(', ')}</span>
          </div>
        {/if}
        
        {#if additionalAttrs.dietary_info && additionalAttrs.dietary_info.length > 0}
          <div class="detail-row">
            <span class="label">Dietary:</span>
            <span class="value">{additionalAttrs.dietary_info.join(', ')}</span>
          </div>
        {/if}
        
        {#if item.associated_category_unique_identifier}
          <div class="detail-row">
            <span class="label">Category:</span>
            <span class="value">{item.associated_category_unique_identifier}</span>
          </div>
        {/if}
        
        {#if item.id}
          <div class="detail-row">
            <span class="label">Product ID:</span>
            <span class="value">{item.id}</span>
          </div>
        {/if}
      {:else if isCategory}
        {#if item.category_type}
          <div class="detail-row">
            <span class="label">Type:</span>
            <span class="value">{item.category_type}</span>
          </div>
        {/if}
        
        {#if item.id}
          <div class="detail-row">
            <span class="label">Category ID:</span>
            <span class="value">{item.id}</span>
          </div>
        {/if}
        
        {#if item.source_unique_identifier}
          <div class="detail-row">
            <span class="label">Source ID:</span>
            <span class="value">{item.source_unique_identifier}</span>
          </div>
        {/if}
      {/if}
    </div>
    
    <div class="menu-footer">
      <button class="edit-button" on:click={() => handleEdit()}>
        Edit
      </button>
      <button class="close-button" on:click={() => dispatch('close')}>
        Close
      </button>
    </div>
  </div>
{/if}

<style>
  .context-menu {
    position: fixed;
    z-index: 1000;
    background-color: rgba(58, 58, 58, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    min-width: 280px;
    max-width: 400px;
    backdrop-filter: blur(10px);
    animation: fadeIn 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .menu-header {
    padding: 16px 16px 8px 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .menu-header h3 {
    margin: 0;
    color: #fff;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
  }

  .menu-content {
    padding: 12px 16px;
  }

  .detail-row {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
    gap: 12px;
  }

  .detail-row:last-child {
    margin-bottom: 0;
  }

  .label {
    color: #ccc;
    font-weight: 500;
    min-width: 80px;
    flex-shrink: 0;
  }

  .value {
    color: #fff;
    text-align: right;
    word-break: break-word;
    flex: 1;
  }

  .menu-footer {
    padding: 8px 16px 16px 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }

  .edit-button {
    background-color: #27ae60;
    color: white;
    border: 1px solid #2ecc71;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: background-color 0.2s ease;
    height: 60px;
    min-width: 80px;
    padding: 0 16px;
  }

  .edit-button:hover {
    background-color: #2ecc71;
  }

  .close-button {
    background-color: #666;
    color: white;
    border: 1px solid #777;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: background-color 0.2s ease;
    height: 60px;
    min-width: 80px;
    padding: 0 16px;
  }

  .close-button:hover {
    background-color: #777;
  }

  /* Handle very small screens */
  @media (max-width: 320px) or (max-height: 400px) {
    .context-menu {
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .menu-header h3 {
      font-size: 16px;
    }
    
    .detail-row {
      flex-direction: column;
      gap: 4px;
      margin-bottom: 12px;
    }
    
    .label {
      min-width: auto;
      font-weight: bold;
    }
    
    .value {
      text-align: left;
    }
    
    .menu-footer {
      flex-direction: column;
    }
    
    .edit-button,
    .close-button {
      height: 50px; /* Slightly smaller on very small screens but still touch-friendly */
      min-width: 100%;
      font-size: 16px;
    }
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-10px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/FunctionButtons.svelte ---

<script>
  import { onMount } from 'svelte';
  import SquareButton from './SquareButton.svelte';
  
  let containerWidth = 0;
  let containerHeight = 0;
  let containerElement;
  let resizeObserver;
  
  // Dynamic mosaic calculation
  let octagonWidth = 80; // Width of octagon buttons in px
  let octagonHeight = 80; // Height of octagon buttons in px
  let squareWidth = 56; // Width of square buttons 
  let squareHeight = 56; // Height of square buttons
  let columnsCount = 8; // Default number of columns
  let gridCells = []; // Grid structure for mosaic pattern
  
  const BUTTON_GAP = 6; // 6px gap between buttons
  const MIN_OCTAGON_SIZE = 60; // Minimum octagon size for usability
  
  // Reactive calculations for honeycomb layout with optimal square-like octagons
  $: {
    if (containerWidth > 0 && containerHeight > 0) {
      // 1. ВЫСОТА определяет базовую высоту 8-угольников (2 ряда + фиксированный gap)
      octagonHeight = Math.max((containerHeight - BUTTON_GAP) / 2, MIN_OCTAGON_SIZE);
      
      // 2. Подбираем КОЛИЧЕСТВО колонок для максимально квадратных 8-угольников
      // Ищем количество, при котором ширина ближе всего к высоте
      let bestColumnsCount = 2;
      let bestRatio = Infinity; // Чем ближе к 1, тем лучше (квадратнее)
      
      // Проверяем разные количества колонок
      for (let testColumns = 2; testColumns <= 20; testColumns++) {
        const testWidth = (containerWidth - (testColumns - 1) * BUTTON_GAP) / testColumns;
        if (testWidth >= MIN_OCTAGON_SIZE) { // Проверяем минимальный размер
          const ratio = Math.abs(testWidth / octagonHeight - 1); // Отклонение от 1:1
          if (ratio < bestRatio) {
            bestRatio = ratio;
            bestColumnsCount = testColumns;
          }
        }
      }
      
      columnsCount = bestColumnsCount;
      
      // 3. Рассчитываем ширину 8-угольников для оптимального количества
      octagonWidth = (containerWidth - (columnsCount - 1) * BUTTON_GAP) / columnsCount;
      
      // 4. Ромбы (повернутые квадраты) масштабируются с теми же пропорциями
      const widthRatio = octagonWidth / octagonHeight;
      const baseSquareSize = octagonHeight * 0.6; // Базовый размер по высоте
      squareWidth = baseSquareSize * widthRatio; // Растягиваем по ширине
      squareHeight = baseSquareSize; // Высота остается пропорциональной
      
      // Update grid structure
      updateGridStructure();
    }
  }
  
  function updateGridStructure() {
    gridCells = [];
    
    // First pass: place all octagons in regular grid (2 rows)
    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < columnsCount; col++) {
        gridCells.push({
          id: `octagon-${row}-${col}`,
          type: 'octagon',
          row,
          col,
          gridRow: row + 1,
          gridCol: col + 1,
          label: `F${gridCells.length + 1}`
        });
      }
    }
    
    // Second pass: place squares between groups of 4 octagons
    // Squares go between every 2x2 group of octagons
    for (let row = 0; row < 1; row++) { // Only 1 row of squares between octagon rows
      for (let col = 0; col < columnsCount - 1; col++) { // One less square than octagons horizontally
        gridCells.push({
          id: `square-${row}-${col}`,
          type: 'square',
          row: row + 0.5, // Between rows
          col: col + 0.5, // Between columns
          gridRow: row + 1.5, // CSS Grid position between rows
          gridCol: col + 1.5, // CSS Grid position between columns
          label: `S${gridCells.filter(c => c.type === 'square').length + 1}`
        });
      }
    }
  }
  
  // ResizeObserver setup
  onMount(() => {
    if (containerElement) {
      // Set initial dimensions
      containerWidth = containerElement.clientWidth;
      containerHeight = containerElement.clientHeight;
      
      resizeObserver = new ResizeObserver(entries => {
        for (let entry of entries) {
          containerWidth = entry.contentRect.width;
          containerHeight = entry.contentRect.height;
        }
      });
      resizeObserver.observe(containerElement);
    }
    
    return () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  });
</script>

<div class="function-buttons-wrapper" bind:this={containerElement} bind:clientWidth={containerWidth} bind:clientHeight={containerHeight}>
  <div class="honeycomb-container">
    <!-- Octagon buttons in regular grid -->
    <div class="octagon-grid" style="grid-template-columns: repeat({columnsCount}, 1fr); gap: {BUTTON_GAP}px;">
      {#each gridCells.filter(c => c.type === 'octagon') as cell (cell.id)}
        <button class="octagon-btn" style="width: {octagonWidth}px; height: {octagonHeight}px;">
          <span>{cell.label}</span>
        </button>
      {/each}
    </div>
    
    <!-- Square buttons positioned absolutely between octagons -->
    {#each gridCells.filter(c => c.type === 'square') as cell (cell.id)}
      <div 
        class="square-position" 
        style="
          left: {(cell.col + 0.5) * (octagonWidth + BUTTON_GAP) - squareWidth/2 - 3}px;
          top: {(octagonHeight + BUTTON_GAP/2) - squareHeight/2}px;
        "
      >
        <SquareButton 
          label={cell.label} 
          width={squareWidth} 
          height={squareHeight}
        />
      </div>
    {/each}
  </div>
</div>

<style>
  .function-buttons-wrapper {
    flex-grow: 1; /* This makes the component fill the remaining space */
    height: 100%;
    box-sizing: border-box;
    overflow: hidden; /* Hide any overflow */
    padding: 0; /* Remove padding to eliminate extra spacing */
  }
  
  .honeycomb-container {
    position: relative;
    width: 100%;
    height: 100%;
  }
  
  .octagon-grid {
    display: grid;
    grid-template-rows: repeat(2, 1fr);
    width: 100%;
    height: 100%;
    align-items: center;
    justify-items: center;
  }
  
  .square-position {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none; /* Let clicks pass through to the SquareButton inside */
  }
  
  .square-position :global(.square-button) {
    pointer-events: auto; /* Re-enable clicks on the actual button */
  }

  .octagon-btn {
    /* Reset button styles */
    background: none;
    border: none;
    padding: 0;
    color: white;
    font-family: inherit;

    /* Styling */
    background-color: #4a69bd; /* A distinct blue */
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;

    /* Shape and Proportions - size now controlled by inline style */
    flex-shrink: 0; /* Prevent shrinking */
    clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);

    /* Content Alignment */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 19px;
    font-weight: bold;
  }

  .octagon-btn:hover {
    background-color: #6a89cc;
    transform: scale(1.05);
  }

  .octagon-btn:active {
    transform: scale(0.98);
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/HalfHexButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let icon = '';
  export let disabled = false;
  export let side = 'left'; // 'left' or 'right'
  export let width = 67.5; // Width in pixels, default to calculated half size (4.21875rem = 67.5px)
  export let height = 121; // Height in pixels, default to original size (7.5625rem = 121px)
  
  const dispatch = createEventDispatcher();
  
  function handleClick() {
    if (!disabled) {
      dispatch('click');
    }
  }
</script>

<button class="half-hex-button" class:disabled class:right={side === 'right'} style="--half-hex-width: {width}px; --half-hex-height: {height}px;" on:click={handleClick}>
  <div class="half-hex-shape">
    {#if icon}
      <span class="half-hex-icon">{icon}</span>
    {:else}
      <span class="half-hex-text">{label}</span>
    {/if}
  </div>
</button>

<style>
  .half-hex-button {
    --clip-path: polygon(0% 0%, 100% 25%, 100% 75%, 0% 100%);
  }
  
  .half-hex-button.right {
    --clip-path: polygon(0% 25%, 100% 0%, 100% 100%, 0% 75%);
  }
  
  .half-hex-button {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    width: var(--half-hex-width, 67.5px); /* Dynamic width, fallback to calculated half size */
    height: var(--half-hex-height, 121px); /* Dynamic height, same as HexButton */
    position: relative;
    transition: transform 0.2s ease-out;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-grow: 0;
    flex-shrink: 0;
  }
  
  .half-hex-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }
  
  .half-hex-button:active {
    transform: scale(0.98);
  }
  
  .half-hex-shape {
    width: 100%;
    height: 100%;
    background-color: #5a7aad; /* Distinct darker color */
    clip-path: var(--clip-path);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    border: 2px solid rgba(255, 255, 255, 0.2);
  }
  
  .half-hex-text {
    color: white;
    font-weight: bold;
    text-align: center;
    font-size: 14px;
    padding: 5px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
  }
  
  .half-hex-icon {
    color: white;
    font-size: 32px;
    font-weight: bold;
    text-align: center;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
  }
  
  .half-hex-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
  }
  
  .half-hex-button.disabled .half-hex-shape {
    background-color: #2a2a2a;
    border-color: rgba(255, 255, 255, 0.1);
  }
  
  .half-hex-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/HalfRectButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let icon = '';
  export let disabled = false;
  export let side = 'left'; // 'left' or 'right'
  export let width = 60; // Width in pixels
  export let height = 100; // Height in pixels
  
  const dispatch = createEventDispatcher();
  
  function handleClick() {
    if (!disabled) {
      dispatch('click');
    }
  }
</script>

<button 
  class="half-rect-button" 
  class:disabled 
  class:right={side === 'right'} 
  style="width: {width}px; height: {height}px;" 
  on:click={handleClick}
>
  <div class="half-rect-shape">
    {#if icon}
      <span class="half-rect-icon">{icon}</span>
    {:else}
      <span class="half-rect-text">{label}</span>
    {/if}
  </div>
</button>

<style>
  .half-rect-button {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    position: relative;
    transition: transform 0.2s ease-out;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-grow: 0;
    flex-shrink: 0;
  }
  
  .half-rect-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }
  
  .half-rect-button:active {
    transform: scale(0.98);
  }
  
  .half-rect-shape {
    width: 100%;
    height: 100%;
    background-color: #666666;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
    border-radius: 8px;
  }
  
  .half-rect-text {
    color: white;
    font-weight: normal;
    font-family: 'Arial Narrow', 'Liberation Sans Narrow', 'Helvetica Neue Condensed', 'Arial', sans-serif;
    font-stretch: ultra-condensed;
    text-align: center;
    font-size: 16px;
    line-height: 1.2;
    letter-spacing: -0.3px;
    word-break: break-word;
    white-space: normal;
    padding: 4px;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
  }
  
  .half-rect-icon {
    color: white;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
  }
  
  .half-rect-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
  }
  
  .half-rect-button.disabled .half-rect-shape {
    background-color: #2a2a2a;
  }
  
  .half-rect-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/HexButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let color = '#666666'; // A nice default gray
  export let disabled = false;
  export let data = null; // For passing category data
  export let width = 140; // Width in pixels, default to original size (8.75rem = 140px)
  export let height = 121; // Height in pixels, default to original size (7.5625rem = 121px)
  
  const dispatch = createEventDispatcher();
  
  // Use the full label without truncation to allow proper wrapping
  $: displayLabel = label;
  
  let longPressTimer;
  let isLongPressing = false;

  function handleClick() {
    if (!disabled && !isLongPressing) {
      dispatch('click', { data, label });
    }
  }

  function handleContextMenu(event) {
    if (!disabled) {
      event.preventDefault();
      dispatch('secondaryaction', { 
        data, 
        label, 
        mouseX: event.clientX, 
        mouseY: event.clientY,
        originalEvent: event
      });
    }
  }

  function handleMouseDown(event) {
    if (!disabled && event.button === 0) { // Left mouse button
      isLongPressing = false;
      longPressTimer = setTimeout(() => {
        isLongPressing = true;
        dispatch('secondaryaction', { 
          data, 
          label, 
          mouseX: event.clientX, 
          mouseY: event.clientY,
          originalEvent: event
        });
      }, 500); // 500ms for long press
    }
  }

  function handleMouseUp() {
    clearTimeout(longPressTimer);
    setTimeout(() => { isLongPressing = false; }, 10);
  }

  function handleMouseLeave() {
    clearTimeout(longPressTimer);
    isLongPressing = false;
  }
</script>

<button class="hex-button" class:disabled style="--hex-bg-color: {color}; --hex-width: {width}px; --hex-height: {height}px;" title={label} on:click={handleClick} on:contextmenu={handleContextMenu} on:mousedown={handleMouseDown} on:mouseup={handleMouseUp} on:mouseleave={handleMouseLeave}>
  <div class="hex-shape">
    {#if $$slots.default}
      <div class="slot-container">
        <slot />
      </div>
    {:else}
      <span class="hex-text">{displayLabel}</span>
    {/if}
  </div>
</button>

<style>
  .hex-button {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    width: var(--hex-width, 140px); /* Dynamic width, fallback to 140px */
    height: var(--hex-height, 121px); /* Dynamic height, fallback to 121px */
    position: relative;
    transition: transform 0.2s ease-out;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-grow: 0;   /* Prevent the button from growing */
    flex-shrink: 0; /* Prevent the button from shrinking */
  }
  .hex-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }
  .hex-button:active {
    transform: scale(0.98);
  }
  .hex-shape {
    width: 100%;
    height: 100%;
    background-color: var(--hex-bg-color);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    position: relative; /* Needed for slot container */
    overflow: hidden; /* This masks the content */
  }
  .slot-container {
    width: 100%;
    height: 100%;
  }
  .hex-text {
    color: white;
    font-weight: normal;
    font-family: 'Arial Narrow', 'Liberation Sans Narrow', 'Helvetica Neue Condensed', 'Arial', sans-serif;
    font-stretch: ultra-condensed;
    /* Removed scaleX to fix text wrapping calculation */
    text-align: center;
    font-size: 22px; /* Increased by 20% from 18px */
    line-height: 1.1; /* Tighter line spacing for condensed text */
    letter-spacing: -0.5px; /* Negative spacing to compensate for scaleX */
    word-break: break-word;
    white-space: normal;
    padding: 5px;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8); /* Stronger shadow for better contrast */
  }
  .hex-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
  }
  .hex-button.disabled .hex-shape {
    background-color: #2a2a2a;
    border-color: rgba(255, 255, 255, 0.1);
  }
  .hex-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/OctagonButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let color = '#666666'; // Gray color like HexButton
  export let disabled = false;
  export let data = null;
  export let width = 80; // Width in px
  export let height = 80; // Height in px
  
  const dispatch = createEventDispatcher();
  
  let longPressTimer;
  let isLongPressing = false;

  function handleClick() {
    if (!disabled && !isLongPressing) {
      dispatch('click', { data, label });
    }
  }

  function handleContextMenu(event) {
    if (!disabled) {
      event.preventDefault();
      dispatch('secondaryaction', { 
        data, 
        label, 
        mouseX: event.clientX, 
        mouseY: event.clientY,
        originalEvent: event
      });
    }
  }

  function handleMouseDown(event) {
    if (!disabled && event.button === 0) { // Left mouse button
      isLongPressing = false;
      longPressTimer = setTimeout(() => {
        isLongPressing = true;
        dispatch('secondaryaction', { 
          data, 
          label, 
          mouseX: event.clientX, 
          mouseY: event.clientY,
          originalEvent: event
        });
      }, 500); // 500ms for long press
    }
  }

  function handleMouseUp() {
    clearTimeout(longPressTimer);
    setTimeout(() => { isLongPressing = false; }, 10);
  }

  function handleMouseLeave() {
    clearTimeout(longPressTimer);
    isLongPressing = false;
  }
</script>

<button 
  class="octagon-button" 
  class:disabled 
  style="width: {width}px; height: {height}px; background-color: {color};" 
  title={label} 
  on:click={handleClick}
  on:contextmenu={handleContextMenu}
  on:mousedown={handleMouseDown}
  on:mouseup={handleMouseUp}
  on:mouseleave={handleMouseLeave}
>
  {#if $$slots.default}
    <div class="slot-container">
      <slot />
    </div>
  {:else}
    <span class="octagon-text">{label}</span>
  {/if}
</button>

<style>
  .octagon-button {
    /* Reset button styles */
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    color: white;
    font-family: inherit;
    
    /* Styling */
    /* Background color set through inline style */
    border: none;
    transition: background-color 0.2s ease, transform 0.1s ease;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-shrink: 0;
    
    /* Octagon shape through clip-path */
    clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
    
    /* Content Alignment */
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative; /* Needed for slot container */
    overflow: hidden; /* This masks the content */
  }
  
  .octagon-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }
  
  .octagon-button:active {
    transform: scale(0.98);
  }
  
  .slot-container {
    width: 100%;
    height: 100%;
  }
  
  .octagon-text {
    font-weight: normal;
    font-family: 'Arial Narrow', 'Liberation Sans Narrow', 'Helvetica Neue Condensed', 'Arial', sans-serif;
    font-stretch: ultra-condensed;
    /* Removed scaleX to fix text wrapping calculation */
    text-align: center;
    font-size: 24px; /* Increased by 20% from 20px */
    line-height: 1.1; /* Tighter line spacing */
    letter-spacing: -0.5px; /* Negative spacing to compensate for scaleX */
    word-break: break-word;
    white-space: normal;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8); /* Stronger shadow */
  }
  
  .octagon-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
    background-color: #2a2a2a !important;
  }
  
  .octagon-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/ParkedOrdersDisplay.svelte ---

<script>
  import { onMount, onDestroy } from 'svelte';
  import { parkedOrdersStore } from '../parkedOrdersStore.js';
  import { orderStore } from '../orderStore.js';
  import { wsStore } from '../wsStore.js';
  import { timeStore } from '../timeStore.js';

  let parkedOrders = [];
  let unsubscribe;
  let wsUnsubscribe;
  let hasLoadedOnce = false; // Flag to prevent multiple loads

  onMount(async () => {
    // Subscribe to parked orders store
    unsubscribe = parkedOrdersStore.subscribe(value => {
      parkedOrders = value;
    });

    // Wait for WebSocket connection before loading parked orders
    wsUnsubscribe = wsStore.subscribe(async (wsState) => {
      if (wsState.connected && !hasLoadedOnce) {
        // Only load once when WebSocket connects
        hasLoadedOnce = true;
        await parkedOrdersStore.refreshParkedOrders();
      }
    });
  });

  onDestroy(() => {
    if (unsubscribe) {
      unsubscribe();
    }
    if (wsUnsubscribe) {
      wsUnsubscribe();
    }
  });

  async function handleOrderClick(order) {
    try {
      // Импортируем функцию сворачивания из SelectionArea
      const { orderStore } = await import('../orderStore.js');
      
      // Проверяем, есть ли активный заказ
      let currentOrderState;
      orderStore.subscribe(state => currentOrderState = state)();
      
      if (currentOrderState.transactionId && currentOrderState.status === 'active') {
        // Есть активный заказ - сворачиваем его сначала
        const hasItems = currentOrderState.items && currentOrderState.items.length > 0;
        const hasTable = currentOrderState.metadata && currentOrderState.metadata.table;
        
        if (hasItems && hasTable) {
          // Паркуем текущий заказ БЕЗ обновления времени
          await orderStore.parkCurrentOrder(hasTable, 1, false);
          await parkedOrdersStore.refreshParkedOrders();
        } else if (hasItems && !hasTable) {
          // Заказ с товарами но без стола - принудительно открываем пинпад для присвоения стола
          const { pinpadStore } = await import('../pinpadStore.js');
          const { consoleView } = await import('../viewStore.js');
          
          // Переключаемся на view заказов и открываем пинпад
          consoleView.set('order');
          pinpadStore.activateTableEntry();
          
          // Не продолжаем выполнение - ждем присвоения стола
          return;
        } else {
          // Просто сбрасываем незавершенный заказ без товаров
          orderStore.resetOrder();
        }
      }
      
      // Теперь активируем выбранный заказ без обновления времени
      const activatedOrder = await parkedOrdersStore.activateOrder(order.id, false);
      orderStore.loadOrder(activatedOrder);
    } catch (error) {
      console.error('Failed to switch to order:', error);
      // TODO: Show user-friendly error message
    }
  }

  function formatCurrency(amount) {
    return (parseFloat(amount) || 0).toFixed(2) + ' €';
  }

  function getTableName(order) {
    const metadata = order.metadata || {};
    const tableNumber = metadata.table || order.id.toString();
    
    // Limit to 3 characters max for clean design
    if (tableNumber.length > 3) {
      return `#${tableNumber.substring(0, 3)}`;
    }
    
    return `#${tableNumber}`;
  }

  function formatTimeElapsed(dateString) {
    // Use server time instead of client time
    return timeStore.formatTimeElapsed(dateString);
  }

  function getOrderStats(order) {
    const openMinutes = formatTimeElapsed(order.created_at);
    const activityMinutes = formatTimeElapsed(order.updated_at);
    const price = formatCurrency(order.total_amount);
    
    return {
      price,
      openMinutes,
      activityMinutes
    };
  }
</script>

<div class="parked-orders-container">
  {#if parkedOrders.length === 0}
    <div class="no-orders">
      <span>Нет припаркованных заказов</span>
    </div>
  {:else}
    <div class="orders-list">
      {#each parkedOrders as order (order.id)}
        <div class="order-item" on:click={() => handleOrderClick(order)}>
          <div class="table-number">
            {getTableName(order)}
          </div>
          <div class="order-stats">
            <div class="stat-price">{getOrderStats(order).price}</div>
            <div class="stat-open">{getOrderStats(order).openMinutes}min</div>
            <div class="stat-activity">{getOrderStats(order).activityMinutes}min</div>
          </div>
        </div>
      {/each}
    </div>
  {/if}
</div>

<style>
  .parked-orders-container {
    width: 100%;
    /* Remove background, let individual cards have their own styling */
    margin-bottom: 12px;
    /* Remove height constraints to allow natural stacking */
  }

  .no-orders {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 44px;
    color: #888;
    font-style: italic;
    font-size: 13px;
  }

  .orders-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    padding: 2px; /* Add padding to prevent hover scale overflow */
  }

  .order-item {
    background: #2c2c2e;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    aspect-ratio: 2/1;
    display: flex;
    flex-direction: row;
    align-items: stretch;
    min-height: 0;
  }

  .order-item:hover {
    background: #3a3a3c;
    border-color: #666;
    transform: scale(1.02);
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
  }

  .table-number {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #2E1A16;
    border-radius: 4px;
    margin-right: 8px;
    min-width: 40px;
    width: 50px; /* Fixed width for 3-character limit */
    font-weight: 900;
    font-size: 18px; /* Slightly smaller for better fit */
    color: #CD853F;
  }

  .order-stats {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    align-items: flex-end;
    gap: 2px;
  }

  .stat-price {
    font-weight: 700;
    color: #5fb85f;
    font-size: 14px;
  }

  .stat-open {
    font-weight: 600;
    color: #e0e0e0;
    font-size: 12px;
  }

  .stat-activity {
    font-weight: 500;
    color: #aaa;
    font-size: 12px;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/Pinpad.svelte ---

<script>
  import { pinpadStore } from '../pinpadStore.js';
  
  export let onClose = () => {};
  
  let containerHeight = 0;
  let buttonHeight = 80;
  let buttonWidth = 107;

  const GAP = 8;

  $: {
    if (containerHeight > 0) {
      const rows = $pinpadStore.layout === 'alpha' ? 4 : 4;
      buttonHeight = (containerHeight - (GAP * (rows -1))) / rows;
      buttonWidth = buttonHeight * (4 / 3);
    }
  }

  function handleKeyClick(key) {
    pinpadStore.append(key);
  }

  function handleBackspace() {
    pinpadStore.backspace();
  }

  function handleConfirm() {
    pinpadStore.confirm();
  }

  function handleCancel() {
    pinpadStore.cancel();
  }

  function handleCloseDoubleClick() {
    onClose();
  }

  const alphaKeys = [
    ['Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I', 'O', 'P'],
    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
    ['Y', 'X', 'C', 'V', 'B', 'N', 'M', '.', ' ']
  ];
</script>

<div class="pinpad-wrapper" bind:clientHeight={containerHeight}>
  {#if $pinpadStore.layout === 'numeric'}
    <div class="pinpad-grid numeric" style="--button-height: {buttonHeight}px; --button-width: {buttonWidth}px;">
      <button class="numpad-key" on:click={() => handleKeyClick('1')}>1</button>
      <button class="numpad-key" on:click={() => handleKeyClick('2')}>2</button>
      <button class="numpad-key" on:click={() => handleKeyClick('3')}>3</button>
      <button class="function-key key-cancel" on:click={handleCancel} on:dblclick={handleCloseDoubleClick}>X</button>
      <button class="numpad-key" on:click={() => handleKeyClick('4')}>4</button>
      <button class="numpad-key" on:click={() => handleKeyClick('5')}>5</button>
      <button class="numpad-key" on:click={() => handleKeyClick('6')}>6</button>
      <button class="function-key key-correct" on:click={handleBackspace}>←</button>
      <button class="numpad-key" on:click={() => handleKeyClick('7')}>7</button>
      <button class="numpad-key" on:click={() => handleKeyClick('8')}>8</button>
      <button class="numpad-key" on:click={() => handleKeyClick('9')}>9</button>
      <button class="function-key key-enter" on:click={handleConfirm}>↵</button>
      <button class="numpad-key function-key key-plus" on:click={() => handleKeyClick('+')}>+</button>
      <button class="numpad-key" on:click={() => handleKeyClick('0')}>0</button>
      <button class="numpad-key function-key key-minus" on:click={() => handleKeyClick('-')}>-</button>
    </div>
  {:else if $pinpadStore.layout === 'alpha'}
    <div class="pinpad-grid alpha">
      {#each alphaKeys as row, rowIndex}
        <div class="alpha-row" style="margin-left: {rowIndex * 20}px;">
          {#each row as key}
            {#if key === ' '}
               <button class="alpha-key space" on:click={() => handleKeyClick(' ')}></button>
            {:else}
               <button class="alpha-key" on:click={() => handleKeyClick(key)}>{key}</button>
            {/if}
          {/each}
        </div>
      {/each}
       <div class="alpha-controls">
         <button class="function-key key-cancel" on:click={handleCancel} on:dblclick={handleCloseDoubleClick}>X</button>
         <button class="function-key key-correct" on:click={handleBackspace}>←</button>
         <button class="function-key key-enter" on:click={handleConfirm}>↵</button>
      </div>
    </div>
  {/if}
</div>

<style>
  .pinpad-wrapper { display: flex; justify-content: flex-start; align-items: center; height: 100%; flex-shrink: 0; }
  .pinpad-grid { display: grid; gap: 8px; }
  .pinpad-grid.numeric { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); }
  .pinpad-grid.alpha { display: flex; flex-direction: column; gap: 8px; width: 100%; }
  .alpha-row { display: flex; justify-content: center; gap: 8px; }
  .alpha-controls { display: flex; justify-content: flex-end; gap: 8px; margin-top: 8px; }
  button { background-color: #4a4a4a; color: #ffffff; border: 1px solid #666; border-radius: 8px; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease; }
  .numpad-key { height: var(--button-height); width: var(--button-width); font-size: 28px; }
  .alpha-key { width: 60px; height: 60px; font-size: 24px; }
  .space { flex-grow: 5; }
  .numpad-key:hover, .alpha-key:hover { background-color: #5a5a5a; }
  .function-key { font-size: 24px; }
  .key-cancel { background-color: #D32F2F; }
  .key-cancel:hover { background-color: #E53935; }
  .key-correct { background-color: #FBC02D; }
  .key-correct:hover { background-color: #FDD835; }
  .key-enter { background-color: #388E3C; }
  .key-enter:hover { background-color: #43A047; }
  .pinpad-grid.numeric .key-enter { grid-column: 4; grid-row: 3 / 5; height: calc(var(--button-height) * 2 + 8px); }
  .pinpad-grid.numeric .key-correct { grid-column: 4; grid-row: 2; }
  .pinpad-grid.numeric .key-cancel { grid-column: 4; grid-row: 1; }
  .pinpad-grid.numeric .key-plus { grid-column: 1; grid-row: 4; }
  .pinpad-grid.numeric .key-minus { grid-column: 3; grid-row: 4; }
  .alpha-controls .function-key { width: 100px; height: 60px; }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/PinpadPreview.svelte ---

<div class="preview-wrapper">
  <div class="preview-grid">
    <div class="key">1</div><div class="key">2</div><div class="key cancel">3</div>
    <div class="key">4</div><div class="key">5</div><div class="key correct">6</div>
    <div class="key">7</div><div class="key">8</div><div class="key enter">9</div>
    <div class="key zero">0</div><div class="key clear">C</div>
  </div>
</div>

<style>
  .preview-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #666666;
    padding: 5px;
    box-sizing: border-box;
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 6px;
  }
  .preview-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2px;
    width: 95%;
    height: 95%;
  }
  .key {
    background-color: #484848;
    border-radius: 2px;
    min-height: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: bold;
    color: #aaa;
    border: 1px solid #555;
  }
  .key.zero {
    grid-column: 1 / 3;
  }
  .key.cancel {
    background-color: #8a4040;
    color: #ddd;
  }
  .key.correct {
    background-color: #8a7a40;
    color: #ddd;
  }
  .key.enter {
    background-color: #4a6040;
    color: #ddd;
  }
  .key.clear {
    background-color: #5a4848;
    color: #ddd;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/ReceiptFeed.svelte ---

<script>
  import { onMount, afterUpdate } from 'svelte';
  import { receiptsStore } from '../receiptsStore.js';
  import { addLog } from '../logStore.js';

  export let autoExpandLatest = false; // Prop to auto-expand latest receipt
  
  let expandedReceipt = null;
  let userHasInteracted = false; // Track if user has manually clicked any receipt
  let receiptListElement;

  onMount(() => {
    // Load receipts when component mounts
    receiptsStore.loadReceipts();
  });

  // Auto-scroll removed - handled by parent ConsoleView

  // Auto-expand latest receipt when requested (only if user hasn't interacted yet)
  $: if (autoExpandLatest && !userHasInteracted && $receiptsStore.receipts.length > 0) {
    // Find the latest receipt (newest by fiscal_timestamp or updated_at)
    const sortedReceipts = $receiptsStore.receipts.sort((a, b) => 
      new Date(b.fiscal_timestamp || b.updated_at) - new Date(a.fiscal_timestamp || a.updated_at)
    );
    const latestReceiptId = sortedReceipts[0]?.id;
    
    if (latestReceiptId && expandedReceipt !== latestReceiptId) {
      expandedReceipt = latestReceiptId;
    }
  }

  // Reset user interaction when autoExpandLatest changes from false to true
  $: if (autoExpandLatest) {
    userHasInteracted = false;
  }

  function toggleReceipt(receiptId) {
    userHasInteracted = true; // Mark that user has manually interacted
    expandedReceipt = expandedReceipt === receiptId ? null : receiptId;
  }

  function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  function formatCurrency(amount) {
    return parseFloat(amount).toFixed(2) + '€';
  }

  function getItemName(item) {
    if (item.display_names && item.display_names.menu && item.display_names.menu.de) {
      return item.display_names.menu.de;
    }
    return 'Unnamed Item';
  }

  function handleReprintReceipt(receipt) {
    addLog('INFO', `Reprint requested for receipt №${receipt.id}`);
    // TODO: Implement reprint functionality
    console.log('Reprint receipt:', receipt);
  }
</script>

<div class="receipt-feed">

  {#if $receiptsStore.loading}
    <div class="loading">Loading receipts...</div>
  {:else if $receiptsStore.error}
    <div class="error">
      Error: {$receiptsStore.error}
    </div>
  {:else if $receiptsStore.receipts.length === 0}
    <div class="empty">No receipts found.</div>
  {:else}
    <div class="receipt-list" bind:this={receiptListElement}>
      {#each $receiptsStore.receipts.sort((a, b) => new Date(a.fiscal_timestamp || a.updated_at) - new Date(b.fiscal_timestamp || b.updated_at)) as receipt (receipt.id)}
        <div class="receipt-item" class:expanded={expandedReceipt === receipt.id}>
          <div class="receipt-summary" on:click={() => toggleReceipt(receipt.id)}>
            <div class="receipt-left">
              <div class="receipt-main-line">
                <span class="receipt-id-large">№{receipt.id}</span>
                {#if receipt.metadata?.table}
                  <span class="receipt-table-large">#{receipt.metadata.table}</span>
                {/if}
              </div>
              <div class="receipt-date">{formatDate(receipt.fiscal_timestamp || receipt.updated_at)}</div>
              <div class="receipt-payment">{receipt.payment_type || 'Unknown'}</div>
            </div>
            <div class="receipt-right">
              <div class="receipt-price"><span class="price">{formatCurrency(receipt.total_amount)}</span></div>
              <div class="receipt-meta">
                <div class="receipt-items-count">{receipt.items?.length || 0} items</div>
              </div>
            </div>
            <div class="expand-icon">
              {expandedReceipt === receipt.id ? '▼' : '▶'}
            </div>
          </div>
          
          {#if expandedReceipt === receipt.id}
            <div class="receipt-details">
              <div class="items-list">
                {#each receipt.items as item (item.id)}
                  <div class="item-row">
                    <span class="item-qty">{item.quantity}x</span>
                    <span class="item-name">{getItemName(item)}</span>
                    <span class="item-price">{formatCurrency(item.total_price)}</span>
                  </div>
                {/each}
              </div>
              <div class="receipt-totals">
                <div class="total-row">
                  <span>Tax:</span>
                  <span class="price">{formatCurrency(receipt.tax_amount)}</span>
                </div>
                <div class="total-row total">
                  <span>Total:</span>
                  <span class="price">{formatCurrency(receipt.total_amount)}</span>
                </div>
              </div>
              <div class="receipt-actions">
                <button class="action-button" on:click={() => handleReprintReceipt(receipt)}>
                  🖨️ Reprint
                </button>
              </div>
            </div>
          {/if}
        </div>
      {/each}
    </div>
  {/if}
</div>

<style>
  .receipt-feed {
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  .feed-header {
    margin-bottom: 16px;
    padding-bottom: 8px;
    border-bottom: 1px solid #444;
  }

  .feed-header h3 {
    margin: 0;
    color: #e0e0e0;
    font-size: 18px;
  }

  .loading, .error, .empty {
    text-align: center;
    padding: 20px;
    color: #aaa;
    font-style: italic;
  }

  .error {
    color: #ff6b6b;
  }

  .receipt-list {
    flex: 1;
    /* Remove overflow - let parent handle scrolling */
  }

  .receipt-item {
    border: 1px solid #444;
    border-radius: 6px;
    margin-bottom: 8px;
    background: #333;
    transition: all 0.2s ease;
  }

  .receipt-item:hover {
    border-color: #666;
  }

  .receipt-item.expanded {
    border-color: #4a69bd;
    background: #383838;
  }

  .receipt-summary {
    display: flex;
    align-items: center;
    padding: 12px;
    cursor: pointer;
    user-select: none;
  }

  .receipt-left {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .receipt-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-right: 12px;
  }

  .receipt-id {
    font-weight: bold;
    color: #4a69bd;
    font-size: 18px; /* Made bigger */
    margin-bottom: 4px;
  }

  .receipt-date {
    font-size: 12px;
    color: #aaa;
    margin-bottom: 2px;
  }

  .receipt-payment {
    font-size: 12px;
    color: #e0e0e0;
  }

  .receipt-price {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 4px;
  }

  .receipt-meta {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 2px;
  }

  .receipt-table {
    font-size: 12px;
    color: #4a69bd;
    font-weight: bold;
  }

  .receipt-main-line {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
  }

  .receipt-id-large {
    font-size: 18px;
    color: #4a69bd; /* Purple like receipt numbers */
    font-weight: bold;
  }

  .receipt-table-large {
    font-size: 18px;
    color: #CD853F; /* Wood color like in active orders */
    font-weight: bold;
  }

  .receipt-items-count {
    font-size: 11px;
    color: #888;
  }

  .expand-icon {
    color: #666;
    font-size: 12px;
    transition: transform 0.2s ease;
  }

  .receipt-item.expanded .expand-icon {
    transform: rotate(0deg);
  }

  .receipt-details {
    border-top: 1px solid #444;
    padding: 12px;
  }

  .items-list {
    margin-bottom: 12px;
  }

  .item-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px dashed #555;
    font-size: 13px;
  }

  .item-row:last-child {
    border-bottom: none;
  }

  .item-qty {
    font-weight: bold;
    color: #d32f2f; /* Reddish color instead of purple */
    min-width: 40px;
  }

  .item-name {
    flex: 1;
    padding: 0 8px;
  }

  .item-price {
    font-weight: bold;
    color: #4CAF50; /* Green color for all prices */
  }

  .receipt-totals {
    border-top: 1px solid #555;
    padding-top: 8px;
    margin-bottom: 12px;
  }

  .total-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    margin-bottom: 4px;
  }

  .total-row.total {
    font-weight: bold;
    font-size: 14px;
    border-top: 1px solid #666;
    padding-top: 4px;
    margin-top: 4px;
  }

  .receipt-actions {
    display: flex;
    gap: 8px;
  }

  .action-button {
    background: #5a7a5a;
    border: none;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.2s ease;
  }

  .action-button:hover {
    background: #6a8a6a;
  }

  .price {
    color: #4CAF50; /* Green color for all prices */
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/RecoveryModal.svelte ---

<script>
  import { recoveryStore } from '../recoveryStore.js';
  import { currentTime } from '../timeStore.js';

  function handleConfirmNoPending() {
    recoveryStore.confirmNoPending();
  }
  
  function handlePostponeAllAndStart() {
    // Postpone all pending transactions and start the app
    const pendingTxs = $recoveryStore.pendingTransactions;
    
    // Postpone all transactions
    pendingTxs.forEach(tx => {
      recoveryStore.resolveTransaction(tx.id, 'postpone', 1);
    });
    
    // Start the app after a brief delay
    setTimeout(() => {
      recoveryStore.confirmNoPending();
    }, 500);
  }

  function formatTime(date) {
    return date.toLocaleTimeString('de-DE', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  function formatDate(date) {
    return date.toLocaleDateString('de-DE', {
      weekday: 'long',
      day: '2-digit',
      month: 'long',
      year: 'numeric'
    });
  }
</script>

{#if $recoveryStore.status === 'awaiting_resolution' || $recoveryStore.status === 'awaiting_confirmation'}
  <div class="modal-overlay">
    <div class="modal-content">
      <!-- Always show time confirmation at the top -->
      <div class="time-confirmation-section">
        <h2>🕐 Подтверждение времени системы</h2>
        <div class="time-display-large">
          <div class="current-time">{formatTime($currentTime)}</div>
          <div class="current-date">{formatDate($currentTime)}</div>
        </div>
      </div>
      
      {#if $recoveryStore.status === 'awaiting_resolution'}
        <div class="transactions-section">
          <h3>⚠️ Незавершенные чеки</h3>
          <p>Обнаружены незавершенные чеки с предыдущей сессии:</p>
          
          <div class="transaction-list">
            <table>
              <thead>
                <tr>
                  <th>ID Чека</th>
                  <th>Сумма</th>
                  <th>Позиций</th>
                  <th>Действия</th>
                </tr>
              </thead>
              <tbody>
                {#each $recoveryStore.pendingTransactions as tx (tx.id)}
                  <tr>
                    <td>{tx.id}</td>
                    <td>{tx.total_amount.toFixed(2)} €</td>
                    <td>{tx.items.length}</td>
                    <td class="actions">
                      <button 
                        class="btn-fiscalize"
                        on:click={() => recoveryStore.resolveTransaction(tx.id, 'fiscalize', 1)}
                        title="Завершить и фискализировать этот чек."
                      >
                        Фискализировать
                      </button>
                      <button 
                        class="btn-cancel"
                        on:click={() => recoveryStore.resolveTransaction(tx.id, 'cancel', 1)}
                        title="Сторнировать (отменить) этот чек. Это фискальная операция."
                      >
                        Сторнировать
                      </button>
                      <button 
                        class="btn-postpone"
                        on:click={() => recoveryStore.resolveTransaction(tx.id, 'postpone', 1)}
                        title="Отложить решение на потом. Чек будет показан снова при следующем запуске."
                      >
                        Отложить
                      </button>
                    </td>
                  </tr>
                {/each}
              </tbody>
            </table>
          </div>
          
          <!-- Big postpone button for transactions -->
          <div class="main-actions">
            <button 
              class="btn-postpone-all"
              on:click={handlePostponeAllAndStart}
              title="Подтвердить время и отложить решение по всем чекам"
            >
              🕐 Подтвердить время и отложить все чеки
            </button>
          </div>
        </div>
      {:else if $recoveryStore.status === 'awaiting_confirmation'}
        <!-- Company info for clean start -->
        {#if $recoveryStore.companyInfo}
          <div class="company-info-small">
            <div class="company-name">{$recoveryStore.companyInfo.companyName || 'ecKasse'}</div>
            <div class="branch-info">{$recoveryStore.companyInfo.branchName || ''}</div>
          </div>
        {/if}
        
        <div class="main-actions">
          <button 
            class="btn-confirm"
            on:click={handleConfirmNoPending}
            title="Подтвердить время и начать работу"
          >
            🕐 Подтвердить время и начать работу
          </button>
        </div>
      {/if}

      {#if $recoveryStore.error}
        <p class="error">Ошибка: {$recoveryStore.error}</p>
      {/if}
    </div>
  </div>
{/if}

<style>
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .modal-content {
    background-color: white;
    padding: 2rem;
    border-radius: 12px;
    width: 85%;
    max-width: 1000px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  }

  .time-confirmation-section {
    margin-bottom: 2rem;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 2rem;
  }

  .transactions-section {
    margin-top: 1rem;
  }

  h2 {
    margin-top: 0;
    color: #2c3e50;
    text-align: center;
  }

  h3 {
    color: #e74c3c;
    margin-bottom: 1rem;
  }

  .time-display-large {
    text-align: center;
    margin: 1.5rem 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 12px;
    color: white;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }
  
  .current-time {
    font-size: 3rem;
    font-weight: 700;
    line-height: 1;
    margin-bottom: 0.5rem;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
  }
  
  .current-date {
    font-size: 1.2rem;
    font-weight: 500;
    opacity: 0.9;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
  }

  th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }

  th {
    background-color: #f2f2f2;
    font-weight: 600;
  }

  .actions button {
    margin-right: 5px;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    color: white;
    font-size: 12px;
    font-weight: 500;
  }
  
  .btn-fiscalize { 
    background-color: #28a745; 
  }
  .btn-fiscalize:hover { 
    background-color: #218838; 
  }
  
  .btn-cancel { 
    background-color: #dc3545; 
  }
  .btn-cancel:hover { 
    background-color: #c82333; 
  }
  
  .btn-postpone { 
    background-color: #ffc107; 
    color: #212529; 
  }
  .btn-postpone:hover { 
    background-color: #e0a800; 
  }
  
  .company-info-small {
    text-align: center;
    margin: 1rem 0;
    padding: 1rem;
    background-color: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #e9ecef;
  }
  
  .company-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: #495057;
    margin-bottom: 0.25rem;
  }
  
  .branch-info {
    font-size: 0.9rem;
    color: #6c757d;
  }
  
  .main-actions {
    display: flex;
    justify-content: center;
    margin: 2rem 0;
    gap: 1rem;
  }
  
  .btn-confirm, .btn-postpone-all {
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 16px 32px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
    letter-spacing: 0.5px;
  }
  
  .btn-confirm:hover, .btn-postpone-all:hover {
    background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
  }
  
  .btn-confirm:active, .btn-postpone-all:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(0, 123, 255, 0.3);
  }
  
  .error {
    color: #dc3545;
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    padding: 10px;
    border-radius: 4px;
    margin-top: 1rem;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/RectButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let icon = '';
  export let color = '#666666'; // Default gray color
  export let disabled = false;
  export let data = null;
  export let width = 120; // Width in px
  export let height = 80; // Height in px
  
  const dispatch = createEventDispatcher();
  
  let longPressTimer;
  let isLongPressing = false;

  function handleClick() {
    if (!disabled && !isLongPressing) {
      dispatch('click', { data, label });
    }
  }

  function handleContextMenu(event) {
    if (!disabled) {
      event.preventDefault();
      dispatch('secondaryaction', { 
        data, 
        label, 
        mouseX: event.clientX, 
        mouseY: event.clientY,
        originalEvent: event
      });
    }
  }

  function handleMouseDown(event) {
    if (!disabled && event.button === 0) { // Left mouse button
      isLongPressing = false;
      longPressTimer = setTimeout(() => {
        isLongPressing = true;
        dispatch('secondaryaction', { 
          data, 
          label, 
          mouseX: event.clientX, 
          mouseY: event.clientY,
          originalEvent: event
        });
      }, 500); // 500ms for long press
    }
  }

  function handleMouseUp() {
    clearTimeout(longPressTimer);
  }

  function handleMouseLeave() {
    clearTimeout(longPressTimer);
    isLongPressing = false;
  }
</script>

<button 
  class="rect-button" 
  class:disabled 
  style="width: {width}px; height: {height}px; background-color: {color};" 
  title={label || icon} 
  on:click={handleClick}
  on:contextmenu={handleContextMenu}
  on:mousedown={handleMouseDown}
  on:mouseup={handleMouseUp}
  on:mouseleave={handleMouseLeave}
>
  {#if $$slots.default}
    <slot />
  {:else if icon}
    <span class="rect-icon">{icon}</span>
  {:else if label}
    <span class="rect-text">{label}</span>
  {/if}
</button>

<style>
  .rect-button {
    /* Reset button styles */
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    color: white;
    font-family: inherit;
    
    /* Styling - simple rectangle with rounded corners */
    border-radius: 8px;
    border: none;
    transition: all 0.2s ease;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-shrink: 0;
    
    /* Content Alignment */
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .rect-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }
  
  .rect-button:active {
    transform: scale(0.98);
  }
  
  .rect-text {
    font-weight: normal;
    font-family: 'Arial Narrow', 'Liberation Sans Narrow', 'Helvetica Neue Condensed', 'Arial', sans-serif;
    font-stretch: ultra-condensed;
    text-align: center;
    font-size: 18px;
    line-height: 1.2;
    letter-spacing: -0.3px;
    word-break: break-word;
    white-space: normal;
    padding: 8px;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
  }
  
  .rect-icon {
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
  }
  
  .rect-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
    background-color: #2a2a2a !important;
  }
  
  .rect-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/SquareButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let color = '#27ae60'; // Green color to distinguish from octagons
  export let disabled = false;
  export let data = null;
  export let width = 60; // Width in px
  export let height = 60; // Height in px
  
  const dispatch = createEventDispatcher();
  
  let longPressTimer;
  let isLongPressing = false;

  function handleClick() {
    if (!disabled && !isLongPressing) {
      dispatch('click', { data, label });
    }
  }

  function handleContextMenu(event) {
    if (!disabled) {
      event.preventDefault();
      dispatch('secondaryaction', { 
        data, 
        label, 
        mouseX: event.clientX, 
        mouseY: event.clientY,
        originalEvent: event
      });
    }
  }

  function handleMouseDown(event) {
    if (!disabled && event.button === 0) { // Left mouse button
      isLongPressing = false;
      longPressTimer = setTimeout(() => {
        isLongPressing = true;
        dispatch('secondaryaction', { 
          data, 
          label, 
          mouseX: event.clientX, 
          mouseY: event.clientY,
          originalEvent: event
        });
      }, 500); // 500ms for long press
    }
  }

  function handleMouseUp() {
    clearTimeout(longPressTimer);
    setTimeout(() => { isLongPressing = false; }, 10);
  }

  function handleMouseLeave() {
    clearTimeout(longPressTimer);
    isLongPressing = false;
  }
</script>

<button 
  class="square-button" 
  class:disabled 
  style="width: {width}px; height: {height}px; background-color: {color};" 
  title={label} 
  on:click={handleClick}
  on:contextmenu={handleContextMenu}
  on:mousedown={handleMouseDown}
  on:mouseup={handleMouseUp}
  on:mouseleave={handleMouseLeave}
>
  <span class="square-text-wrapper">
    <span class="square-text">{label}</span>
  </span>
</button>

<style>
  .square-button {
    /* Reset button styles */
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    color: white;
    font-family: inherit;
    
    /* Styling */
    transition: background-color 0.2s ease, transform 0.1s ease;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-shrink: 0;
    border: 2px solid rgba(255, 255, 255, 0.2);
    
    /* Diamond shape through clip-path - no rotation needed */
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    
    /* Content Alignment */
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .square-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }
  
  .square-button:active {
    transform: scale(0.98);
  }
  
  .square-text-wrapper {
    /* No rotation needed - text stays normal */
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }
  
  .square-text {
    font-weight: normal;
    font-family: 'Arial Narrow', 'Liberation Sans Narrow', 'Helvetica Neue Condensed', 'Arial', sans-serif;
    font-stretch: ultra-condensed;
    /* Removed scaleX to fix text wrapping calculation */
    text-align: center;
    font-size: 19px; /* Increased by 20% from 16px */
    line-height: 1.0; /* Very tight line spacing for diamond shape */
    letter-spacing: -0.3px; /* Negative spacing to compensate for scaleX */
    word-break: break-word;
    white-space: normal;
    padding: 4px;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8); /* Stronger shadow */
  }
  
  .square-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
    background-color: #2a2a2a !important;
    border-color: rgba(255, 255, 255, 0.1);
  }
  
  .square-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/TimeButton.svelte ---

<script>
  import { currentTime, timeStore } from '../timeStore.js';
  import { addLog } from '../logStore.js';

  let showTimeSettings = false;

  function handleTimeClick() {
    showTimeSettings = !showTimeSettings;
    addLog('INFO', `Time settings ${showTimeSettings ? 'opened' : 'closed'}`);
  }

  function resetTimeOffset() {
    timeStore.resetTimeOffset();
    addLog('INFO', 'Time offset reset - using client time');
    showTimeSettings = false;
  }

  function formatTime(date) {
    return date.toLocaleTimeString('de-DE', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  function formatDate(date) {
    return date.toLocaleDateString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }
</script>

<div class="time-button-container">
  <button class="time-button" on:click={handleTimeClick}>
    <div class="time-display">
      <div class="time">{formatTime($currentTime)}</div>
      <div class="date">{formatDate($currentTime)}</div>
    </div>
  </button>

  {#if showTimeSettings}
    <div class="time-settings">
      <div class="settings-header">
        <h3>Время системы</h3>
        <button class="close-btn" on:click={() => showTimeSettings = false}>×</button>
      </div>
      
      <div class="time-info">
        <p><strong>Текущее время:</strong> {formatTime($currentTime)}</p>
        <p><strong>Дата:</strong> {formatDate($currentTime)}</p>
        
        {#if $timeStore.timeOffset !== 0}
          <p class="offset-info">
            <strong>Смещение:</strong> {Math.round($timeStore.timeOffset / 1000)}с
            <span class="offset-note">(используется серверное время)</span>
          </p>
        {:else}
          <p class="offset-info">
            <span class="offset-note">Используется время клиента</span>
          </p>
        {/if}
      </div>

      <div class="settings-actions">
        <button class="reset-btn" on:click={resetTimeOffset}>
          Сбросить смещение
        </button>
        <p class="reset-note">
          Касса будет пересчитывать время самостоятельно.<br>
          Системное время остается неизменным.
        </p>
      </div>
    </div>
  {/if}
</div>

<style>
  .time-button-container {
    position: relative;
    display: inline-block;
  }

  .time-button {
    background: #2c2c2e;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  .time-button:hover {
    background: #3a3a3c;
    border-color: #666;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
  }

  .time-display {
    text-align: center;
    color: #e0e0e0;
  }

  .time {
    font-size: 16px;
    font-weight: 700;
    color: #5fb85f;
    margin-bottom: 2px;
  }

  .date {
    font-size: 12px;
    color: #aaa;
    font-weight: 500;
  }

  .time-settings {
    position: absolute;
    bottom: 100%;
    right: 0;
    background: #2c2c2e;
    border: 1px solid #666;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 8px;
    box-shadow: 0 8px 16px rgba(0,0,0,0.5);
    z-index: 1000;
    min-width: 300px;
  }

  .settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #444;
  }

  .settings-header h3 {
    margin: 0;
    color: #e0e0e0;
    font-size: 16px;
  }

  .close-btn {
    background: none;
    border: none;
    color: #aaa;
    font-size: 20px;
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .close-btn:hover {
    color: #e0e0e0;
  }

  .time-info {
    margin-bottom: 16px;
  }

  .time-info p {
    margin: 6px 0;
    color: #e0e0e0;
    font-size: 14px;
  }

  .offset-info {
    margin-top: 12px !important;
    padding-top: 8px;
    border-top: 1px solid #444;
  }

  .offset-note {
    color: #aaa;
    font-size: 12px;
  }

  .settings-actions {
    text-align: center;
  }

  .reset-btn {
    background: #5a7a5a;
    border: 1px solid #4a6a4a;
    border-radius: 4px;
    color: white;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }

  .reset-btn:hover {
    background: #6a8a6a;
    border-color: #5a7a5a;
  }

  .reset-note {
    margin: 8px 0 0 0;
    font-size: 11px;
    color: #aaa;
    line-height: 1.3;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/components/UniversalButton.svelte ---

<script>
  import { createEventDispatcher } from 'svelte';
  
  export let label = '';
  export let icon = '';
  export let color = '#666666';
  export let textColor = '';
  export let backgroundStyle = '';
  export let disabled = false;
  export let data = null;
  export let width = 120;
  export let height = 80;
  export let shape = 'rect'; // 'rect' | 'hex'
  export let side = ''; // for half buttons: 'left' | 'right'
  export let active = false; // for active half buttons (back button, layout toggle)
  export let showShape = ''; // for layout toggle: 'hex' | 'rect' - shape to display as overlay
  
  const dispatch = createEventDispatcher();
  
  let longPressTimer;
  let isLongPressing = false;
  
  $: isHalfButton = side === 'left' || side === 'right';
  $: displayLabel = label;

  function handleClick() {
    if (!disabled && !isLongPressing) {
      dispatch('click', { data, label });
    }
  }

  function handleContextMenu(event) {
    if (!disabled) {
      event.preventDefault();
      dispatch('secondaryaction', { 
        data, 
        label, 
        mouseX: event.clientX, 
        mouseY: event.clientY,
        originalEvent: event
      });
    }
  }

  function handleMouseDown(event) {
    if (!disabled && event.button === 0) {
      isLongPressing = false;
      longPressTimer = setTimeout(() => {
        isLongPressing = true;
        dispatch('secondaryaction', { 
          data, 
          label, 
          mouseX: event.clientX, 
          mouseY: event.clientY,
          originalEvent: event
        });
      }, 500);
    }
  }

  function handleMouseUp() {
    clearTimeout(longPressTimer);
    setTimeout(() => { isLongPressing = false; }, 10);
  }

  function handleMouseLeave() {
    clearTimeout(longPressTimer);
    isLongPressing = false;
  }

  // Calculate clip-path for half hexagons (matching original HalfHexButton)
  $: clipPath = shape === 'hex' && isHalfButton 
    ? (side === 'left' 
        ? 'polygon(0% 0%, 100% 25%, 100% 75%, 0% 100%)' 
        : 'polygon(0% 25%, 100% 0%, 100% 100%, 0% 75%)')
    : (shape === 'hex' 
        ? 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
        : 'none');
</script>

<button 
  class="universal-button {shape}" 
  class:disabled 
  class:half={isHalfButton}
  class:left={side === 'left'}
  class:right={side === 'right'}
  class:active
  style="
    --button-width: {width}px; 
    --button-height: {height}px; 
    --button-color: {color};
    {textColor ? `--button-text-color: ${textColor};` : ''}
    {backgroundStyle ? `--button-background-style: ${backgroundStyle};` : ''}
    --clip-path: {clipPath};
  " 
  on:click={handleClick}
  on:contextmenu={handleContextMenu}
  on:mousedown={handleMouseDown}
  on:mouseup={handleMouseUp}
  on:mouseleave={handleMouseLeave}
>
  <div class="button-shape">
    {#if $$slots.default}
      <div class="slot-container">
        <slot />
      </div>
    {:else if icon || showShape}
      {#if icon}
        <span class="button-icon">{@html icon}</span>
      {/if}
      {#if showShape}
        <div class="shape-overlay {showShape}"></div>
      {/if}
    {:else if label}
      <span class="button-text">{displayLabel}</span>
    {/if}
  </div>
</button>

<style>
  .universal-button {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    width: var(--button-width, 120px);
    height: var(--button-height, 80px);
    position: relative;
    transition: transform 0.2s ease-out;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.4));
    flex-grow: 0;
    flex-shrink: 0;
    color: white;
    font-family: inherit;
  }

  .universal-button:hover {
    transform: scale(1.05);
    filter: drop-shadow(4px 4px 5px rgba(0,0,0,0.5));
  }

  .universal-button:active {
    transform: scale(0.98);
  }

  .button-shape {
    width: 100%;
    height: 100%;
    background-color: var(--button-color);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
  }

  /* Apply custom background style only when defined */
  .universal-button[style*="--button-background-style"] .button-shape {
    background: var(--button-background-style);
  }

  /* Special styling for half hex buttons */
  .universal-button.hex.half .button-shape {
    background-color: #5a7aad;
    border: none;
  }

  /* Active half buttons (back button and layout toggle) use receipt area color */
  .universal-button.hex.half.active .button-shape {
    background-color: #2c2c2e;
    border: none;
  }

  .universal-button.rect.half.active .button-shape {
    background-color: #2c2c2e;
  }

  /* Hexagon shape */
  .universal-button.hex .button-shape {
    clip-path: var(--clip-path);
  }

  /* Rectangle shape */
  .universal-button.rect .button-shape {
    border-radius: 8px;
  }

  .slot-container {
    width: 100%;
    height: 100%;
  }

  .button-text {
    font-weight: normal;
    font-family: 'Arial Narrow', 'Liberation Sans Narrow', 'Helvetica Neue Condensed', 'Arial', sans-serif;
    font-stretch: ultra-condensed;
    text-align: center;
    line-height: 1.1;
    letter-spacing: -0.5px;
    word-break: break-word;
    white-space: normal;
    padding: 5px;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
    color: var(--button-text-color, inherit);
  }

  /* Use the same text style for both hex and rect */
  .universal-button.hex .button-text,
  .universal-button.rect .button-text {
    font-size: 22px;
  }

  .button-icon {
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
    color: var(--button-text-color, inherit);
  }

  /* Special styling for half hex button text and icons */
  .universal-button.hex.half .button-text {
    font-size: 14px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    padding: 5px;
  }

  .universal-button.hex.half .button-icon {
    font-size: 32px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
  }

  /* Special styling for half rect button text and icons - same as hex halves */
  .universal-button.rect.half .button-text {
    font-size: 14px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    padding: 5px;
  }

  .universal-button.rect.half .button-icon {
    font-size: 32px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
  }

  .universal-button.disabled {
    pointer-events: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
    opacity: 0.3;
  }

  .universal-button.disabled .button-shape {
    background-color: #2a2a2a !important;
  }

  .universal-button.disabled:hover {
    transform: none;
    filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
  }

  /* Shape overlay for layout toggle button */
  .shape-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #404040;
    border: none;
    pointer-events: none;
    z-index: 1;
  }

  .shape-overlay.rect {
    width: 50px;
    height: 50px;
    /* квадрат - фиксированные одинаковые размеры в пикселях */
  }

  .shape-overlay.hex {
    width: 50px;
    height: 50px;
    /* правильный шестиугольник - фиксированные одинаковые размеры */
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
  }

  .shape-overlay.double-arrow-down {
    width: 50px;
    height: 50px;
    background: none;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #404040;
  }

  .shape-overlay.double-arrow-down::before {
    content: '';
    width: 50px;
    height: 50px;
    background-image: url("data:image/svg+xml,%3Csvg width='50' height='50' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 13L12 18L17 13M7 6L12 11L17 6' stroke='%23404040' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
  }
</style>

--- File: /packages/client-desktop/src/renderer/src/lib/logStore.js ---

import { writable } from 'svelte/store';
import { wsStore } from './wsStore.js';

export const logEntries = writable([]);

function sanitizeContext(context) {
  if (!context || typeof context !== 'object') {
    return {};
  }
  const sanitized = {};
  for (const key in context) {
    if (Object.prototype.hasOwnProperty.call(context, key)) {
      const value = context[key];
      if (['string', 'number', 'boolean'].includes(typeof value)) {
        sanitized[key] = value;
      } else if (value instanceof Error) {
        sanitized[key] = { message: value.message, stack: value.stack };
      } else {
        sanitized[key] = JSON.stringify(value, null, 2);
      }
    }
  }
  return sanitized;
}

export function addLog(level, message, context = {}) {
  const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
  logEntries.update(entries => [...entries.slice(-100), { timestamp, level, message, context }]);

  // Fire-and-forget log to the backend (only if WebSocket is connected)
  let currentWsState;
  wsStore.subscribe(state => currentWsState = state)();
  
  if (wsStore && currentWsState && currentWsState.connected) {
    wsStore.send({
      command: 'logClientEvent',
      payload: { level, message, context: sanitizeContext(context) }
    });
  }
}

export function clearLogs() {
  logEntries.set([]);
}

--- File: /packages/client-desktop/src/renderer/src/lib/orderStore.js ---

import { writable } from 'svelte/store';
import { wsStore } from './wsStore.js';
import { addLog } from './logStore.js';

function createOrderStore() {
	const { subscribe, set, update } = writable({
		transactionId: null,
		uuid: null,
		items: [],
		total: 0.00,
		tax: 0.00,
		status: 'idle', // idle, initializing, active, finished, error
		paymentType: null,
		paymentAmount: null,
		metadata: {}
	});

	let initializationPromise = null;
	let pendingItems = [];

	function resetOrder() {
		set({
			transactionId: null,
			uuid: null,
			items: [],
			total: 0.00,
			tax: 0.00,
			status: 'idle',
			paymentType: null,
			paymentAmount: null,
			metadata: {}
		});
		initializationPromise = null;
		pendingItems = [];
		addLog('INFO', 'Order reset and ready for new transaction.');
	}

	wsStore.subscribe(state => {
		let currentStoreState;
		subscribe(s => currentStoreState = s)();

		if (state.lastMessage?.command === 'orderUpdated' && state.lastMessage.status === 'success' && state.lastMessage.payload) {
			const updatedTx = state.lastMessage.payload;
			update(store => ({
				...store,
				transactionId: updatedTx.id,
				uuid: updatedTx.uuid,
				items: updatedTx.items || [],
				total: parseFloat(updatedTx.total_amount),
				tax: parseFloat(updatedTx.tax_amount),
				status: 'active',
				metadata: updatedTx.metadata ? (typeof updatedTx.metadata === 'string' ? JSON.parse(updatedTx.metadata) : updatedTx.metadata) : {}
			}));
			addLog('INFO', `Order ${updatedTx.id} updated.`);
			
			// If we just became active and have pending items, add them now
			if (currentStoreState.status === 'initializing' && pendingItems.length > 0) {
				const itemsToAdd = [...pendingItems];
				pendingItems = [];
				itemsToAdd.forEach(({ itemId, quantity, userId }) => {
					addLog('INFO', `Adding queued item ${itemId} to transaction ${updatedTx.id}`);
					wsStore.send({
						command: 'addItemToTransaction',
						payload: {
							transactionId: updatedTx.id,
							itemId,
							quantity,
							userId
						}
					});
				});
			}
		} else if (state.lastMessage?.command === 'transactionFinished' && state.lastMessage.status === 'success') {
			const finishedTx = state.lastMessage.payload;
			if (finishedTx.transaction) {
				update(store => ({
					...store,
					transactionId: finishedTx.transaction.id,
					uuid: finishedTx.transaction.uuid,
					items: finishedTx.transaction.items || [],
					total: parseFloat(finishedTx.transaction.total_amount),
					tax: parseFloat(finishedTx.transaction.tax_amount),
					status: 'finished',
					paymentType: finishedTx.transaction.payment_type,
					paymentAmount: parseFloat(finishedTx.transaction.payment_amount),
					metadata: finishedTx.transaction.metadata ? (typeof finishedTx.transaction.metadata === 'string' ? JSON.parse(finishedTx.transaction.metadata) : finishedTx.transaction.metadata) : {}
				}));
				addLog('SUCCESS', `Transaction ${finishedTx.transaction.id} finished successfully.`);
			} else {
				addLog('SUCCESS', `Transaction ${currentStoreState.transactionId} finished successfully.`);
				update(store => ({ ...store, status: 'finished' }));
			}

			// Auto-reset after a short delay to allow UI to show finished state briefly
			setTimeout(() => {
				addLog('INFO', 'Auto-resetting order for next transaction.');
				resetOrder();
			}, 2000); // 2 second delay
		}
	});

	async function initializeOrder(userId = 1, metadata = {}) {
		if (initializationPromise) {
			return initializationPromise;
		}

		update(s => ({ ...s, status: 'initializing' }));
		addLog('INFO', 'Initializing new order...');
		
		initializationPromise = new Promise((resolve, reject) => {
			let unsubscribe;
			unsubscribe = wsStore.subscribe(state => {
				if (state.lastMessage?.command === 'orderUpdated' && state.lastMessage.status === 'success') {
					if (unsubscribe) unsubscribe();
					resolve(state.lastMessage.payload);
				} else if (state.lastMessage?.command === 'orderUpdated' && state.lastMessage.status === 'error') {
					if (unsubscribe) unsubscribe();
					update(s => ({ ...s, status: 'error' }));
					reject(new Error(state.lastMessage.payload?.message || 'Failed to initialize order'));
				}
			});
		});

		wsStore.send({
			command: 'findOrCreateActiveTransaction',
			payload: { criteria: { metadata }, userId }
		});

		return initializationPromise;
	}

	async function addItem(itemId, quantity = 1, userId = 1) {
		let currentStoreState;
		subscribe(s => currentStoreState = s)();

		// If we're idle, initialize the order first and queue this item
		if (currentStoreState.status === 'idle') {
			addLog('INFO', `First item click detected. Initializing order and queuing item ${itemId}...`);
			pendingItems.push({ itemId, quantity, userId });
			try {
				await initializeOrder(userId);
			} catch (error) {
				addLog('ERROR', `Failed to initialize order: ${error.message}`);
				pendingItems = [];
				return;
			}
			return;
		}

		// If we're still initializing, queue the item
		if (currentStoreState.status === 'initializing') {
			addLog('INFO', `Order initializing. Queuing item ${itemId}...`);
			pendingItems.push({ itemId, quantity, userId });
			return;
		}

		// If we're active, add item directly
		if (currentStoreState.status === 'active' && currentStoreState.transactionId) {
			addLog('INFO', `Adding item ${itemId} to transaction ${currentStoreState.transactionId}`);
			wsStore.send({
				command: 'addItemToTransaction',
				payload: {
					transactionId: currentStoreState.transactionId,
					itemId,
					quantity,
					userId
				}
			});
			return;
		}

		addLog('ERROR', 'Cannot add item: invalid order state.');
	}

	async function finishOrder(paymentData, userId = 1) {
		let currentStoreState;
		subscribe(s => currentStoreState = s)();

		if (!currentStoreState.transactionId || currentStoreState.status !== 'active') {
			addLog('ERROR', 'No active order to finish.');
			return;
		}

		addLog('INFO', `Finishing transaction ${currentStoreState.transactionId}...`);
		wsStore.send({
			command: 'finishTransaction',
			payload: {
				transactionId: currentStoreState.transactionId,
				paymentData,
				userId
			}
		});
	}

	async function parkCurrentOrder(tableIdentifier, userId = 1, updateTimestamp = true) {
		let currentStoreState;
		subscribe(s => currentStoreState = s)();

		if (!currentStoreState.transactionId || currentStoreState.status !== 'active') {
			addLog('ERROR', 'No active order to park.');
			return;
		}

		addLog('INFO', `Parking transaction ${currentStoreState.transactionId} to table ${tableIdentifier} (updateTime: ${updateTimestamp})...`);
		
		return new Promise(async (resolve, reject) => {
			const unsubscribe = wsStore.subscribe(async (state) => {
				if (state.lastMessage?.command === 'parkTransactionResponse' && state.lastMessage.status === 'success') {
					unsubscribe();
					resetOrder();
					addLog('SUCCESS', `Order parked to table ${tableIdentifier}`);
					
					// Refresh parked orders list immediately
					try {
						const { parkedOrdersStore } = await import('./parkedOrdersStore.js');
						await parkedOrdersStore.refresh();
						addLog('INFO', 'Parked orders list refreshed');
					} catch (error) {
						addLog('WARNING', 'Could not refresh parked orders list after parking');
					}
					
					resolve(state.lastMessage.payload);
				} else if (state.lastMessage?.command === 'parkTransactionResponse' && state.lastMessage.status === 'error') {
					unsubscribe();
					addLog('ERROR', `Failed to park order: ${state.lastMessage.payload?.message || 'Unknown error'}`);
					reject(new Error(state.lastMessage.payload?.message || 'Failed to park order'));
				}
			});

			wsStore.send({
				command: 'parkTransaction',
				payload: {
					transactionId: currentStoreState.transactionId,
					tableIdentifier,
					userId,
					updateTimestamp
				}
			});
		});
	}

	function loadOrder(orderData) {
		addLog('INFO', `Loading order ${orderData.id}...`);
		update(store => ({
			...store,
			transactionId: orderData.id,
			uuid: orderData.uuid,
			items: orderData.items || [],
			total: parseFloat(orderData.total_amount),
			tax: parseFloat(orderData.tax_amount),
			status: 'active',
			metadata: orderData.metadata ? (typeof orderData.metadata === 'string' ? JSON.parse(orderData.metadata) : orderData.metadata) : {}
		}));
		addLog('SUCCESS', `Order ${orderData.id} loaded successfully`);
	}


	async function assignTableNumber(tableNumber, userId = 1) {
		let currentStoreState;
		subscribe(s => currentStoreState = s)();

		if (!currentStoreState.transactionId || currentStoreState.status !== 'active') {
			addLog('ERROR', 'No active order to assign table number to.');
			throw new Error('No active order to assign table number to.');
		}

		addLog('INFO', `Checking availability and assigning table ${tableNumber} to transaction ${currentStoreState.transactionId}...`);
		
		try {
			// Check table availability first
			const operationId = Math.random().toString(36).substring(2, 15);
			const checkResult = await new Promise((resolve, reject) => {
				const timeout = setTimeout(() => {
					if (unsubscribe) unsubscribe();
					reject(new Error('Table availability check timeout'));
				}, 5000);

				let unsubscribe;
				unsubscribe = wsStore.subscribe(state => {
					if (state.lastMessage?.command === 'checkTableAvailabilityResponse' &&
						state.lastMessage?.operationId === operationId) {
						clearTimeout(timeout);
						if (unsubscribe) unsubscribe();
						resolve(state.lastMessage);
					}
				});

				wsStore.send({
					operationId,
					command: 'checkTableAvailability',
					payload: {
						tableNumber,
						excludeTransactionId: currentStoreState.transactionId
					}
				});
			});

			console.log('Table availability check result:', checkResult);

			if (checkResult.status === 'success' && checkResult.payload.isInUse) {
				addLog('ERROR', `Table ${tableNumber} is already in use by another order`);
				// Return special signal instead of throwing error
				return { tableInUse: true };
			}

			// Table is available, proceed with assignment
			// Update local metadata immediately for UI responsiveness
			update(store => ({
				...store,
				metadata: {
					...store.metadata,
					table: tableNumber
				}
			}));

			// Send update to backend
			wsStore.send({
				command: 'updateTransactionMetadata',
				payload: {
					transactionId: currentStoreState.transactionId,
					metadata: {
						...currentStoreState.metadata,
						table: tableNumber
					},
					userId
				}
			});

			addLog('SUCCESS', `Table ${tableNumber} assigned to order`);
		} catch (error) {
			addLog('ERROR', `Failed to assign table ${tableNumber}: ${error.message}`);
			throw error;
		}
	}

	async function clearActiveOrderView() {
		addLog('INFO', 'Clearing active order view');
		resetOrder();
		// Import parkedOrdersStore dynamically to avoid circular dependencies
		try {
			const { parkedOrdersStore } = await import('./parkedOrdersStore.js');
			await parkedOrdersStore.refreshParkedOrders();
		} catch (error) {
			addLog('WARNING', 'Could not refresh parked orders after clearing view');
		}
	}

	return {
		subscribe,
		set,
		update,
		initializeOrder,
		addItem,
		finishOrder,
		resetOrder,
		parkCurrentOrder,
		assignTableNumber,
		loadOrder,
		clearActiveOrderView
	};
}

export const orderStore = createOrderStore();

--- File: /packages/client-desktop/src/renderer/src/lib/parkedOrdersStore.js ---

import { writable } from 'svelte/store';
import { wsStore } from './wsStore.js';
import { addLog } from './logStore.js';

class ParkedOrdersStore {
  constructor() {
    this.store = writable([]);
    this.subscribe = this.store.subscribe;
    this.set = this.store.set;
    this.update = this.store.update;
  }

  async refreshParkedOrders() {
    try {
      addLog('DEBUG', 'Requesting parked transactions...');
      const operationId = this.generateUUID();
      addLog('DEBUG', `Generated operationId: ${operationId}`);
      
      // Use WebSocket with HTTP fallback
      const result = await this.sendRequestWithFallback(operationId, 'getParkedTransactions', {});
      
      addLog('DEBUG', `Parked transactions response: ${JSON.stringify(result)}`);
      
      if (result.status === 'success') {
        addLog('DEBUG', `Setting parked orders: ${JSON.stringify(result.payload)}`);
        this.set(result.payload || []);
      } else {
        addLog('ERROR', `Failed to fetch parked orders: ${JSON.stringify(result)}`);
        this.set([]);
      }
    } catch (error) {
      addLog('ERROR', `Error fetching parked orders: ${error.message}`);
      this.set([]);
    }
  }

  // Helper method to send requests with WebSocket + HTTP fallback
  async sendRequestWithFallback(operationId, command, payload) {
    try {
      // First try WebSocket
      return await this.sendWebSocketRequest(operationId, command, payload);
    } catch (error) {
      addLog('WARNING', `WebSocket request failed, trying HTTP fallback: ${error.message}`);
      
      // Fallback to HTTP
      try {
        return await this.sendHttpRequest(operationId, command, payload);
      } catch (httpError) {
        addLog('ERROR', `Both WebSocket and HTTP requests failed: ${httpError.message}`);
        throw httpError;
      }
    }
  }

  // WebSocket request method
  sendWebSocketRequest(operationId, command, payload) {
    return new Promise((resolve, reject) => {
      // Check if WebSocket is connected before attempting to send
      let currentWsState;
      wsStore.subscribe(state => currentWsState = state)();
      
      if (!currentWsState || !currentWsState.connected) {
        reject(new Error('WebSocket is not connected'));
        return;
      }

      const timeout = setTimeout(() => {
        unsubscribe();
        reject(new Error('WebSocket request timeout'));
      }, 3000); // Shorter timeout for WebSocket to allow HTTP fallback

      const unsubscribe = wsStore.subscribe(state => {
        if (state.lastMessage && state.lastMessage.operationId === operationId) {
          clearTimeout(timeout);
          unsubscribe();
          resolve(state.lastMessage);
        }
      });

      wsStore.send({
        operationId,
        command,
        payload
      });
    });
  }

  // HTTP fallback request method
  async sendHttpRequest(operationId, command, payload) {
    const response = await fetch('/api/websocket-fallback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        operationId,
        command,
        payload
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP request failed: ${response.status}`);
    }

    const result = await response.json();
    return result;
  }

  // Alias for external use
  refresh() {
    return this.refreshParkedOrders();
  }

  async activateOrder(transactionId, updateTimestamp = false) {
    try {
      const operationId = this.generateUUID();
      const result = await this.sendRequestWithFallback(operationId, 'activateTransaction', {
        transactionId: transactionId,
        userId: 1, // TODO: Get from auth store when available
        updateTimestamp: updateTimestamp
      });
      
      if (result.status === 'success') {
        // Only refresh the parked orders list if we're actually changing the order
        if (updateTimestamp) {
          await this.refreshParkedOrders();
        }
        return result.payload;
      } else {
        throw new Error(result.payload?.message || 'Failed to activate order');
      }
    } catch (error) {
      addLog('ERROR', `Error activating order: ${error.message}`);
      throw error;
    }
  }

  generateUUID() {
    // Simple UUID v4 generator
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}

export const parkedOrdersStore = new ParkedOrdersStore();

--- File: /packages/client-desktop/src/renderer/src/lib/pinpadStore.js ---

import { writable } from 'svelte/store';
import { orderStore } from './orderStore.js';

function createPinpadStore() {
    const { subscribe, set, update } = writable({
        isActive: false,
        mode: null, // 'table', 'quantity', 'agent'
        layout: 'numeric', // 'numeric' or 'alpha'
        liveValue: '',
        confirmCallback: null,
        cancelCallback: null,
        lastRedClickTime: 0,
        errorMessage: null
    });

    return {
        subscribe,
        
        activate(mode, confirmCallback, cancelCallback, layout = 'numeric') {
            set({
                isActive: true,
                mode,
                layout,
                liveValue: '',
                confirmCallback,
                cancelCallback,
                lastRedClickTime: 0,
                errorMessage: null
            });
        },

        deactivate() {
            set({
                isActive: false,
                mode: null,
                layout: 'numeric',
                liveValue: '',
                confirmCallback: null,
                cancelCallback: null,
                lastRedClickTime: 0,
                errorMessage: null
            });
        },

        append(char) {
            update(state => {
                if (!state.isActive) return state;
                return {
                    ...state,
                    liveValue: state.liveValue + char,
                    errorMessage: null
                };
            });
        },

        backspace() {
            update(state => {
                if (!state.isActive) return state;
                return {
                    ...state,
                    liveValue: state.liveValue.slice(0, -1),
                    errorMessage: null // Clear error when user starts typing
                };
            });
        },

        clear() {
            update(state => {
                if (!state.isActive) return state;
                return {
                    ...state,
                    liveValue: '',
                    errorMessage: null
                };
            });
        },

        async confirm() {
            let state;
            let callback;
            let value;
            
            // Get current state
            update(currentState => {
                state = currentState;
                return currentState;
            });
            
            if (!state.isActive || !state.confirmCallback) return;
            
            callback = state.confirmCallback;
            value = state.liveValue;
            
            try {
                // Execute callback and wait for it to complete
                await callback(value);
                
                // Only deactivate after successful callback
                update(() => ({
                    isActive: false,
                    mode: null,
                    liveValue: '',
                    confirmCallback: null,
                    cancelCallback: null,
                    lastRedClickTime: 0,
                    errorMessage: null
                }));
            } catch (error) {
                console.error('Pinpad confirm callback failed:', error);
                
                // For all errors, deactivate to prevent stuck state
                update(() => ({
                    isActive: false,
                    mode: null,
                    liveValue: '',
                    confirmCallback: null,
                    cancelCallback: null,
                    lastRedClickTime: 0,
                    errorMessage: null
                }));
            }
        },

        cancel() {
            update(state => {
                const now = Date.now();
                const timeSinceLastClick = now - state.lastRedClickTime;
                
                // Double click detection (within 300ms)
                if (timeSinceLastClick < 300) {
                    // Double click - full cancel
                    const callback = state.cancelCallback;
                    const newState = {
                        isActive: false,
                        mode: null,
                        liveValue: '',
                        confirmCallback: null,
                        cancelCallback: null,
                        lastRedClickTime: 0,
                        errorMessage: null
                    };
                    
                    if (callback) {
                        setTimeout(() => callback(), 0);
                    }
                    
                    return newState;
                } else {
                    // Single click - just clear
                    return {
                        ...state,
                        liveValue: '',
                        lastRedClickTime: now,
                        errorMessage: null // Clear error on single click
                    };
                }
            });
        },

        // Helper methods for specific modes
        activateTableEntry() {
            this.activate(
                'table',
                async (tableNumber) => {
                    if (tableNumber && tableNumber.trim()) {
                        try {
                            const result = await orderStore.assignTableNumber(tableNumber.trim());
                            // Check if table was in use
                            if (result && result.tableInUse) {
                                // Just clear the input and keep pinpad open - no error message needed
                                update(state => ({
                                    ...state,
                                    liveValue: '' // Clear the input
                                }));
                                // Return nothing - this will NOT close the pinpad but also won't break flow
                                return;
                            }
                            return result;
                        } catch (error) {
                            // For other errors, still throw to close pinpad
                            throw error;
                        }
                    }
                },
                () => {
                    // Cancel callback - nothing special needed
                }
            );
        },

        // New method for table entry with auto-collapse
        activateTableEntryWithAutoCollapse() {
            this.activate(
                'table',
                async (tableNumber) => {
                    if (tableNumber && tableNumber.trim()) {
                        try {
                            const result = await orderStore.assignTableNumber(tableNumber.trim());
                            // Check if table was in use
                            if (result && result.tableInUse) {
                                // Just clear the input and keep pinpad open - no error message needed
                                update(state => ({
                                    ...state,
                                    liveValue: '' // Clear the input
                                }));
                                // Return nothing - this will NOT close the pinpad but also won't break flow
                                return;
                            }
                            
                            // Table assigned successfully - now auto-collapse the order
                            // Get current order state after assignment attempt
                            let currentOrderState;
                            orderStore.subscribe(state => currentOrderState = state)();
                            
                            const hasItems = currentOrderState.items && currentOrderState.items.length > 0;
                            const hasTable = currentOrderState.metadata && currentOrderState.metadata.table;
                            
                            if (hasItems && hasTable) {
                                // Park the order and return to start position
                                await orderStore.parkCurrentOrder(hasTable, 1, false); // updateTimestamp = false
                                
                                // Import parkedOrdersStore to refresh
                                const { parkedOrdersStore } = await import('./parkedOrdersStore.js');
                                await parkedOrdersStore.refresh();
                                
                                // Reset order and return to categories
                                orderStore.resetOrder();
                                
                                // Emit a custom event to signal that we should return to categories
                                window.dispatchEvent(new CustomEvent('autoCollapseComplete'));
                                
                                // Signal that we should return to categories
                                return { autoCollapsed: true };
                            }
                            
                            return result;
                        } catch (error) {
                            // For other errors, still throw to close pinpad
                            throw error;
                        }
                    }
                },
                () => {
                    // Cancel callback - nothing special needed
                }
            );
        },

        activateAlphaInput(confirmCallback, cancelCallback) {
            this.activate('agent', confirmCallback, cancelCallback, 'alpha');
        }
    };
}

export const pinpadStore = createPinpadStore();

--- File: /packages/client-desktop/src/renderer/src/lib/receiptsStore.js ---

import { writable } from 'svelte/store';
import { wsStore } from './wsStore.js';
import { addLog } from './logStore.js';

function createReceiptsStore() {
	const { subscribe, set, update } = writable({
		receipts: [],
		loading: false,
		error: null,
		lastUpdated: null
	});

	// Listen for WebSocket responses
	wsStore.subscribe(state => {
		if (state.lastMessage?.command === 'getRecentReceiptsResponse') {
			if (state.lastMessage.status === 'success') {
				const payload = state.lastMessage.payload;
				if (payload.success && payload.transactions) {
					// Parse metadata for each transaction
					const transactionsWithParsedMetadata = payload.transactions.map(transaction => ({
						...transaction,
						metadata: transaction.metadata ? JSON.parse(transaction.metadata) : {}
					}));
					
					update(store => ({
						...store,
						receipts: transactionsWithParsedMetadata,
						loading: false,
						error: null,
						lastUpdated: new Date()
					}));
					addLog('INFO', `Loaded ${payload.transactions.length} recent receipts.`);
				} else {
					update(store => ({
						...store,
						loading: false,
						error: payload.message || 'Failed to load receipts'
					}));
					addLog('ERROR', `Failed to load receipts: ${payload.message || 'Unknown error'}`);
				}
			} else {
				update(store => ({
					...store,
					loading: false,
					error: state.lastMessage.payload?.message || 'Failed to load receipts'
				}));
				addLog('ERROR', `Failed to load receipts: ${state.lastMessage.payload?.message || 'Unknown error'}`);
			}
		}
	});

	function loadReceipts(limit = 20) {
		update(store => ({ ...store, loading: true, error: null }));
		addLog('INFO', `Loading recent receipts (limit: ${limit})...`);
		
		// Check if WebSocket is connected before sending
		let currentWsState;
		wsStore.subscribe(state => currentWsState = state)();
		
		if (currentWsState && currentWsState.connected) {
			wsStore.send({
				command: 'getRecentReceipts',
				payload: { limit }
			});
		} else {
			addLog('WARNING', 'WebSocket not connected, skipping receipt load');
			update(store => ({ 
				...store, 
				loading: false, 
				error: 'WebSocket connection not available' 
			}));
		}
	}

	function refresh() {
		addLog('INFO', 'Refreshing receipts...');
		loadReceipts();
	}

	return {
		subscribe,
		loadReceipts,
		refresh
	};
}

export const receiptsStore = createReceiptsStore();

--- File: /packages/client-desktop/src/renderer/src/lib/recoveryStore.js ---

import { writable } from 'svelte/store';
import { wsStore } from './wsStore.js';
import { addLog } from './logStore.js';

function createRecoveryStore() {
  const { subscribe, set, update } = writable({
    status: 'idle', // idle, awaiting_resolution, resolving, awaiting_confirmation
    pendingTransactions: [],
    companyInfo: null,
    error: null,
  });

  // Listen for pending transactions and company info from the backend upon connection
  wsStore.subscribe(state => {
    if (state.lastMessage?.command === 'pendingTransactions' && state.lastMessage.payload?.transactions) {
      const txs = state.lastMessage.payload.transactions;
      if (txs.length > 0) {
        addLog('INFO', `Received ${txs.length} pending transactions for recovery.`);
        set({
          status: 'awaiting_resolution',
          pendingTransactions: txs,
          companyInfo: null,
          error: null
        });
      }
    }

    // Listen for initial app data (company info when no pending transactions)
    if (state.lastMessage?.command === 'initialAppData' && state.lastMessage.payload?.companyInfo) {
      const companyInfo = state.lastMessage.payload.companyInfo;
      addLog('INFO', 'Received company information for startup confirmation.');
      update(s => ({
        ...s,
        status: 'awaiting_confirmation',
        companyInfo,
        error: null
      }));
    }

    // Listen for resolution responses
    if (state.lastMessage?.command === 'resolvePendingTransactionResponse') {
      const response = state.lastMessage;
      if (response.status === 'success') {
        const transactionId = response.payload.transactionId;
        const action = response.payload.action;
        addLog('INFO', `Transaction ${transactionId} successfully ${action}.`);
        
        // Remove the resolved transaction from the list
        update(s => ({
          ...s,
          pendingTransactions: s.pendingTransactions.filter(tx => tx.id !== transactionId),
          status: s.pendingTransactions.length > 1 ? 'awaiting_resolution' : 'idle',
          error: null
        }));
      } else {
        const error = response.payload?.error || 'Unknown error';
        addLog('ERROR', `Failed to resolve transaction: ${error}`);
        update(s => ({ ...s, status: 'awaiting_resolution', error }));
      }
    }
  });

  async function confirmNoPending() {
    addLog('INFO', 'User confirmed company information - proceeding to main application.');
    update(s => ({ ...s, status: 'idle', companyInfo: null }));
  }

  async function resolveTransaction(transactionId, resolution, userId = 1) {
    addLog('INFO', `Attempting to resolve transaction ${transactionId} with action: ${resolution}`);
    update(s => ({ ...s, status: 'resolving', error: null }));

    // Check if WebSocket is connected before sending
    let currentWsState;
    wsStore.subscribe(state => currentWsState = state)();
    
    if (!currentWsState || !currentWsState.connected) {
      addLog('ERROR', 'WebSocket not connected, cannot resolve transaction');
      update(s => ({ ...s, status: 'awaiting_resolution', error: 'WebSocket connection not available' }));
      return;
    }

    try {
      const response = await wsStore.send({
        command: 'resolvePendingTransaction',
        payload: { transactionId, resolution, userId }
      });

      if (response.error) {
        addLog('ERROR', `WebSocket error: ${response.error}`);
        update(s => ({ ...s, status: 'awaiting_resolution', error: response.error }));
      }
    } catch (error) {
      addLog('ERROR', `Failed to send resolution command: ${error.message}`);
      update(s => ({ ...s, status: 'awaiting_resolution', error: error.message }));
    }
  }

  return {
    subscribe,
    resolveTransaction,
    confirmNoPending
  };
}

export const recoveryStore = createRecoveryStore();

--- File: /packages/client-desktop/src/renderer/src/lib/timeStore.js ---

import { writable, derived } from 'svelte/store';

class TimeStore {
  constructor() {
    this.store = writable({
      serverTime: null,
      clientTime: null,
      timeOffset: 0, // Разница между сервером и клиентом в миллисекундах
      lastSync: null
    });
    
    this.subscribe = this.store.subscribe;
    this.update = this.store.update;
    this.set = this.store.set;
  }

  // Обновляет серверное время и пересчитывает offset
  updateServerTime(serverTimeISO) {
    const serverTime = new Date(serverTimeISO);
    const clientTime = new Date();
    const timeOffset = serverTime.getTime() - clientTime.getTime();
    
    this.update(state => ({
      ...state,
      serverTime,
      clientTime,
      timeOffset,
      lastSync: clientTime
    }));
  }

  // Возвращает текущее серверное время (рассчитанное)
  getServerTime() {
    let currentState;
    this.subscribe(state => currentState = state)();
    
    if (!currentState.lastSync) {
      return new Date(); // Fallback к клиентскому времени
    }
    
    const now = new Date();
    return new Date(now.getTime() + currentState.timeOffset);
  }

  // Форматирует разницу времени используя синхронизированное время
  formatTimeElapsed(dateString) {
    // For calculating elapsed time, we should use direct UTC comparison
    // to avoid double-applying timezone offsets
    const now = new Date(); // Current client time in UTC
    const date = new Date(dateString); // Parse the timestamp (should be UTC)
    
    // Calculate the difference directly in UTC
    const diffMs = now.getTime() - date.getTime();
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    
    return diffMinutes > 0 ? diffMinutes : 0;
  }

  // Сбрасывает offset (для ручной корректировки)
  resetTimeOffset() {
    this.update(state => ({
      ...state,
      timeOffset: 0,
      lastSync: null
    }));
  }
}

export const timeStore = new TimeStore();

// Derived store для отображения текущего времени
export const currentTime = derived(
  timeStore,
  ($timeStore, set) => {
    const updateTime = () => {
      const serverTime = timeStore.getServerTime();
      set(serverTime);
    };

    updateTime();
    const interval = setInterval(updateTime, 1000);

    return () => clearInterval(interval);
  },
  new Date()
);

--- File: /packages/client-desktop/src/renderer/src/lib/viewStore.js ---

import { writable, derived } from 'svelte/store';

export const currentView = writable('order');

// Dynamic view cycle that adapts based on the current view
export const viewCycle = derived(currentView, ($currentView) => {
  const allViews = ['order', 'receipts', 'agent'];
  
  // Start the cycle from the current view
  const currentIndex = allViews.indexOf($currentView);
  
  // Create a new array starting from current view
  const cycle = [
    ...allViews.slice(currentIndex),  // From current to end
    ...allViews.slice(0, currentIndex)  // From start to current (exclusive)
  ];
  
  return cycle;
});

--- File: /packages/client-desktop/src/renderer/src/lib/wsStore.js ---

import { writable } from 'svelte/store';

// Create a writable store for WebSocket state
function createWebSocketStore() {
  const { subscribe, set, update } = writable({
    connected: false,
    isConnected: false, // Keep for backward compatibility
    lastMessage: null,
    error: null
  });

  let ws = null;
  const pendingOperations = new Map();

  // Connect to WebSocket
  function connect() {
    try {
      ws = new WebSocket('ws://localhost:3030');
      
      ws.onopen = () => {
        console.log('WebSocket connected');
        update(state => ({ ...state, connected: true, isConnected: true, error: null }));
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          console.log('WebSocket message received:', message);
          
          // Update server time if provided
          if (message.serverTime) {
            import('./timeStore.js').then(({ timeStore }) => {
              timeStore.updateServerTime(message.serverTime);
            });
          }
          
          // Update store with the last message
          update(state => ({ ...state, lastMessage: message }));
          
          // Handle operation responses
          if (message.operationId && pendingOperations.has(message.operationId)) {
            const resolve = pendingOperations.get(message.operationId);
            pendingOperations.delete(message.operationId);
            resolve(message);
          }
        } catch (error) {
          console.error('Error parsing WebSocket message:', error);
        }
      };

      ws.onclose = () => {
        console.log('WebSocket disconnected');
        update(state => ({ ...state, connected: false, isConnected: false }));
        // Auto-reconnect after 3 seconds
        setTimeout(connect, 3000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        update(state => ({ ...state, error: error.message }));
      };
    } catch (error) {
      console.error('Failed to create WebSocket connection:', error);
      update(state => ({ ...state, error: error.message }));
    }
  }

  // Send message via WebSocket
  function send(message) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      const messageWithId = {
        operationId: generateUUID(),
        ...message
      };
      
      console.log('Sending WebSocket message:', messageWithId);
      ws.send(JSON.stringify(messageWithId));
      
      // Return a promise that resolves when response is received
      return new Promise((resolve) => {
        pendingOperations.set(messageWithId.operationId, resolve);
        
        // Timeout after 10 seconds
        setTimeout(() => {
          if (pendingOperations.has(messageWithId.operationId)) {
            pendingOperations.delete(messageWithId.operationId);
            resolve({ error: 'Timeout waiting for response' });
          }
        }, 10000);
      });
    } else {
      // Silently fail if WebSocket is not connected (avoids startup errors)
      return Promise.resolve({ error: 'WebSocket not connected' });
    }
  }

  // Simple UUID v4 generator (to avoid crypto.randomUUID dependency issues)
  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Initialize connection
  connect();

  return {
    subscribe,
    send,
    connect
  };
}

export const wsStore = createWebSocketStore();

--- File: /packages/client-desktop/src/renderer/src/main.js ---

import './app.css'
import { mount } from 'svelte'
import App from './App.svelte'
import { addLog } from './lib/logStore.js';

// --- Global Error Handling ---
window.onerror = function (message, source, lineno, colno, error) {
  addLog('ERROR', 'Unhandled Frontend Exception', {
    type: 'window.onerror',
    message: message,
    source: source,
    lineno: lineno,
    colno: colno,
    error: error ? error.stack : 'N/A',
  });
  return true; // Prevents the default browser error handling
};

window.addEventListener('unhandledrejection', event => {
  addLog('ERROR', 'Unhandled Promise Rejection', {
    type: 'unhandledrejection',
    reason: event.reason ? (event.reason.message || event.reason) : 'No reason provided',
    stack: event.reason ? event.reason.stack : 'N/A',
  });
});


const app = mount(App, {
  target: document.getElementById('app'),
})

export default app

--- File: /packages/client-desktop/src/renderer/vite.config.js ---

import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig({
  plugins: [svelte()],
  server: {
    port: 3001,
    proxy: {
      '/api': {
        target: 'http://localhost:3030', // Proxy API requests to the backend
        changeOrigin: true,
        ws: true, // Also proxy WebSockets
      }
    }
  }
})

--- File: /public/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="ecKasse - LLM-Powered POS System"
    />
    <title>ecKasse</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

