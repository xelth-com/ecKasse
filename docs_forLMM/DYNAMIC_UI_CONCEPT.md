# Концепция: Динамический "Квантовый" UI для ecKasse

## 1. Цель

Перейти от статичной сетки к интеллектуальной, контекстно-зависимой компоновке кнопок, которая адаптируется к задачам пользователя в реальном времени. Это позволит максимально эффективно использовать экранное пространство, показывая только релевантные действия и избегая перегруженности интерфейса.

## 2. Основная идея: "Квантовая" модель интерфейса

В основе концепции лежит аналогия с квантовой механикой. Вместо жестко закрепленных позиций, каждая кнопка (действие) имеет "вероятность" появления в определенных ячейках сетки.

* **Суперпозиция:** В любой момент времени ячейка сетки потенциально может содержать несколько действий с разной вероятностью.
* **Коллапс волновой функции:** Контекст пользователя (например, переход в подменю или начало оплаты) действует как "наблюдатель". Он "коллапсирует" состояние сетки, и в ячейках материализуются кнопки с наивысшей вероятностью (приоритетом) для данного контекста.
* **Принцип неопределенности:** Если высокоприоритетное действие (например, отображение списка товаров) занимает основное место системной кнопки (например, "Оплата"), то кнопка "Оплата" либо исчезает, либо "появляется" в другом, менее вероятном, но свободном месте.
* **Принцип исключения:** Одна и та же кнопка (действие) не может появиться в нескольких местах одновременно. После "коллапса" в одной ячейке, ее вероятность в других падает до нуля.

## 3. Технические принципы реализации

Эта модель будет реализована через продвинутый **менеджер состояний и приоритетов UI**.

### 3.1. Менеджер состояний UI (UI State Machine)
Интерфейс будет иметь четко определенные состояния, например:
* `TOP_LEVEL_SELECTION` (выбор основных категорий)
* `DEEP_NAVIGATION` (навигация по подкатегориям, например, "Еда" -> "Супы")
* `ORDER_ACTIVE` (в чеке есть товары)
* `PAYMENT_MODE` (активирован процесс оплаты)

### 3.2. Приоритеты действий (Action Priorities)
Каждому возможному действию (показать товар, оплатить, отменить, назад, и т.д.) будет присвоен числовой приоритет, который **динамически меняется** в зависимости от текущего состояния UI.

* **Пример:**
    * В состоянии `TOP_LEVEL_SELECTION`: Приоритет "Оплатить" = `80`, "Показать категорию" = `70`.
    * В состоянии `DEEP_NAVIGATION` (меню супов): Приоритет "Показать суп" = `100`, "Назад" = `90`, "Оплатить" = `10`.

### 3.3. Контекстный движок компоновки (Contextual Layout Engine)
Перед каждой перерисовкой сетки будет работать специальная функция-планировщик:
1.  Она получает текущее состояние UI и список данных для отображения (например, 12 супов).
2.  Она получает список всех системных действий с их текущими приоритетами.
3.  Она "заполняет" сетку, начиная с действий с самым высоким приоритетом, размещая их в ячейках с наивысшей "вероятностью".
4.  Действия с низким приоритетом размещаются в оставшиеся свободные ячейки или не отображаются вовсе, если места не хватило.

### 3.4. Разделение кнопок
* **Полукнопки (Half-buttons):** Будут зарезервированы для почти статичных, глобальных действий (например, `Переключение вида`, `Время`, `Назад`), так как они важны в большинстве контекстов.
* **Полные кнопки (Full-buttons):** Становятся полностью динамической областью, где и происходит основное "квантовое" размещение.

## 4. Пример работы: Меню супов вытесняет кнопки оплаты

1.  **Состояние:** `TOP_LEVEL_SELECTION`. Пользователь видит категории "Еда", "Напитки". Внизу, в последнем ряду, видны кнопки "Bar", "Karte", так как у них высокий приоритет (`80`).
2.  **Действие:** Пользователь нажимает "Еда", затем "Супы".
3.  **Смена состояния:** Состояние UI меняется на `DEEP_NAVIGATION`.
4.  **Коллапс:** Движок компоновки пересчитывает приоритеты:
    * Приоритет действия "Показать товар (суп)" становится `100`.
    * Приоритет действия "Назад" становится `90`.
    * Приоритет действий "Bar", "Karte" падает до `10`.
5.  **Результат:**
    * Движок размещает все 12 кнопок с супами, занимая почти всю сетку, включая ячейки, где раньше были кнопки оплаты.
    * Кнопка "Назад" (полукнопка) остается на своем месте с высоким приоритетом.
    * Кнопки "Bar" и "Karte" не находят для себя свободных ячеек с достаточным приоритетом и временно исчезают, так как в контексте выбора супа они не нужны.

## 5. Преимущества подхода

* **Контекстуальность:** Пользователь видит только те инструменты, которые ему нужны в данный момент.
* **Эффективность:** Максимальное использование пространства для отображения данных (товаров, категорий).
* **Чистота интерфейса:** Отсутствие лишних кнопок снижает когнитивную нагрузку.
* **Гибкость:** Легкое добавление новых состояний и правил без изменения всей логики UI.








Отличная идея! Документирование архитектурных решений — это ключевой шаг. Я подготовил `.md` файл, который подробно описывает принцип работы нашей новой двухуровневой системы сеток.

Вот содержимое файла:

---

# Архитектура Двухуровневой Сетки ecKasse: Статический Каркас и Динамическое Ядро

## 1. Общая концепция

Новая архитектура интерфейса в `SelectionArea.svelte` основана на принципе разделения двух логических "таблиц" или уровней, которые работают совместно для создания гибкого, но предсказуемого пользовательского интерфейса.

-   **Статический Каркас:** Периферийная область, состоящая из "полукнопок", которая остается относительно неизменной.
-   **Динамическое Ядро:** Центральная область, состоящая из "полных кнопок", которая полностью перестраивается в зависимости от контекста.

Такое разделение позволяет нам сочетать стабильность (важные системные кнопки всегда на месте) и гибкость (центральная область полностью адаптируется под текущую задачу).

---

## 2. Уровень 1: Статический Каркас (Полукнопки)

Это "рама" нашего интерфейса. Она управляется напрямую компонентом `SelectionArea.svelte`.

*   **Ответственность:** Отображение глобальных, высокоприоритетных системных функций, которые должны быть доступны в большинстве контекстов.
*   **Реализация:** Каркас строится на основе массива `gridCells`, который содержит только "полукнопки" (`left-half`, `right-half`). Компонент `SelectionArea.svelte` напрямую итерируется по этому массиву и рендерит `UniversalButton` для каждой ячейки. Логика размещения проста и зависит от четности/нечетности рядов.
*   **Примеры кнопок:** "Назад", "Пользователь/Login", "Время/Настройки", "Переключение раскладки", "Вызов AI".
*   **Ключевая характеристика:** **Стабильность**. Пользователь всегда знает, где найти эти основные элементы управления.

---

## 3. Уровень 2: Динамическое Ядро (Центральная область)

Это "холст" нашего интерфейса, где происходит основное взаимодействие с контентом. Эта область управляется через более сложную абстракцию — `GridManager`.

*   **Ответственность:** Отображение контекстно-зависимого контента: категорий, товаров, кнопок оплаты и других операционных элементов.
*   **Реализация:** Здесь работает ключевое улучшение — **"виртуальная таблица"**.
    1.  **Создание "Карты" (`buildFullGridStructure`):** В памяти создается полная, равномерная сетка (например, 12x4 виртуальных ячеек). Каждая ячейка получает уникальные координаты.
    2.  **Маркировка "Мертвых Зон" (`isPositionUsable`):** В зависимости от выбранной симметрии (`symmetrical` или `asymmetrical`), некоторые ячейки этой карты помечаются как неиспользуемые (`usable: false`). Это позволяет нам сохранять **пропорциональные расстояния** между всеми возможными позициями кнопок, что критически важно для будущей вероятностной модели. Мы не просто создаем "рваную" сетку, а имеем полную карту с отмеченными на ней "препятствиями".
    3.  **Размещение контента (`GridManager`):** `GridManager` получает список контента (например, 15 товаров) и, зная приоритеты, "раскладывает" его по **используемым (`usable: true`)** ячейкам виртуальной таблицы.
*   **Ключевая характеристика:** **Гибкость**. Эта область может полностью меняться, но делает это в рамках предсказуемой и пропорциональной виртуальной сетки.

---

## 4. Принцип взаимодействия двух уровней

Рендеринг полного интерфейса происходит в несколько этапов за один цикл обновления:

1.  `SelectionArea.svelte` измеряет свои физические размеры (ширину и высоту).
2.  На основе этих размеров вызывается `calculateOptimalGrid`, которая определяет оптимальные параметры для **обоих уровней**: количество рядов и колонок, размеры кнопок и тип симметрии.
3.  `SelectionArea.svelte` использует эти параметры, чтобы построить **Статический Каркас** (массив `gridCells` с полукнопками).
4.  Параллельно создается и настраивается `GridManager` для **Динамического Ядра**.
5.  `SelectionArea.svelte` рендерит свои полукнопки из массива `gridCells`.
6.  `GridManager` вычисляет и отдает готовый к рендерингу массив центральных кнопок (`renderableCells`) с уже рассчитанными абсолютными CSS-координатами.
7.  `SelectionArea.svelte` просто итерируется по массиву `renderableCells` и рендерит полные кнопки, применяя к ним готовые стили позиционирования.

### Упрощенный пример в коде:

```svelte
<!-- SelectionArea.svelte (псевдокод) -->

<div class="grid-container-unified">
    
    <!-- Уровень 1: Статический Каркас (Полукнопки) -->
    <!-- Рендерится напрямую из gridCells, который содержит только half-buttons -->
    {#each gridRows as row}
        <div class="button-row">
            {#each row as cell}
                <!-- Логика для рендеринга UniversalButton для полукнопок -->
                <UniversalButton {...getButtonProps(cell)} />
            {/each}
        </div>
    {/each}

    <!-- Уровень 2: Динамическое Ядро (Полные кнопки от GridManager) -->
    <!-- Рендерится из renderableCells, который приходит из GridManager -->
    {#each renderableCells as cell}
        <div class="quantum-button" style="{cell.cssTransform}">
            <!-- Логика для рендеринга UniversalButton для полных кнопок -->
            <UniversalButton {...getCenterButtonContent(cell)} />
        </div>
    {/each}

</div>
```

---

## 5. Преимущества такого подхода

*   **Разделение Ответственности:** Компонент `SelectionArea` отвечает за "раму" и общую структуру, а `GridManager` — за сложную логику размещения контента в центре. Код становится чище.
*   **Производительность:** Статический каркас остается стабильным, в то время как сложным и частым перерасчетам подвергается только динамическое ядро.
*   **Масштабируемость и Будущее:** Эта архитектура с "виртуальной таблицей" является идеальным фундаментом для внедрения нашей главной цели — **вероятностной ("квантовой") модели интерфейса**. Мы сможем легко оперировать координатами и расстояниями в предсказуемой сетке.
*   **Предсказуемость для пользователя:** Глобальные системные кнопки всегда остаются на своих привычных местах по краям, в то время как центральная часть адаптируется под задачу.